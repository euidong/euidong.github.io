<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="description" content="Just Tech Blog"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta property="og:type" content="blog"/><meta property="og:site_name" content="JustLog"/><title>Instruction<!-- --> | JustLog<!-- --></title><meta property="og:title" content="JustLog"/><meta property="og:description" content="Just Tech Blog"/><meta property="og:url" content="https://euidong.github.io"/><meta property="og:image" content="https://euidong.github.io/logo192.png"/><meta name="next-head-count" content="10"/><link rel="icon" href="https://euidong.github.io/favicon.png"/><link rel="apple-touch-icon" href="https://euidong.github.io/logo192.png"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7452732177557701" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/ef7c1611da8b69bb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ef7c1611da8b69bb.css" data-n-g=""/><link rel="preload" href="/_next/static/css/757a2fbfbe37ecc1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/757a2fbfbe37ecc1.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-81da43a8dcd978d9.js" defer=""></script><script src="/_next/static/chunks/main-7b6c38cbad60dfcf.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6690ca4d4e5d76be.js" defer=""></script><script src="/_next/static/chunks/260-70537706ba3e961b.js" defer=""></script><script src="/_next/static/chunks/pages/tags/%5Bsubject%5D-d7c9489aad34918a.js" defer=""></script><script src="/_next/static/1PUrYTUvNPOdAa_sVbKOf/_buildManifest.js" defer=""></script><script src="/_next/static/1PUrYTUvNPOdAa_sVbKOf/_ssgManifest.js" defer=""></script><script src="/_next/static/1PUrYTUvNPOdAa_sVbKOf/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_wrapper__dKJSz root"><header class="Layout_header__XosLl" style="position:sticky"><div><button tabindex="1" class="SideBarToggler_search_bar_toggler__CEuUg"><svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 24 24" height="35px" width="35px" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor"></path><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor"></path><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor"></path></svg></button><nav class="SideBar_side_bar__wrapper--close__8Nwnr"><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/">Home</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/tags">Tags</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Algorithm">Algorithm<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->11<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Computer%20Architecture">Computer Architecture<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->7<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Web">Web<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->3<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Network">Network<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->9<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Tech">Tech<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->1<!-- -->)<!-- --></span></a></nav></div><a class="Logo_logo___yD0t" tabindex="1" href="/"></a><div><button class="SearchBarToggler_search_bar_toggler__3dHbA" tabindex="2"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="25px" width="25px" xmlns="http://www.w3.org/2000/svg"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"></path></svg></button></div></header><section><div class="RowCard_row_card__list__background___xFj5"><h1 class="RowCard_row_card__list__title__t4a2h"> Instruction</h1><ul class="RowCard_row_card__list__wrapper__5Gtgi"><div class="RowCard_row_card__wrapper__kohuv"><a class="RowCard_row_card__thumbnail__wrapper__bedY4" href="/posts/architecture-instruction"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:200px;height:200px;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fixed" class="RowCard_row_card__thumbnail__Dh_84" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/default.jpg?imwidth=256 1x, https://euidong.github.io/images/default.jpg?imwidth=640 2x" src="https://euidong.github.io/images/default.jpg?imwidth=640" decoding="async" data-nimg="fixed" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="RowCard_row_card__thumbnail__Dh_84" loading="lazy"/></noscript></span></a><div class="RowCard_row_card__tray__trcA5"><a class="RowCard_row_card__tray__title__lVniM" tabindex="-1" href="/posts/architecture-instruction">2. Instruction</a><div class="RowCard_row_card__tray__date__3cY_j">2022년 4월 14일 09시 00분</div><ul class="RowCard_row_card__tray__tag__qXmOl"><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/Computer%20Organization%20And%20Design"># <!-- -->Computer Organization And Design<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/Instruction"># <!-- -->Instruction<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/ISA"># <!-- -->ISA<!-- --></a></ul></div></div></ul></div>;<!-- --></section><footer class="Layout_footer__EL5v8"><div class="Layout_footer__copyright__r5baC"><span>Copyright © euidong</span><br/><span>모든 컨텐츠에 대한 저작권은 작성자에게 존재합니다. <!-- --><br/>불법 복제를 통한 상업적 사용을 절대적으로 금지합니다. <!-- --><br/>단, 비상업적 이용의 경우 출처 및 링크를 적용한다면 자유롭게 사용가능 합니다.<!-- --></span><span>Also I use photos by<!-- --> <!-- --><a href="https://unsplash.com/@lorenzoherrera?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Lorenzo Herrera</a> <!-- -->on<!-- --> <!-- --><a href="https://unsplash.com/s/photos/tech?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Unsplash</a></span></div><div class="Layout_footer__contents__YZWSm"><a class="Layout_footer__contents__link__K_TKH" href="https://github.com/euidong" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>github</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://euidong.github.io/portfolio" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M6 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-5 6s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H1zM11 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5zm.5 2.5a.5.5 0 0 0 0 1h4a.5.5 0 0 0 0-1h-4zm2 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2zm0 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2z"></path></svg><span>portfolio</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://chrome.google.com/webstore/detail/bonfire/nkooidijgbppkojdgkoafcoppnohdfka?hl=ko" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M5.016 16c-1.066-2.219-0.498-3.49 0.321-4.688 0.897-1.312 1.129-2.61 1.129-2.61s0.706 0.917 0.423 2.352c1.246-1.387 1.482-3.598 1.293-4.445 2.817 1.969 4.021 6.232 2.399 9.392 8.631-4.883 2.147-12.19 1.018-13.013 0.376 0.823 0.448 2.216-0.313 2.893-1.287-4.879-4.468-5.879-4.468-5.879 0.376 2.516-1.364 5.268-3.042 7.324-0.059-1.003-0.122-1.696-0.649-2.656-0.118 1.823-1.511 3.309-1.889 5.135-0.511 2.473 0.383 4.284 3.777 6.197z"></path></svg><span>chat</span></a></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"content":"\n## **Reference**\n\n![default](/images/default.jpg)\n\nDavid A. Patterson, John L. Hennessy, Computer Organization and Design\n\n본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 \"-다\"로 표현합니다.\n\n---\n\n컴퓨터가 알아들을 수 있는 명령을 우리는 Instruction이라고 한다. 그렇다면, 이들을 모아놓은 단어장(Vocabulary)는 **Instruction set**이 되는 것이다. 이런 의미에서 현대의 computer는 이를 기반으로 동작하도록 설계되었기 때문에, 이를 **Instruction set architecture**라고 부른다. 해당 책에서는 MIPS를 기준으로 하기 때문에 똑같이 MIPS를 기준으로 설명합니다. 이는 다른 processor들과 매우 유사하니 이를 배우면 쉽게 다른 것도 이해할 수 있을 것이다.\n\n그렇다면, Instruction이란 무엇일까? 이는 기계어(0과 1로 이루어진 이진수 체계)의 형태로 표현된다. 따라서, 이를 Assembly Instruction이라고도 한다. 이는 hardware에게 특정 동작을 수행하도록 하는 명령어라고 할 수 있다. 그렇기에 우리가 실행하거나 작성하는 모든 program들은 사실 Instruction들의 집합이라고 볼 수 있다. 실제로 Computer에서 Program이 동작할 때, 이는 Computer는 memory에 program의 내용과 program에서 사용할 data들을 위한 공간을 배정해준다. 그런 후에 실제로 실행될 때에는 program의 Instruction을 차례차례 읽어가면서 실행하는 것이다.\n\n---\n\n## **Assembly Instruction의 구성요소**\n\n기본적으로 MIPS는 32bit(=4Bytes) 시스템을 사용한다. 따라서, 하나의 Instruction은 4 Bytes로 표현된다. 이를 하나의 가장 단위라고 여겨서 word라고도 부른다. 따라서, 64bit(=8Bytes) CPU에서는 1 word가 8 Bytes가 될 수도 있다. 결국 모든 Instruction이 0과 1로 이루어진다. 하지만, 이는 너무 읽기 어렵기 때문에 우선 Assembly(기계어보다는 사람의 언어에 가깝지만 아주 원초적인 형태의 언어) Instruction을 알아볼 것이다. 이를 기계어로 바꾸는 것은 해당 포스팅의 밑에서 다룬다.\n\n### **1\\. Operand**\n\n연산을 위해서 필요한 것은 연산자와 피연산자이다. 보통의 programming 언어에서는 이를 변수라고 한다.\n\nMIPS에서는 총 두 가지의 변수 type이 존재한다.\n\n1. **Constant**  \n    하나의 상수로써 동작하는 변수이다. 주어진 범위 내에서 자유롭게 상수로 사용가능하다.\n2. **Register No**  \n    하드웨어 상의 register들과 programming에서의 변수와 차이점이 있다면, 바로 갯수의 제한이 있다는 것이다. 보통은 갯수를 32개로 제한한다. 그렇게 하는 것이 효율적이라고 찾아냈다고 한다. 더 많이 써도 Clock Cycle이 더 소모될 뿐이고, 적다면 표현력이 부족해지 수도 있다. 또한, 하나의 register의 크기 또한 우리는 대게 32bit(1 word)로 제한한다. 이를 표현할 때에는 보통 \\$ 표시를 활용하고, register는 특정 목적을 위해서 지정되어 있다. (밑에 표를 참고)  \n    Instruction에서는 Register를 가르키기 위해서 5bit를 사용한다. $2^5$이면 모든 Register를 구분할 수 있기 때문이다.\n3. **Memory Address**  \n    해당 공간에는 기본적으로 register에 담기진 못한 모든 정보가 저장된다. 왜냐하면, register 가 하나의 변수를 표현할 수 있는데 만약, 변수가 32개를 넘어간다면, 이를 처리하는 것이 매우 버거워진다. 따라서, 이를 임시로 저장해두어야 한다. 따라서, 이를 memory에 잠깐 저장하는데 이를 **spilling register**라고 부른다.  \n    좀 더 복잡한 데이터 구조를 가지는 경우에도 이를 모두 register에 담는 것은 불가능하다. 따라서, 우리는 Memory라는 것을 활용한다. Memory는 8bit 단위로 한 칸으로 나누어 4개의 칸을 합친 것을 하나의 단위로 봅니다. (왜냐하면 이것이 4x8bit = 32bit = 1word가 되기 때문이다.) 따라서, 우리가 특정 값에 접근할 때에는 4의 배수로 접근하는 것이 올바른 접근이다. 또한, 하나의 데이터가 4개의 칸으로 쪼개지기 때문에 저장 방법에 차이가 있을 수 있다. 어떤 사람들은 앞 자리부터 차곡차곡 넣을 수도 있지만, 누구는 역순으로도 넣을 수 있기 때문에 이를 유의해야 한다. MIPS에서는 앞에서붙터 차곡차곡 넣는 Big Endian 방식을 사용한다. (즉, 4개 중 가장 낮은 주소값에 높은 값을 의미하는 값(MSB)이 쓰인다.)  \n    하나의 Memory address를 가르키기 위해서는 32bit가 필요하다. 이렇게 하여 $2^{32}$ = 4GB 이하까지의 Memory는 가르킬 수 있는 것이다. Instruction 자체가 32bit인데, 이를 Instruction에 바로 넣을 수는 없기 때문에 특정 Memory address를 가르키기 위해서 별도의 register에 해당 Memory의 address를 저장해두고 해당 지점부터 offset을 constant로 전달하는 식으로 표기한다.(여기서 4의 배수로 memory가 표현되므로, 2bit를 뺀다고 해도 30bit로 여전히 많다.)\n\n다음은 MIPS의 Register와 Memory를 나타낸 것이다.\n\n![registers](/images/registers.png)\n\n상식적으로 알아두고 갈 부분은 reigster는 직접적으로 연산이 이루어지는 곳이기 때문에, register에 접근하는 비용이 memory에 접근하는 부분보다 확연하게 비용이 싸다.(시간이 짧게 걸린다.) 따라서, 이를 효율적으로 다루어주는 것이 효율 향상에 도움이 된다.\n\n#### **2\\. Operation**\n\n모든 computer는 기본적인 연산을 수행할 수 있어야 한다. MIPS에서는 다음과 같은 표기법을 사용한다.\n\n```plaintext\n1. \u003c명령어(operation)\u003e \u003c연산자(operand) 1\u003e \u003c연산자(operand) 2\u003e \u003c연산자(operand) 3\u003e\n\n2. \u003c명령어(operation)\u003e \u003c연산자(operand) 1\u003e \u003c연산자(operand) 2\u003e\n\n3. \u003c명령어(operation)\u003e \u003c연산자(operand)\u003e\n```\n\n마치 우리가 영어를 처음 배울 때, 1형식, 2형식 배우는 형태랑 유사하다. 그리고 여기서는 모든 문장이 명령형으로 구성된다는 점을 유의하자. 이에 따라서, 다음 MIPS의 피연산자(operand)와 주요 Operation을 살펴보자.\n\n\u003e **Add / Substract**\n\n`add [연산자1] [연산자2] [연산자3]`\n\n모든 연산의 기본으로 위의 형태 중에서 첫번째에 해당한다. 이를 수학 기호로 나타내면 다음과 같다.\n\n`[연산자1] = [연산자2] + [연산자3]`\n\nSubstraction 연산도 이와 동일하게 동작한다.\n\n\u003e **Load / Save**\n\n우리가 Register에 특정 데이터를 저장하기를 원한다면, $zero register 에 저장하기를 원하는 값 또는 register를 add해서 해당 register에 저장하면 된다.\n\n`add [저장을 원하는 register No] [$zero] [1234]`\n\n하지만, Memory에 데이터를 저장하기 위해서는 별도의 명령어가 필요하다. 그것이 save 명령어 입니다. 앞 서 말한 것과 같이 memory address를 직접적으로 Instruction에 표현할 수는 없기 때문에 특정 register에 주소값을 저장하고, 해당 주소를 base로 해서 offset을 더해서 주소를 찾는 형태로 수행한다.\n\n`sw [불러올 register No] [Memory의 Base Address를 가진 register No] offset`\n\n이와 반대로 Memory에서 데이터를 register로 불러올 때에도 별도의 명령어가 필요하다.\n\n`lw [불러올 register No] [Memory의 Base Address를 가진 register No] offset`\n\n\u003e **Jump**\n\nInstruction 역시 Memory에 상주하고 있는데, 만약 필요에 따라 이전 Instruction으로 돌아가거나 Instruction을 뛰어넘어야 한다면, 그때 사용할 수 있는 Instruction이다.\n\n`j [이동할 instruction offset]`\n\n\u003e **Branch**\n\nBranch(분기)는 특정 조건의 부합 여부를 확인하고, Jump를 수행하는 Instruction이다. 이를 위한 operator가 beq, bne가 있다.\n\n`beq [비교할 register1] [비교할 register2] [이동할 instruction offset]`\n\nregister1과 2가 서로 동일하다면, 해당 instruction offset으로 이동하라는 의미이다. bne는 반대로 두 register가 다를 때에 이동할 수 있다.\n\n\u003e **기타 주요 명령어**\n\n![instruction](/images/instruction.png)\n\n\\* PC : Program Counter의 줄임말로 현재 실행하고 있는 Program에서 어느 위치의 Instruction을 실행시키고 있는지를 나타낸다. 이를 이용해서 CPU는 다음 Instruction을 불러온다.\n\n\\* offset : offset은 대게 instruction 단위로 나타내기 때문에 1 offset은 4Bytes를 의미한다. 따라서, offset을 실제 주소에 더할 때에는 곱하기 4(실제로는 shift left 2)를 해야한다. 이로 인해서, 현재 Instruction의 다음 Instruction의 주소를 PC+4 라고 한다.\n\n---\n\n## **Instruction를 이용한 Programming 언어 기본 요소 구현**\n\n### **1\\. 조건문 (if / else)**\n\n```pseudo\nif (i == j) \n f = g + h;\nelse\n f = g - h;\n```\n\n다음과 같은 c의 조건문 코드를 아래와 같은 Instruction들로 변환이 가능하다.\n\n```pseudo\nbne $s3, $s4, Else # go to Else if i != j\nadd $s0, $s1, $s2 # f = g + h (skipped if i != j)\nj Exit # go to Exit\n\nElse: \nsub $s0, $s1, $s2 # f = g - h (skipped if i = j)\n\nExit:\n```\n\n여기서 Else는 임의의 offset을 나타낸다. 따라서, \"Else:\"라고 표시된 부분에 해당하는 offset이라고 생각하면 된다.\n\nSwitch/Case 문 같은 경우는 if/else로 변환해서 나타내기도 하고, 아니면 Switching 위치를 적어놓은 Table을 만들어서 해당 위치로 바로 이동하는 식으로 구현하기도 한다.\n\n### **2\\. 반복문 (while)**\n\n```pseudo\nwhile(save[i] == k)\n i += 1;\n```\n\n다음과 같은 c의 반복문을 아래와 같은 Instruction들로 변환이 가능하다.\n\n```pseudo\n# $t1 : save[i] address pointer\n# $t0 : save[i] value\n# $s3 : i\n# $s6 : save의 base address (save[0] address pointer)\n# $s5 : k\n\n# sll shift left \"\u003c\u003c\" 를 의미합니다. \n# 즉, 아래에서는 두 번하므로, *2^2를 의미합니다.\nLoop: \nsll $t1, $s3, 2 # temp reg $t1 = i * 4\nadd $t1, $t1, $s6 # $t1 = address of save[i]\nlw $t0, 0($t1) # temp reg $t0 = save[i]\nbne $t0, $s5, Exit # go to Exit if save[i] != k\naddi $s3, $s3, 1 # i = i + 1\nj Loop # go to Loop\n\nExit:\n```\n\n### **3\\. 함수 (function)**\n\nprocedure는 대게 function(함수)이라고도 불린다. 함수를 우리는 하나의 예시를 통해서 설명할 수 있다.\n\nprocedure를 비밀 작전을 맡고 떠난 spy라고 하자. 작전은 자원을 습득하여, 특정 작업을 수행하고, 흔적을 감춘 뒤에, 바람직한 결과를 들고 돌아오는 것을 의미한다. 즉, spy는 작업을 마치고, 원하는 결과를 갖고 왔지만, 해당 결과 외에는 아무것도 바뀌지 않기를 기대한다. (누군가한테 의심받지 않아야하기 때문에)\n\n이러한 과정이 똑같이 함수의 호출마다 발생한다. 아래는 이를 다소 축약한 형태입니다.\n\n1. parameter를 procedure가 접근할 수 있는 곳에 위치시킵니다.\n2. control을 procedure(callee)로 옮깁니다.\n3. procedure는 해당하는 자원(parameter)을 습득합니다.\n4. 목표한 바를 수행합니다.\n5. 결과값을 자신을 호출한 program(caller)이 접근할 수 있는 곳에 위치시킵니다.\n6. control을 호출한 곳(caller)으로 넘깁니다.\n\n\\* 여기서 control이 이동했다는 것은 \bPC값이 PC+4가 아닌 함수의 주소로 이동했다는 것을 의미합니다.\n\n이를 구현하기 위해서 우리는 다음과 같은 별도의 register를 사용합니다.\n\n```pseudo\n$a0 - $a3 : 4 argument(=parameter) registers.\n$v0 - $v1 : 2 return value registers.\n$ra : 1 return address register. 원래 위치를 기억하기 위한 register.\n```\n\n\\$a와 \\$v는 사실 함수 사용에서 필수적이기 때문에 쉽게 받아들일 수 있지만, \\$ra가 의아할 수 있을 것이다. 이는 procedure를 호출했던 시점으로 다시 돌아오기 위해서 호출한 시점의 주소(실제로는 호출한 시점에서 다음 Instruction의 주소)를 저장하고 있는 것이다. 이러한 과정 즉, \\$ra에 저장과 jump를 동시에 해주는 것이 jal instruction이다. 이는 바로 다음 instruction을 가르키도록 하여 PC+4로 저장하고, 특정 지점으로 이동한다. 그리고 돌아올 때에는 jr instruction을 이용해서 \\$ra로 돌아올 수 있다.\n\n만약, 더 많은 변수를 return value, argument로 쓰고 싶다면 우리는 이를 memory로 옮기는 과정을 수행해야 한다. 이때, computer 에서는 stack이라는 구조를 사용한다. (실제로 구현하는 것은 아니고, 마치 stack 처럼 사용하기에 이렇게 부른다.) Stack pointer라는 register(\\$sp)를 이용하여 현재 사용하고자 하는 data가 stack의 어디를 가르키고 있는지를 저장한다.\n\n\u003e **실제 예제**\n\n```c\nint leaf_example (int g, int h, int i, int j) {\n int f;\n \n f = (g + h) - (i + j);\n return f;\n}\n```\n\n```c\nleaf_example:\naddi $sp, $sp, –12 # adjust stack to make room for 3 items\nsw $t1, 8($sp) # save register $t1 for use afterwards\nsw $t0, 4($sp) # save register $t0 for use afterwards\nsw $s0, 0($sp) # save register $s0 for use afterwards\n\nadd $t0,$a0,$a1 # register $t0 contains g + h\nadd $t1,$a2,$a3 # register $t1 contains i + j\nsub $s0,$t0,$t1 # f = $t0 – $t1, which is (g + h)–(i + j)\n\nadd $v0,$s0,$zero # returns f ($v0 = $s0 + 0)\n\nlw $s0, 0($sp)  # restore register $s0 for caller\nlw $t0, 4($sp)  # restore register $t0 for caller\nlw $t1, 8($sp)  # restore register $t1 for caller\naddi $sp,$sp,12 # adjust stack to delete 3 items\n\njr $ra # jump back to calling routine\n```\n\n해당 방식을 통해서, 만약 우리가 argument를 각 argument register 채워주고, \"jal leaf\\_example\"를 수행하게 되면, 해당 함수를 실행하는 것과 같은 동작을 하게 되는 것이다.\n\n하지만, 더 고민해야 하는 경우가 있다. 바로 함수 안에서 또 함수를 호출하는 경우이다.\n\n\u003e **Nested Function call(Function 내부에서 Function의 호출)**\n\nprocedure가 또 procedure를 호출하는 경우에는 어떻게 해야할까? 이 때에는 간단한게 stack의 retuern address를 저장해놓고, \\$ra를 덮어씌우는 식으로 작동한다. 아래는 recursive call을 수행한 경우를 담은 내용이다.\n\n```c\nint fact (int n) {\n if (n \u003c 1) \n  return 1;\n else\n  return n * fact(n-1); \n}\n```\n\n```pseudo\nfact:\naddi  $sp, $sp, –8    # adjust stack for 2 items\nsw    $ra, 4($sp)     # save the return address\nsw    $a0, 0($sp)     # save the argument n\n# slti 는 $a0의 값이 상수보다 작다면, 0 크다면 1이 저장됩니다.\nslti  $t0, $a0, 1     # test for n \u003c 1\nbeq   $t0, $zero, L1  # if n \u003e= 1, go to L1\n\naddi  $sp, $sp, 8     # pop 2 items off stack\n\naddi  $v0, $zero, 1   # return 1\njr    $ra             # return to caller\n\nL1: addi $a0,$a0,–1   # n \u003e= 1: argument gets (n – 1)\njal fact              # call fact with (n –1)\n\nlw $a0, 0($sp)        # return from jal: restore argument n \nlw $ra, 4($sp)        # restore the return address\naddi $sp, $sp, 8      # adjust stack pointer to pop 2 items\n\nmul $v0,$a0,$v0       # return n * fact (n – 1)\njr   $ra              # return to the caller\n```\n\n이제 끝일 거 같지만, 마지막으로 생각해야 할 게 있다. 바로 내부에서 또 local variable을 선언한 경우이다. 이 경우에도 memory에 공간에 저장해야 하는데 이때에도 stack pointer를 이동 시켜서 구현하는 것은 후에 동작에 혼란을 야기할 수 있다. 따라서, frame pointer라는 것을 추가로 할당하였다. 이는 함수의 진입 시점에 stack pointer의 초기 위치를 가르킨다. 따라서, 쉽게 후에 돌아올 지점을 알 수 있기에 stack pointer를 더 유동적으로 움직일 수 있다.\n\n---\n\n## **여러 변수 형태 표현법**\n\n### **Signed Numbers**\n\n일반적으로 unsigned number라고 하면, 0과 양수를 포함하는 범위이다. 하지만, signed number는 음수까지 포함한다. 그렇다면, 컴퓨터에서는 음수를 어떻게 표현할 수 있을까?\n\n사람의 머리로 가장 쉽게 생각할 수 있는 방법은 부호를 나타내기 위한 별도의 표시 bit를 하나 넣어주면 될 거 같다는 생각을 할 것이다. 이것이 정확하다. 바로 오른쪽 끝에 있는 bit가 1이면 음수 0이면 양수로 보는 방식이다. 1이 맨 앞에 올 때는 0이 원래 1의 역할을 대신한다. 그리고 0이 앞에 올 때는 원래 계산하던대로 수행하면 된다. 그러면 놀랍게도 우리가 생각하는 것처럼 덧셈 뺄셈 연산이 동작한다. 그리고 오른쪽 끝에 있는 수를 우리는 MST 라고 하고, 이를 sign bit라고 부른다.\n\n```pseudo\n0000 0000 0000 0000 0000 0000 0000 0000(two) = 0(ten) \n0000 0000 0000 0000 0000 0000 0000 0001(two) = 1(ten)\n0000 0000 0000 0000 0000 0000 0000 0010(two) = 2(ten)\n...\n0111 1111 1111 1111 1111 1111 1111 1101(two) = 2,147,483,645(ten)\n0111 1111 1111 1111 1111 1111 1111 1110(two) = 2,147,483,646(ten)\n0111 1111 1111 1111 1111 1111 1111 1111(two) = 2,147,483,647(ten)\n1000 0000 0000 0000 0000 0000 0000 0000(two) = –2,147,483,648(ten)\n1000 0000 0000 0000 0000 0000 0000 0001(two) = –2,147,483,647(ten)\n1000 0000 0000 0000 0000 0000 0000 0010(two) = –2,147,483,646(ten)\n...\n1111 1111 1111 1111 1111 1111 1111 1101(two) = –3(ten)\n1111 1111 1111 1111 1111 1111 1111 1110(two) = –2(ten)\n1111 1111 1111 1111 1111 1111 1111 1111(two) = –1(ten) \n```\n\n\u003e **Proof**\n\n```pseudo\n# 덧셈\n  1111 1111 1111 1110 (-2)\n+                   1 (+1)\n----------------------\n  1111 1111 1111 1111 (-1)\n\n\n                   11  (+3)\n+ 1111 1111 1111 1000  (-8)\n----------------------\n  1111 1111 1111 1011  (-5)\n\n\n# 뺄셈 1\n  1111 1111 1111 1110 (-2)\n-                   1 (+1)\n----------------------\n  1111 1111 1111 1101 (-3)\n\n\n# 뺄셈 2\n                   11  (+3)\n- 1111 1111 1111 1000  (-8)\n----------------------\n                   11  (+3)\n+ 0000 0000 0000 1000  (+8)\n----------------------\n  0000 0000 0000 1011  (+11)\n```\n\n연산을 하다보면, 당연히 너무 큰 양수를 더하게 되면 overflow가 발생할 수 있는데 이 경우 운영체제마다 compiler마다 처리 방식이 상이하다. C에서는 overflow가 되면 그대로 값을 내놓기 때문에, 대게 굉장히 큰 음수가 나오게 된다.\n\n### **Character**\n\ncomputer에서 수가 아닌 값을 어떻게 표현할 수 있는가는 ASCII code 표가 답해줄 수 있을 것이다. 하나의 문자를 우리는 character라고 부르고, ASCII code 표와 같은 방식을 통해서 수를 글자로 변환하여 표현한다. 또한, 하나의 문자가 아닌 단어, 문장에 이르게 되면 이를 우리는 string이라고 하며, 이는 이 데이터의 길이를 표기하기 위해서 다음 3가지 중 하나를 선택하게 된다.\n\n1. string의 가장 앞에 길이를 나타내는 값을 넣어준다.\n2. string을 구조체로 만들어서 길이를 나타내는 값을 따로 넣는다.\n3. string의 가장 끝 문자를 구분자로 채워서 구분할 수 있도록 한다. ⇒ C에서는 \\\\0 을 사용하여 구분한다.\n\n---\n\n## **Representing Instruction with Machine Language**\n\n위에 나온 MIPS Assembly code를 이제 MIPS의 기계어로 변환하는 과정을 수행할 것이다.\n\n다시 한 번 설명하자면, 우리의 program들은 사실상 instruction의 집합이라고 볼 수 있다. 또한, 현대의 컴퓨터는 이러한 instruction들을 memory에 마치 데이터처럼 쌓아서 실행시킨다. 그래서 우리는 이러한 프로그램 실행 방식을 **stored program** 이라고 부른다. 우리는 위에서 memory에 데이터를 저장하기 위해서 하나의 word 즉 32bit를 사용했다. 따라서, 우리의 instruction도 하나의 word 단위로 표현한다.\n\n아래 그림은 32bit의 각 각 부분이 무엇을 의미하는지를 표현한 것이다. 위의 연산을 표시하기 위해서 다음과 같이 word를 구분한다. 이때 주의할 점은 큰 값을 처리할 때에는 I-Type을 사용하기 때문에 형태가 기본형인 R-Type과는 다소 다른 것을 볼 수 있다.\n\n\u003e **R-Type**\n\n![r-type](/images/r-type.png)\n\n- op : opcode라고 불리며, instruction의 동작이 무엇인지를 정의한다. (ex. add, jump, ...)\n- rs : first source register\n- rt : second source register\n- rd : destination register. 연산의 결과값이 저장되는 위치를 의미한다.\n- shamt : shift amount라는 의미로 shift 연산을 사용할 때 이용된다.\n- funct : op field에서 구체적인 동작을 정의할 때 사용한다.\n\n\u003e **I-Type**\n\n![i-type](/images/i-type.png)\n\n- op : opcode라고 불리며, instruction의 동작이 무엇인지를 정의한다. (ex. addi, jump, ...)\n- rs : first source register\n- rt : second source register\n- constraint or address : 긴 값이 필요한 연산에서는 다음과 같은 형태로 표현한다.\n\n## **Addressing**\n\nMIPS는 여러가지 instruction을 가지고 있기 때문에, 주소를 targeting하는 방식도 여러가지이다. 또한, 따른 instruction set architecture에서도 다양한 방법을 통해서 memory의 주소를 가르킨다.\n\n1. Immediate addressing : 상수를 통해 직접 address를 지정하는 방식이다.\n2. Register addressing : register로 address를 지정하는 방식이다.\n3. Base addressing : 상수에 특정 register값을 더해서 구하는 방식이다.(MIPS → Load Word, Save Word)\n4. PC-relative addressing : PC 값에 상수 값을 더해서 구하는 방식이다. (MIPS → Branch)\n5. Psedodirect addressing : PC의 맨앞 내자리를 가져와서 쓰는 방식이다. (MIPS → Jump)\n","slug":"architecture-instruction","date":"2022-04-14 09:00","title":"2. Instruction","category":"Computer Architecture","tags":["Computer Organization And Design","Instruction","ISA"],"thumbnailSrc":"https://euidong.github.io/images/default.jpg"}],"params":{"subject":"Instruction"}},"__N_SSG":true},"page":"/tags/[subject]","query":{"subject":"Instruction"},"buildId":"1PUrYTUvNPOdAa_sVbKOf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>