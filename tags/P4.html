<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="description" content="Network 분야에 관심이 많은 개발자로 Computer Engineering 관련 Posting을 주로 다룹니다."/><meta property="og:description" content="Network 분야에 관심이 많은 개발자로 Computer Engineering 관련 Posting을 주로 다룹니다."/><meta property="og:type" content="blog"/><meta property="og:site_name" content="JustLog"/><meta property="og:image" content="https://euidong.github.io/logo192.png"/><title>#P4 | JustLog</title><meta property="og:title" content="#P4 | JustLog"/><link rel="canonical" href="https://euidong.github.io/tags/P4"/><meta property="og:url" content="https://euidong.github.io/tags/P4"/><meta name="next-head-count" content="11"/><link rel="icon" href="https://euidong.github.io/favicon.png"/><link rel="apple-touch-icon" href="https://euidong.github.io/logo192.png"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7452732177557701" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/51df76ed4222d2c7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/51df76ed4222d2c7.css" data-n-g=""/><link rel="preload" href="/_next/static/css/6dc16d084a5153e5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6dc16d084a5153e5.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-81da43a8dcd978d9.js" defer=""></script><script src="/_next/static/chunks/main-7b6c38cbad60dfcf.js" defer=""></script><script src="/_next/static/chunks/pages/_app-ebec51e3d382049a.js" defer=""></script><script src="/_next/static/chunks/675-ae8e8a351ce30ae2.js" defer=""></script><script src="/_next/static/chunks/pages/tags/%5Bsubject%5D-2ecacdd7ae5454e8.js" defer=""></script><script src="/_next/static/59TaE6vt_3amu4s4GZ6KA/_buildManifest.js" defer=""></script><script src="/_next/static/59TaE6vt_3amu4s4GZ6KA/_ssgManifest.js" defer=""></script><script src="/_next/static/59TaE6vt_3amu4s4GZ6KA/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_wrapper__dKJSz root"><header class="Layout_header__XosLl" style="position:sticky"><div><button tabindex="1" class="SideBarToggler_search_bar_toggler__CEuUg"><svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 24 24" height="35px" width="35px" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor"></path><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor"></path><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor"></path></svg></button><nav class="SideBar_side_bar__wrapper--close__8Nwnr"><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/">Home</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/tags">Tags</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Algorithm">Algorithm<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->11<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Computer%20Architecture">Computer Architecture<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->7<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Tech">Tech<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->16<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Web">Web<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->4<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Network">Network<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->11<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/ML">ML<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->1<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Paper">Paper<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->1<!-- -->)<!-- --></span></a></nav></div><a class="Logo_logo___yD0t" tabindex="1" href="/"></a><div><button class="SearchBarToggler_search_bar_toggler__3dHbA" tabindex="2"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="25px" width="25px" xmlns="http://www.w3.org/2000/svg"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"></path></svg></button></div></header><section><div class="RowCard_row_card__list__background___xFj5"><h1 class="RowCard_row_card__list__title__t4a2h"> P4</h1><label class="RowCard_row_card__list__select__wrapper__TZ4_9"><select class="RowCard_row_card__list__select__dxkxA"><option class="RowCard_row_card__list__select__option__GRKZU">최신순<!-- --></option><option class="RowCard_row_card__list__select__option__GRKZU">AtoZ<!-- --></option><option class="RowCard_row_card__list__select__option__GRKZU">ZtoA<!-- --></option></select></label><ul class="RowCard_row_card__list__wrapper__5Gtgi"><div class="RowCard_row_card__wrapper__kohuv"><a class="RowCard_row_card__thumbnail__wrapper__bedY4" href="/posts/p4"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:200px;height:200px;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><img alt="P4" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fixed" class="RowCard_row_card__thumbnail__Dh_84" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="P4" srcSet="https://euidong.github.io/images/p4-icon.png?imwidth=256 1x, https://euidong.github.io/images/p4-icon.png?imwidth=640 2x" src="https://euidong.github.io/images/p4-icon.png?imwidth=640" decoding="async" data-nimg="fixed" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="RowCard_row_card__thumbnail__Dh_84" loading="lazy"/></noscript></span></a><div class="RowCard_row_card__tray__trcA5"><a class="RowCard_row_card__tray__title__lVniM" tabindex="-1" href="/posts/p4">P4</a><div class="RowCard_row_card__tray__date__3cY_j">2022년 6월 9일 17시 29분</div><ul class="RowCard_row_card__tray__tag__qXmOl"><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/SDN"># <!-- -->SDN<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/P4"># <!-- -->P4<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/ProgrammableSwitch"># <!-- -->ProgrammableSwitch<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/DataPlane"># <!-- -->DataPlane<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/OpenFlow"># <!-- -->OpenFlow<!-- --></a></ul></div></div><div class="RowCard_row_card__wrapper__kohuv"><a class="RowCard_row_card__thumbnail__wrapper__bedY4" href="/posts/sdn"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:200px;height:200px;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><img alt="SDN" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fixed" class="RowCard_row_card__thumbnail__Dh_84" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="SDN" srcSet="https://euidong.github.io/images/network-background.jpg?imwidth=256 1x, https://euidong.github.io/images/network-background.jpg?imwidth=640 2x" src="https://euidong.github.io/images/network-background.jpg?imwidth=640" decoding="async" data-nimg="fixed" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="RowCard_row_card__thumbnail__Dh_84" loading="lazy"/></noscript></span></a><div class="RowCard_row_card__tray__trcA5"><a class="RowCard_row_card__tray__title__lVniM" tabindex="-1" href="/posts/sdn">SDN</a><div class="RowCard_row_card__tray__date__3cY_j">2022년 5월 25일 09시 00분</div><ul class="RowCard_row_card__tray__tag__qXmOl"><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/SDN"># <!-- -->SDN<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/NFV"># <!-- -->NFV<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/OpenFlow"># <!-- -->OpenFlow<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/ONOS"># <!-- -->ONOS<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/OpenDayLight"># <!-- -->OpenDayLight<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/P4"># <!-- -->P4<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/DPDK"># <!-- -->DPDK<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/FD.io"># <!-- -->FD.io<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/OpenStack"># <!-- -->OpenStack<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/CORD"># <!-- -->CORD<!-- --></a></ul></div></div></ul></div></section><footer class="Layout_footer__EL5v8"><div class="Layout_footer__copyright__r5baC"><span>Copyright © euidong</span><br/><span>모든 컨텐츠에 대한 저작권은 작성자에게 존재합니다. <!-- --><br/>불법 복제를 통한 상업적 사용을 절대적으로 금지합니다. <!-- --><br/>단, 비상업적 이용의 경우 출처 및 링크를 적용한다면 자유롭게 사용가능 합니다.<!-- --></span><span>Also I use photos by<!-- --> <!-- --><a href="https://unsplash.com/@lorenzoherrera?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Lorenzo Herrera</a> <!-- -->on<!-- --> <!-- --><a href="https://unsplash.com/s/photos/tech?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Unsplash</a></span></div><div class="Layout_footer__contents__YZWSm"><a class="Layout_footer__contents__link__K_TKH" href="https://github.com/euidong" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>github</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://euidong.github.io/portfolio" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M6 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-5 6s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H1zM11 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5zm.5 2.5a.5.5 0 0 0 0 1h4a.5.5 0 0 0 0-1h-4zm2 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2zm0 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2z"></path></svg><span>portfolio</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://chrome.google.com/webstore/detail/bonfire/nkooidijgbppkojdgkoafcoppnohdfka?hl=ko" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M5.016 16c-1.066-2.219-0.498-3.49 0.321-4.688 0.897-1.312 1.129-2.61 1.129-2.61s0.706 0.917 0.423 2.352c1.246-1.387 1.482-3.598 1.293-4.445 2.817 1.969 4.021 6.232 2.399 9.392 8.631-4.883 2.147-12.19 1.018-13.013 0.376 0.823 0.448 2.216-0.313 2.893-1.287-4.879-4.468-5.879-4.468-5.879 0.376 2.516-1.364 5.268-3.042 7.324-0.059-1.003-0.122-1.696-0.649-2.656-0.118 1.823-1.511 3.309-1.889 5.135-0.511 2.473 0.383 4.284 3.777 6.197z"></path></svg><span>chat</span></a></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"content":"\n## Intro\n\nP4는 Programmable Switch, 즉 Hardware에 묶여있는 Software를 통해 DataPlane을 사용하는 것이 아닌 필요에 따라 Switch의 DataPlane을 직접 Programming하여 사용하는 새로운 방법론을 제시한다.\n\n## History\n\n예전 Posting에서 [🔗 OpenFlow](/posts/openflow)와 [🔗 SDN](/posts/sdn)에 대해서 다룬 적이 있다. 이때, P4에 대해서 간략히 알아보고 지나갔었는데, 해당 Posting에서는 이를 자세히 다룰 것이다. 만약, 이에 대한 개념이 잡혀있지 않다면, 해당 Posting을 이해하기 어렵다. 따라서, SDN과 OpenFlow 관련 Posting을 먼저 읽고 다시 돌아오기를 바란다.\n\n먼저, P4의 초기 시작은 OpenFlow의 성장과 연관이 있다. OpenFlow는 기존의 Switch를 Data Plane과 Control Plane으로 나누어 Control Plane을 외부 Server(Controller)로 옮기고 이들은 OpenFlow Protocol을 통해서 Switch의 Data Palen을 제어하고자 했다. OpenFlow의 사용이 가속화되면서 계속해서 새로운 version이 update되었고, 1.0에서 1.5까지 도달하게 되었다. 그런데, 여러 Usecase와 Protocol을 지원하기 위해서 점점 비대해지는 Header를 마주치게 된다. 이는 통신 속도의 저하를 야기할 뿐만 아니라 기존의 유연한 시스템을 만들고자한 OpenFlow의 탄생 배경과도 거리가 있게 된다. 따라서, Data Plane을 필요에 따라 Protocol, Header, Algorithm을 포함하여 Programming으로 구현하여 사용하면 좋지 않을까라는 발상에서 시작된 것이 P4이다. 그렇기에 P4의 full name이 **Programming Protocol-independent Packet processors**인 것이다.\n\n이렇게 시작된 Project는 점점 비대해지며, 원래는 Programmable Switch를 위한 언어를 목적으로 했다면 현재에는 여러 목적의 장비(target)을 지원하는 언어로 확장되었다. 따라서, P4를 한 문장으로 정의하라고 하면, **Programmable Target의 Data Plane을 Programming하는 언어**라고 할 수 있다.\n\n## 동작원리\n\nP4를 통한 Programming을 통해서 우리가 최종적으로 만드는 것은 두 가지이다. 첫번째로, `DataPlane runtime`은 Table과 Action 그리고 적절한 Alogrithm을 통해 실제로 Packet을 처리 및 Forwarding할 Software를 제작하고, Control Plane에서 Data Plane을 제어 및 설정을 하기 위한 API를 제작한다.\n\n![p4-overview](/images/p4-overview.jpeg)\n\n이를 위해서 Target을 제작하는 Vender는 다음과 같은 3가지를 제작한다.\n\n1. P4 Architecture : 해당 Target에서 작동이 가능한 Interface와 extern object를 정의해놓은 명세서이다. 후에 P4 programmer는 이를 참고하여 해당 Interface에 해당하는 Package를 작성하면 된다.\n2. P4 Compiler : Programmer가 작성한 Code를 Compile하여 API와 DataPlane Runtime을 생성한다.\n3. Target(Hardware) : 실제로 동작하는 Hardware이다.\n\n이제 P4 개발자(Programmer)는 P4 Architecture를 기반으로 하여 원하는 동작을 구현한다. 이를 Compiler를 통해서 실행시켜 정상동작 여부를 확인하여 최종적으로 동작하는 P4 Target을 완성할 수 있다.\n\n이렇게 보았듯이 P4 Programming 과정은 Target 디자이너(Vender)에 의해서 만들어진 객체 지향 Architecture에 기반하여 Implementation을 수행하는 것이 핵심이다. 아마 객체 지향에 익숙하다면 굉장히 친숙한 개념일 것이다.\n\n## 구성요소\n\nP4 programming을 통해서 실제로 작성하거나 사용하는 구성요소들은 아래와 같다.\n\n- **Architecture** : P4를 지원하는 지원하는 Switch의 구성요소들의 interface(객체지향에서의 interface)를 작성한 명세서로 이는 Programmer가 아닌 해당 Target을 제작한 Vender가 작성한다. 이를 기반으로 P4 Programmer는 Implementation을 수행한다.\n- **Header Type** : 해당 Data Plane에서 사용할 각각의 Packet의 Header의 형태를 의미한다. 즉, Packet의 Header 부분을 정의한 것이다.\n- **Parser** : 연속으로 들어오는 Packet에서 Header를 식별하고 추출하는 역할을 한다.\n- **Table** : Programmer에 의해서 정의된 key와 이에 대응하는 Action이 저장된다. 이를 통해서, Routing Table, Flow Lookup Table, ACL 등과 같은 일반 Switch의 Table도 구성이 가능하며, 더 복잡한 형태의 새로운 Table을 구성하는 것도 가능하다.\n- **Action** : Header와 Metadata에 특정한 조작을 가할 수 있다.\n- **Match-action unit** : 실제로 Table을 조회하여, Action을 수행하는 Unit으로 동작순서는 다음과 같다.\n  1. Packet의 field와 metadata를 활용하여 key를 생성한다.\n  2. 생성한 key로 Table에서 조회(Lookup)한다.\n  3. 조회된 key에 대응하는 action이 존재한다면, 이를 수행한다.\n- **User-defined metadata** : Programmer(user)에 의해서 정의된 data 구조로 각 packet에서 추출이 가능하다.\n- **Intrinsic metadata** : 기본적으로 정의된 data 구조로 각 packet에서 추출이 가능하다.\n- **Extern object** : 일반적인 Programming Language에서 Library와 같은 역할을 하며, P4가 실행될 Hardware에서 제공하는 기능들이 여기에 포함된다. P4에서 이를 이용하여 Programming이 가능하지만, 이는 P4를 지원하는 Hardware Switch 제작자가 지정하는 것이기에 P4를 통한 구현은 불가능하다.\n- **Deparser** : Packet의 Header와 Payload를 다시 결합하여 output port로 내보낼 Packet을 생성한다.\n- **Control flow** : target의 packet 처리를 기술하는 필수적인 program 요소이다. Deparsing과 Match-action 등을 이를 통해서 기술할 수 있다.\n\n## Example\n\n가장 기본적인 Siwtch(Very Simple Switch, **VSS**)를 구현하며 P4의 programming 절차를 익혀보자. 아래 그림은 VSS를 분석한 그림이다.\n\n![Very Simple Switch](/images/vss.jpeg)\n\n### Flow\n\n총 3가지의 Flow가 존재한다. 하나는 일반적인 데이터 Packet을 의미하며 Target의 **Physical Ethernet**을 통해서 들어온 packet이 이에 해당한다. 또 다른 하나의 Control Flow로 대게 SDN의 Controller를 통해서 들어온 Packet이다. 대게 이는 CPU를 통해서 전달되기 때문에 **From CPU**라고 표기한다. 마지막은 **Recirculate**인데 이는 동일 Target 내부에서 재처리를 위해서 다시 Arbiter로 전달된 Packet을 의미한다. 이는 한 번의 순환으로는 제대로 된 처리가 어려운 경우에 사용한다.\n\n### Component\n\n주황색 박스의 요소는 Hardware로 정의된 요소(Arbiter, Parser Runtime, Demux/Queue)를 의미하고, 검은 박스의 요소(Parser, Match-action Pipeline, Deparser)는 Software로 구현되는 요소를 의미한다. 각 요소를 먼저 알아보도록 하자.\n\n1. **Arbiter**  \n    한국어로는 중재자라는 뜻을 가지며, Input을 일차적으로 가공하는 Block(장치)으로 아래와 같은 기능을 수행한다.\n    - 총 16개의 Port를 가지며, 3가지 종류의 Input을 입력받는다. (1)Physical Ethernet Input, (2)Control Flow(from CPU), (3)Recirculate Input을 받는다.\n    - **Ethernet Input인 경우**, checksum을 추출하고 검증한다. 만약, 올바르지 않은 checksum이라면 packet이 버려지고, 올바르다면 packet의 payload에서 checksum을 추출하여 다음 단계로 전달한다.\n    - 여러 packet을 동시에 수신한 경우에는 이를 scheduling하는 Algorithm을 실행시킨다.\n    - Arbiter가 Busy 상태이고, 대기 queue가 꽉 찬 경우에는 도착한 packet을 Drop한다.\n    - packet을 받은 port를 `inCtrl.inputPort`에 저장하여, Match-action Pipeline으로 전달하여 packet이 어디서부터 왔는지를 marking한다. 여기서는 Physical Ethernet port는 0 ~ 7번까지를 의미하고, 13은 recirculation port, 14는 CPU port를 의미한다.\n2. **Parser**\n   Packet을 가공하여 Input Header를 추출하고, user defined metadata를 생성하여 이를 Match-action Pipeline으로 전달한다.\n3. **Parser Runtime**\n   Parser와 협력을 하며 실행되는 장치이다. Parser에 정의된 action에 기반하여 Match-action Pipeline으로 error code를 Match-action Pipelien, packet payload에 대한 정보(payload 길이 등)를 Demux로 전달한다.\n4. **Match-action Pipeline**\n   Parser로 부터 전달받은 Input Header와 Parser Runtime으로 부터 받은 error, Arbiter를 통해 받은 `inCtrl.inputPort`를 기반으로 하여 key를 구성하고, 이를 통해서 Table을 조회하여 적절한 Action을 조회하여 실행한다. 이를 통해서 결론적으로 Output Header와 `outCtrl.outputPort`를 생성한다.\n5. **Deparser**\n   Deparser의 역할은 output Header를 다시 재조립하는 장치이다. 온전한 header 형태를 완성해서 Demux에서 Packet을 최종으로 생성할 수 있도록 돕는다.\n6. **Demux/Queue**\n   밖으로 전달할 packet의 header는 Deparser로부터, payload는 Parser로 부터 전달받아서 이를 재결합하여 새로운 packet을 생성하여 올바른 output port로 내보내는 역할을 하는 장치이다. output port는 Matc-action Pipeline의 `outCtrl.outputPort`를 통해서 전달된다. 세부적인 동작은 아래와 같다.\n   - packet 삭제를 원하는 경우 drop port로 packet을 내보낸다.\n   - Physical Ethernet으로 나가는 packet인 경우 해당하는 output interface로 전달한다. 만약, 해당 interface가 Busy 상태라면 Queue에 저장된다. output interface에서는 packet의 checksum을 계산하여 packet의 끝에 붙여서 내보낸다.\n   - CPU를 통해서 전달하는 Control plane packet의 경우에는 Deparser에서 생성된 Header를 사용하지 않고, original packet 그대로만 전송할 수 있다.\n   - `outCtrl.outputPort`가 올바르지 않다면, 해당 packet은 drop된다.\n   - 만약, Demux가 Busy 상태이고, queue에 빈 공간이 존재하지 않는다면, `outCtrl.outputPort`를 무시하고 packet을 drop한다.\n\n### Architecture.p4\n\n아래는 위의 내용을 기반으로 Vender가 작성한 Architecture의 내용이다.\n\n```c++\n// File: \"very_simple_switch_model.p4\"\n// Core Library로 packet_in과 packet_out을 사용하기 위해 필요하다.\n#include \u003ccore.p4\u003e \n\n// Port는 4bit로 표현 가능하다.\ntypedef bit\u003c4\u003e PortId;\n\n// 4 width(bit)로 표현하는 8, 생략해서 8만 써도 무방\nconst PortId REAL_PORT_COUNT = 4w8; \n\n// Input packet에 동반되는 metadata로 Match-action Pipeline에서 사용된다.\nstruct InControl {\n  PortId inputPort;\n}\n\n// Special Input Port\nconst PortId RECIRCULATE_IN_PORT = 0xD;\nconst PortId CPU_IN_PORT = 0xE;\n\n// Match-action Pipeline에서 생성되는 Output packet에 동반되는 metadata\nstruct OutControl {\n  PortId outputPort;\n}\n\n// Special Output Port\nconst PortId DROP_PORT = 0xF;\nconst PortId CPU_OUT_PORT = 0xE;\nconst PortId RECIRCULATE_OUT_PORT = 0xD;\n\n// 공통으로 사용되는 H는 header로 programmer에 의해서 정의된다.\n\n/**\n * Parse\n * @param b             input_packet\n * @param parsedHeaders headers contructed by parser\n */\nparser Parser\u003cH\u003e(packet_in b, out H parsedHeaders);\n\n\n/**\n * Match-action Pipeline\n * @param headers     Parser로 부터 받고, Deparser에게 보낸다.\n * @param parseError  parsing 도중에 생성된 error\n * @param inCtrl      packet을 받은 input port를 포함한 정보\n * @param outCtrl     packet을 보낼 output port를 포함한 정보\n */\ncontrol Pipe\u003cH\u003e(inout H headers, \n                in error parseError, \n                in InControl inCtrl, \n                out OutControl outCtrl);\n\n/**\n * Deparser\n * @param outputHeaders programmer에 의해서 정의된 output header\n * @param b             밖으로 내보낼 packet\n */\ncontrol Deparser\u003cH\u003e(inout H outputHeaders, packet_out b);\n\n/**\n * Top level Packet\n */\npackege VSS\u003cH\u003e(parse\u003cH\u003e p, Pipe\u003cH\u003e map, Deparser\u003cH\u003e d);\n\n/**\n * Extern block\n * 이는 Target vender가 내부적으로 구현한 block이다.\n * programmer는 아래 선언된 block을 자유롭게 사용가능하다.\n */\nextern Checksum16 {\n  Checksum16();\n  void clear();\n  void update\u003cT\u003e(in T data);\n  void remove\u003cT\u003e(in T data);\n  bit\u003c16\u003e get();\n}\n```\n\n이렇게 작성된 architecture를 기반으로 하여 programmer는 코드 작성이 가능하다.\n\n### Programming.p4\n\n먼저 어떤 동작을 수행하게 할지를 정의하자.\n\n\u003c!-- TODO 채우기 --\u003e\n1. Ethernet/IPv4 header를 활용하여 Forwarding을 수행할 것이다.\n2. CheckSum을 확인하여 정당성 여부를 확인한다.\n3. TTL 값을 확인하여 정당성 여부를 확인한다.\n4. Destination IPv4를 활용하여 Next Hop의 IPv4를 찾는다.\n5. 추출했던 Packet의 Header를 다시 Ethernet/IPv4로 재구성한다.\n\n이를 코드로써 구현하면 아래와 같다.\n\n```c++\n// File: \"very_simple_switch_impl.p4\"\n# include \u003ccore.p4\u003e\n# include \"very_simple_switch_model.p4\"\n\n// 해당 program은 packet에서 IPv4와 \n// ethernet header를 가져와\n// destination IP에 기반하여 packet을 \n// forwarding하는 것을 목적으로 한다.\n\ntypedef bit\u003c48\u003e EthernetAddress;\ntypedef bit\u003c32\u003e IPv4Address;\n\n// Standard Ethernet header\nheader Ethernet_h {\n  EthernetAddress dstAddr;\n  EthernetAddress srcAddr;\n  bit\u003c16\u003e         etherType;\n}\n\n// IPv4 header (without option)\nheader IPv4_h {\n  bit\u003c4\u003e      version;\n  bit\u003c4\u003e      ihl;\n  bit\u003c8\u003e      diffserv;\n  bit\u003c16\u003e     totalLen;\n  bit\u003c16\u003e     identification;\n  bit\u003c3\u003e      flags;\n  bit\u003c13\u003e     fragOffset;\n  bit\u003c8\u003e      ttl;\n  bit\u003c8\u003e      protocol;\n  bit\u003c16\u003e     hdrChecksum;\n  IPv4Address srcAddr;\n  IPv4Address dstAddr;\n}\n\n// packet에서 추출한 header형태의 구조체\nstruct Parsed_packet {\n  Ethernet_h ethernet;\n  IPv4_h     ip;\n}\n\n/* Parser Section */\n\n// Programmer에 의해서 정의된 error로 \n// parsing 도중에 이를 발생시킬 수 있다.\nerror {\n  IPv4OptionsNotSupported,\n  IPv4IncorrectVersion,\n  IPv4ChecksumError\n}\n\n/**\n * @param b 들어오는 packet\n * @param p parsing해서 나갈 packet Header\n */\nparser TopParser(packet_in b, out Parsed_packet p) {\n  Checksum16() ck; // checksum block을 instantiating\n\n  state start {\n    b.extract(p.ethernet); // p의 ethernet 부분을 b에서 추출\n    transition select(p.ethernet.etherType) {\n      0x800: parse_ipv4; // forward packet to parse_ipv4\n      // default rule이 없기 때문에 0x800(ethernet)을 \n      // 제외한 packet을 모두 rejected 된다.\n    } \n  }\n\n  state parse_ipv4 {\n    b.extract(p.ip);\n    verify(p.ip.version == 4w4, error.IPv4IncorrectVersion);\n    verify(p.ip.ihl == 4w5, error.IPv4OptionsNotSupported);\n    ck.clear();\n    ck.update(p.ip);\n    verify(ck.get() == 16w0, error.IPv4ChecksumError);\n    transition accept; // 다음 block으로 out을 forwarding\n  }\n}\n\n/* Match-action Pipeline Section */\n\ncontrol TopPipe(inout Parsed_packet headers, \n                in error parseError,\n                in InControl inCtrl,\n                out OutControl outCtrl) {\n  IPv4Address nextHop;\n\n  action Drop_action() { outCtrl.outputPort = DROP_PORT; }\n\n  action Set_nhop(IPv4Address ipv4_dest, PortId port) {\n    nextHop = ipv4_dest;\n    headers.ip.ttl = headers.ip.ttl - 1;\n    outCtrl.outputPort = port;\n  }\n\n  table ipv4_match {\n    // lpm : longest-prefix match\n    key = { headers.ip.dstAddr: lpm; }\n    // 해당 테이블에서 key에 대응할 수 있는 action의 list이다. \n    // 해당 table은 후에 controller에 의해서 채워진다.\n    // 즉, 테이블은 p4 prgramming을 통해서 채우는 것은 아니다.\n    actions = {\n      Drop_action;\n      Set_nhop;\n    }\n    size = 1024;\n    default_action = Drop_action;\n  }\n\n  action Send_to_cpu() {\n    outCtrl.outputPort = CPU_OUT_PORT;\n  }\n\n  table check_ttl {\n    // exact : 정확히 일치하는지 여부를 확인\n    key = { headers.ip.ttl: exact; }\n    actions = { \n      Send_to_cpu;\n      NoAction;\n    }\n    const default_action = NoAction;\n  }\n\n  action Set_dmac(EthernetAddress dmac) {\n    headers.ethernet.dstAddr = dmac;\n  }\n  \n  table dmac {\n    key = { NextHop: exact; }\n    actions = {\n      Drop_action;\n      Set_dmac;\n    }\n    size = 1024;\n    default_action = Drop_action;\n  }\n\n  action Set_smac(EthernetAddress smac) {\n    headers.ethernet.srcAddr = smac;\n  }\n  \n  table smac {\n    key = { outCtrl.outputPort: exact; }\n    actions = {\n      Drop_action;\n      Set_smac;\n    }\n    size = 16;\n    default_action = Drop_action;\n  }\n\n  apply {\n    if (parseError != error.NoError) {\n      Drop_actrion();\n      return;\n    }\n\n    ipv4_match.apply();\n    if (outCtrl.outputPort == DROP_PORT) return;\n\n    check_ttl.apply();\n    if (outCtrl.outputPort == CPU_OUT_PORT) return;\n\n    dmac.apply();\n    if (outCtrl.outputPort == DROP_PORT) return;\n\n    smac.apply();\n  }\n}\n\n/* Deparser Section */\n\ncontrol TopDeparser(inout Parsed_packet p, packet_out b) {\n  Checksum16() ck;\n  apply {\n    b.emit(p.ethernet);\n    if (p.ip.isValid()) {\n      ck.clear();\n      p.ip.hdrChecksum = 16w0;\n      ck.update(p.ip);\n      p.ip.hdrChecksum = ck.get();\n    }\n    b.emit(p.ip);\n  }\n}\n\n// VSS packet를 Instantiate\nVSS(TopParser(), TopPipe(), TopDeparser()) main;\n```\n\n여기까지가 기본적인 P4에 대한 설명이다. 후에 전반적인 문법과 작성법에 대한 가이드를 작성하도록 하겠다.\n\n## Reference\n\n- Thumbnail: [🔗 P4 공식홈페이지](https://p4.org)\n- [P4 specification](https://p4.org/p4-spec/docs/P4-16-v1.2.2.pdf)\n","slug":"p4","date":"2022-06-09 17:29","title":"P4","category":"Network","tags":["SDN","P4","ProgrammableSwitch","DataPlane","OpenFlow"],"desc":"P4는 Programmable Switch, 즉 Hardware에 묶여있는 Software를 통해 DataPlane을 사용하는 것이 아닌 필요에 따라 Switch의 DataPlane을 직접 Programming하여 사용하는 새로운 방법론을 제시한다.","thumbnailSrc":"https://euidong.github.io/images/p4-icon.png"},{"content":"\n## Intro\n\nSDN(Software Defined Network)은 기존에 Hardware단에 결합되어 있던 각종 Routing, Forwarding 방식을 별도의 Controller를 통해서 제어하는 방식을 제시한 것이다. 현재 이러한 기술에 대한 연구가 꾸준히 이루어지고 있는데, 이유를 알기 위해서는 기존의 Network 구성 방식의 문제점을 먼저 짚어보자.\n\n## Internet의 문제\n\n\u003e **Traffic 과증가**\n\nTraffic의 매년 20% 이상으로 굉장히 가파르게 성장하고 있다. 이것 자체도 문제가 될 수 있지만, 이로 인한 문제가 더 큰 문제가 되고 있다.\n\n\u003e **통신사업자의 고민**\n\n계속해서 늘어나는 traffic 대비 수익의 정체가 발생하였다. 즉, 증가하는 traffic을 수용하기 위한 link, switch 등의 투자 비용은 계속해서 요구되는 한편 신규 가입자 수는 거의 존재하지 않기 때문에 통신사업자가 가져가는 수익은 현재 매우 정체되어있다. 반면에 늘어난 traffic에 대한 이득은 고스란히 대규모 service 업체에서 가져가고 있다. (ex. Google, Netflix, etc..)\n\n이러한 관점에서 통신사업자와 서비스 사업자 간의 아래와 같은 대립이 계속되고 있다.\n\n- 공정성(Fairity) : traffic 증가는 서비스 사업자도 같이 부담하자.\n- 망중립성(Neutrality) : traffic 증가는 서비스 사업자가 상관할 영역이 아니다.\n\n\u003e **느린 표준화**\n\n표준화라는 절차는 호환성 검사 및 성능 확인 등을 거치면서 굉장히 많은 시간을 요구한다. 하지만, 신기술은 계속해서 쏟아지고 있기 때문에 표준화가 이 속도를 못따라가고 있는 것이 실황이다. 이를 실제 상용에서 적용하는 것 역시 더 많은 시간이 들게 될 수 있다.\n\n\u003e **Vender 의존성**\n\n통신 장비(Switch, Router, Ethernet, etc...)를 제작하는 Vender(Cisco, Juniper, etc...)가 만든 platform에 의존하는 설정 방법이 혼란을 야기했다. 즉, 각 vender마다 다른 시스템과 configuration 방법이 존재하기 때문에 human error를 야기할 가능성이 높았다.\n\n또한, Switch/Router의 동작을 제어하는 것이 해당 vender가 제공하는 API에 제한되기 때문에 사용자가 Programming을 통해 Routing을 제어하는 것이 불가능했다. 그렇기에 신기술에 대한 테스트를 수행할 수 없을 뿐만 아니라 Vender에서 해당 신기술을 적용하기를 기다리는 수 밖에 없었다.\n\n\u003e **Router/Switch의 복잡도 증가**\n\ntraffic의 증가만큼 Router, Switch의 성능적인 향상 및 양적 증가는 많은 문제를 야기하고 있다. 먼저, 성능을 만족하기 위하여 점점 가격이 급격하게 상승하고 있다. 양적으로의 증가는 결국 Routing Table의 크기를 크게 증가시키고 있다. 이는 Table Lookup, Convergence Time 증가를 야기한다.\n\n\u003e **초기 인터넷의 구조적 문제**\n\n초기 인터넷인 ARPANET은 설계 자체가 절대 연결이 끊기지 않는(autonomous, Best Effort) Network를 추구했다. 그렇기에 사람에 의한 개입이 쉽지 않고, 통제가 어려운 구조이다. 따라서, 각 장비에게 부여되는 책임이 커졌다.\n\n\u003e **TCP/IP 기반의 수 많은 Protocol**\n\n지연보다는 연결에 초점을 맞춘 안전한 TCP/IP 기반의 통신은 Network의 성능면에서 많은 어려움을 겪고 있다. 물론 새로운 TCP 방식도 제시되고 있지만, 이를 교체하는 것은 전체 Network를 변경해야하는 경우가 많기에 이에 대한 교체는 사실상 불가능하다고 간주되고 있다(호환성 문제). 또한, IoT 디바이스에서는 해당 TCP/IP가 다소 무거운 구현이기에 이를 포함할 수 없는 경우가 많다. 따라서, 별도의 Protocol을 지원하는 시스템이 필요하다.\n\n### 요약\n\n즉, Traffic은 계속해서 증가하고 있는데, 이를 해결하기 위한 신기술들은 계속해서 적용이 느려지고 있으며, Vender들 마다 다른 표준으로 인해 너무나 복잡한 네트워크 구성은 운영비용의 최적화가 어렵고, 유연한 네트워크 구조를 만드는데 굉장한 부담으로 다가왔다. 따라서, 이를 해결할 방법이 필요해졌다.\n\n## SDN\n\n위에서 제시한 문제들은 결국 각 Switch/Router와 같은 Hardware 장치에 Software가 귀속되어서 발생한다. 따라서, Switch/Router는 단지 Hardware의 기능을 수행하도록하고, Software는 최소한의 기능만을 남긴 후 이들이 수행하는 Forwarding/Routing 등의 동작을 별도의 Generic Computer에 Controller라는 역할을 부여하고, 이 Controller에 의해서 Forwarding/Routing을 제어할 수 있도록 구성한 Network를 통해서 기존 문제를 해결하자는 것이다.\n\n이를 통해서, 결국 각 장치들은 Routing이 어떻게 정해졌는지에 대한 내용은 알지 못한다. 하지만, Hardware적으로 packet의 입력을 받을 수 있을 뿐만 아니라 Controller로부터 어디로 packet을 forwarding 해야할지에 대한 정보는 알고 있고, 이에 따라 packet을 내보내는 것도 가능하다. 따라서, 전체 네트워크가 Controller를 분리함으로써 추상화가 되는 것이다. 이러한 추상화의 장점은 결국 유연한 네트워크를 만들 수 있다는 것이다.\n\n이것이 SDN이 추구하는 사상이다. 이것을 가능하게 한 것이 OpenFlow의 등장이다. OpenFlow에 대한 설명은 별도의 [Posting](/posts/openflow)에서 다룬다.\n\n### Google의 SDN 활용 사례\n\n\u003e **문제 상황**\n\nGoogle에서는 매년 40\\~45%의 Traffic의 증가가 발생하였다. 이를 대비하기 위해서, Google에서 전용 해저 케이블을 설치하였다. 이를 통해서, Google의 각 DataCenter 간의 연결 품질을 올리고 싶었다. 하지만, 실제로 DataCenter간의 통신에는 30\\~40% 수준으로만 케이블을 사용했다. 기존의 Routing으로 DataCenter간 서비스의 Traffic을 적절하게 분배하고 싶었지만 이를 수행할 수 없었다.\n\n\u003e **해결책**\n\n자체 개발한 OpenFlow Protocol을 지원하는 Switch를 개발하여, 이를 이용하여, 다음과 같은 서비스에 weight를 부여하여 적절하게 traffic을 분배하였다.\n\n- User data copy : 각 데이터 센터간의 e-mail, video 등의 파일 동기화\n- 검색어 ranking을 위한 데이터 copy\n- Datacenter간 상태 동기화\n\n해당 service에서 발생하는 traffic을 적절하게 weight를 부과하여 SDN을 활용하여 분배하여 결국 Datacenter간의 통신에서 광케이블 활용률이 90%까지 상승했다.\n\n### 주요 OpenSource\n\nSDN 구축에 많이 활용되는 주요 OpenSource를 정리한다. 그전에, OpenSource의 구성 형태를 알아볼 필요가 있다. 아래와 같은 형태로 각 OpenSource를 구분하여 살펴볼 수 있다.\n\n![SDN Architecture](/images/sdn-arch.jpeg)\n\n- North : 실제 SDN Controller와 communication을 통해 SDN configuration을 변경한다던가 GUI로 현재 상태를 체크하는 등의 동작을 수행할 수 있다.\n- North Bound Interface : SDN Controller와 communication을 가능하게 하는 Protocol이다.\n- SDN Controller : 실제 SDN에서 Routing을 제어할 Controller\n- South Bound Interface : SDN Controller와 Network Node들(실제 또는 가상 Switch)과의 communication을 가능하게 하는 Protocol이다.\n- South : Physical / Virtual Switch\n\n각 OpenSource에 대해서는 자세히 다루지 않는다. 세부적으로는 시간이 주어지면 하나씩 해나갈 생각이다.\n\n\u003e **ONOS**\n\n위에서 설명한 영역에서 North, North Bound Interface, SDN Controller의 역할을 모두 수행할 수 있는 Open Source이다.\n\nOpen Network Operating System의 약자로, ONF에서 관리하며 SDN Controller를 구성하는 방법을 제시한다. 이를 통해서, 유연하고 안정적인 Network Service를 구축하는 것을 목표로 한다. 유연하다는 것은 간단한 program을 구현할 수 있는 interface를 제공하며, 네트워크 상태를 정의하고, 이를 실시간으로 업데이트할 수 있는 환경을 제공한다. 안정적이다의 기준을 ONOS에서는 99.999 % Availability를 제공하는 것을 목표로 한다.\n\n본 목적은 Controller를 구성하는 것이지만, REST API(NIB)에서부터 Web을 통한 Dashboard GUI(North)와 CLI(North)를 제공하고 있다. 또한, 내부적으로 OpenFlow의 동작을 추상화하여\n\n[🔗 공식 사이트](https://wiki.onosproject.org/display/ONOS/ONOS)\n\n\u003e **Open DayLight**\n\nONOS와 가장 많이 비교되어지는 OpenSource로 마찬가지로 North, North Bound Interface, Controller 기능을 제공한다.\n\nCisco와 Network Vender를 모아서, ONOS를 견제하기 위해서 초기에 시작된 Project로 ONOS는 SDN Controller에 좀 더 집중하는 한편, Open DayLight는 SDN 시스템을 구축하는 환경을 제공하는 것을 강조한다. 또한, Vender에 의해서 관리되기 때문에 ONOS와 비교하였을 때, SBI가 케이블tv 및 IoT Protocol까지 확장되었다. 자세히는 아래 표를 통해서 살펴보도록 하자.\n\n|                 | ONOS                    | Open DayLight            | 비고                    |\n| :-------------- | :---------------------- | :----------------------- | :---------------------- |\n| 라이선스        | Apache 2.0              | Eclipse Public License   |                         |\n| 개발자          | 제한 없음               | Vender                   |                         |\n| SBI 지원        | 여러 SBI 지원           | ONOS보다 다양한 SBI 지원 |                         |\n| 주요 고객       | 통신 및 클라우드 사업자 | 데이터 센터              |                         |\n| 보안성          | 약함                    | 중간                     | 아직 모두 보완성이 낮음 |\n| OpenFlow 호환성 | 1.0 ~ 1.5               | 1.0 ~ 1.3                | ONF 표준                |\n| P4              | 지원                    | 지원                     |                         |\n| Network 가상화  | 지원                    | 지원                     |                         |\n\n[🔗 공식 사이트](https://www.opendaylight.org)\n\n\u003e **ONAP**\n\nONAP은 Open Network Automation Platform의 약자로 SDN의 Life Cycle을 관리하는 도구로 이해하면 쉽다. 위의 제시한 Controller로 부터 각 각의 Switch에 이르는 장치들의 상태를 확인하고, 적절하게 orchestration하는 도구이다. 이는 AT\u0026T의 ECOMP project와 중국 네트워크를 위한 Open-O가 결합하여 Opensource화를 진행한 프로젝트이다.\n\n[🔗 공식 사이트](https://www.onap.org)\n\n\u003e **P4**\n\nProgrammable, Protocol-Independant Packet Processor의 약자로 기존의 제한된 기능만 수행하던 Fixed Function Switch를 필요에 따라 기능을 다르게 구현할 수 있는 Programmable Switch로 대체하고, P4를 이용하여 programming할 수 있는 환경을 제공하는 것을 목표로 한다. 현재에는 Switch 내부의 Packet Forwarding과 Access Control 기능 개발용으로 특화된 상태이다. 아직까지는 Queue의 Scheduling과 같은 기능은 제공하지 않는다.\n\n[🔗 공식 사이트](https://p4.org)\n\n\u003e **DPDK**\n\n고성능 packet 처리를 위한 Library와 Driver의 집합이다. Virtual Switch의 가장 큰 문제는 OS Kernel을 통과하면서 발생하는 Overhead이다. 이를 해결하기 위해서, DPDK에서는 Kernel을 통과하여 수행하는 Kernel bypass라는 기능을 제공한다. 이를 통해서 Packet 처리를 가속화하였다.\n\n[🔗 공식 사이트](https://www.dpdk.org)\n\n\u003e **FD.io**\n\nDPDK와 마찬가지로 packet 전송의 가속화를 목표로 한다. 기존 하나의 Packet을 보낼 때, 그래프 연산이 끝날 때까지 다음 packet이 무기한 기다리는 것을 방지하고자 병렬 또는 동일 목적지 packet을 빠르게 식별하여 packet 전송을 최적화하는 것을 목표로 한다.\n\n[🔗 공식 사이트](https://fd.io)\n\n\u003e **OpenStack**\n\nOpenStack은 범용 Cloud를 구축하는 Solution을 제공한다. 즉, 여러 Node를 가진 사용자라면, 여타 Vender(AWS, GCP)를 이용하지 않고, Cloud 환경을 구축하는 것이 가능하다. 이를 통해서 구축한 Cloud에 Controller를 구성하고 SDN를 제공하는 경우도 많다.\n\n[🔗 공식 사이트](https://openstack.org)\n\n### 주요 SBI\n\nSouth Bound Interface란 실제로 Switch와 Controller가 어떻게 communication을 수행할 것인지에 대한 Protocol을 의미한다. 현재 사실상 표준이라고 여겨지는 Protocol은 다음과 같다.\n\n\u003e **OpenFlow**\n\n앞 서 계속해서 설명해왔기에 생략한다.\n\n\u003e **NetConf**\n\nNetwork 장비(Switch, Router)의 Configuration을 위한 Protocol로 기존 Vender마다 다르던 Configuration 과정을 이를 통해서 간략화하고, 기초적인 Programming을 통해서 이 과정을 자동화하는 것도 가능하다.\n\n\u003e **I2RS**\n\nOpenFlow를 통해서 기존 Network 장비의 데이터 평면과 제어 평면의 완전 제거에 대한 반발로 인해 생겨나 Protocol이다. 이는 Cisco에서 만들어졌으며, 기존 Switch/Router의 제어 평면을 그대로 유지하면서 외부 Controller로부터의 제어를 일부 수용하는 형태의 Protocol이다.\n\n\u003e **BGP-LS / PCE-P**\n\nSDN Controller와 Network 상태 정보를 공유하기 위해 개발된 Protocol이다.\n\n\u003e **LISP**\n\nIP에 의한 네트워크 주소와 단말기 주소가 완벽하게 구분되지 않는 문제에 의해서 만들어졌다. 즉, 단말이 이동 시에 네트워크 주소를 재설정해주는 등의 번거로움이 발생할 수 있다.따라서, IP header에 LISP header를 추가하여 실제 기기 주소와 네트워크 주소를 식별하는 정보를 추가하는 것이 핵심 아이디어인 Protocol이다.\n\n### 주요 연구 동향\n\n\u003e **1. CORD**\n\n현재까지는 DataCenter, Cloud에 한정되어 있는 SDN의 적용을 실제 전화국 및 가입자 통신 시설의 가상화까지 이어가고자 하는 것이 목표이다. 현재 프로젝트는 총 4개의 세부 프로젝트로 나뉘어져서 진행중이다.\n\n1. E-CORD : 기업용 최적 인터넷 구성 시간 단축\n2. R-CORD : 광가입자 서비스 장치의 가상화\n3. A-CORD : 데이터 수집 기능을 프로그래밍 가능하게 구현하여 이를 통한 제어를 목표\n4. M-CORD : 4G/5G 장치의 가상화\n\n\u003e **2. Pronto Project**\n\n네트워크의 모든 동작을 Monitoring하고, 제어하는 Deep Programmable Platform을 구현하여 네트워크 사업자가 제어권을 확보하도록 하는 것을 목표로 한다.\n\n## NFV\n\nSDN과 같이 얘기되어지는 NFV(Network Function Virtualization)도 살펴보고자 한다. 위에서 SDN을 설명하였지만, 결국 아직까지는 DataCenter를 운영하는 서비스 사업자 지향적이다. 대게 닫힌 네트워크 내에서 사용이 용이하다는 것인데, 이는 보안과 관련된 부분도 부족하기 때문이다. 따라서, 통신 사업자들은 SDN을 효과적으로 구성하기 위해서 통신 장비의 하드웨어와 소프트웨어를 분리할 방법을 찾아야 했다. 여기서 나온 방법이 Cloud를 활용하여 소프트웨어 영역을 Cloud 내부에서 구현하고, 통신 장비는 최소한의 소프트웨어만으로 구성하는 것이다. 즉, Network의 특정 기능을 가상화해서 필요에 따라 각 하드웨어 장비가 불러와 사용한다는 개념이다. 결국 통신 사업자 입장에서는 SDN을 구축하기 위해서는 NFV의 구현이 우선시되는 것이다. 이를 수행하게 되면, 당연히 Software의 유연한 구현이 가능하고, 각 장치에서 Software까지 부담해야 하는 비용이 줄기 때문에 설치 및 운영비용(CAPEX / OPEX)에서 큰 이점을 볼 수 있는 것이다.\n\n## Reference\n\n- Thumbnail : Photo by [Nastya Dulhiier](https://unsplash.com/@dulhiier?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/network?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n","slug":"sdn","date":"2022-05-25 09:00","title":"SDN","category":"Network","tags":["SDN","NFV","OpenFlow","ONOS","OpenDayLight","P4","DPDK","FD.io","OpenStack","CORD"],"desc":"SDN(Software Defined Network)은 기존에 Hardware단에 결합되어 있던 각종 Routing, Forwarding 방식을 별도의 Controller를 통해서 제어하는 방식을 제시한 것이다. 현재 이러한 기술에 대한 연구가 꾸준히 이루어지고 있는데, 이유를 알기 위해서는 기존의 Network 구성 방식의 문제점을 먼저 짚어보자.","thumbnailSrc":"https://euidong.github.io/images/network-background.jpg"}],"params":{"subject":"P4"}},"__N_SSG":true},"page":"/tags/[subject]","query":{"subject":"P4"},"buildId":"59TaE6vt_3amu4s4GZ6KA","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>