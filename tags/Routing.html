<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="description" content="Just Tech Blog"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta property="og:type" content="blog"/><meta property="og:site_name" content="JustLog"/><title>Routing<!-- --> | JustLog<!-- --></title><meta property="og:title" content="JustLog"/><meta property="og:description" content="Just Tech Blog"/><meta property="og:url" content="https://euidong.github.io"/><meta property="og:image" content="https://euidong.github.io/logo192.png"/><meta name="next-head-count" content="10"/><link rel="icon" href="https://euidong.github.io/favicon.png"/><link rel="apple-touch-icon" href="https://euidong.github.io/logo192.png"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7452732177557701" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/ef7c1611da8b69bb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ef7c1611da8b69bb.css" data-n-g=""/><link rel="preload" href="/_next/static/css/f36e3f70fe7521ec.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f36e3f70fe7521ec.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-81da43a8dcd978d9.js" defer=""></script><script src="/_next/static/chunks/main-7b6c38cbad60dfcf.js" defer=""></script><script src="/_next/static/chunks/pages/_app-082800383cdd78d2.js" defer=""></script><script src="/_next/static/chunks/260-70537706ba3e961b.js" defer=""></script><script src="/_next/static/chunks/pages/tags/%5Bsubject%5D-05aedb71518217f6.js" defer=""></script><script src="/_next/static/gNWoromiMtipQCBoztIg7/_buildManifest.js" defer=""></script><script src="/_next/static/gNWoromiMtipQCBoztIg7/_ssgManifest.js" defer=""></script><script src="/_next/static/gNWoromiMtipQCBoztIg7/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_wrapper__dKJSz root"><header class="Layout_header__XosLl" style="position:sticky"><div><button tabindex="1" class="SideBarToggler_search_bar_toggler__CEuUg"><svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 24 24" height="35px" width="35px" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor"></path><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor"></path><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor"></path></svg></button><nav class="SideBar_side_bar__wrapper--close__8Nwnr"><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/">Home</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/tags">Tags</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Algorithm">Algorithm<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->11<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Computer%20Architecture">Computer Architecture<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->7<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Tech">Tech<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->15<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Web">Web<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->4<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Network">Network<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->9<!-- -->)<!-- --></span></a></nav></div><a class="Logo_logo___yD0t" tabindex="1" href="/"></a><div><button class="SearchBarToggler_search_bar_toggler__3dHbA" tabindex="2"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="25px" width="25px" xmlns="http://www.w3.org/2000/svg"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"></path></svg></button></div></header><section><div class="RowCard_row_card__list__background___xFj5"><h1 class="RowCard_row_card__list__title__t4a2h"> Routing</h1><label class="RowCard_row_card__list__select__wrapper__TZ4_9"><select class="RowCard_row_card__list__select__dxkxA"><option class="RowCard_row_card__list__select__option__GRKZU">최신순<!-- --></option><option class="RowCard_row_card__list__select__option__GRKZU">AtoZ<!-- --></option><option class="RowCard_row_card__list__select__option__GRKZU">ZtoA<!-- --></option></select></label><ul class="RowCard_row_card__list__wrapper__5Gtgi"><div class="RowCard_row_card__wrapper__kohuv"><a class="RowCard_row_card__thumbnail__wrapper__bedY4" href="/posts/routing"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:200px;height:200px;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><img alt="Routing" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fixed" class="RowCard_row_card__thumbnail__Dh_84" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="Routing" srcSet="https://euidong.github.io/images/routing-hero.jpg?imwidth=256 1x, https://euidong.github.io/images/routing-hero.jpg?imwidth=640 2x" src="https://euidong.github.io/images/routing-hero.jpg?imwidth=640" decoding="async" data-nimg="fixed" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="RowCard_row_card__thumbnail__Dh_84" loading="lazy"/></noscript></span></a><div class="RowCard_row_card__tray__trcA5"><a class="RowCard_row_card__tray__title__lVniM" tabindex="-1" href="/posts/routing">Routing</a><div class="RowCard_row_card__tray__date__3cY_j">2022년 5월 30일 12시 28분</div><ul class="RowCard_row_card__tray__tag__qXmOl"><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/Routing"># <!-- -->Routing<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/RIP"># <!-- -->RIP<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/EIGRP"># <!-- -->EIGRP<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/OSPF"># <!-- -->OSPF<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/BGP"># <!-- -->BGP<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/ISIS"># <!-- -->ISIS<!-- --></a></ul></div></div><div class="RowCard_row_card__wrapper__kohuv"><a class="RowCard_row_card__thumbnail__wrapper__bedY4" href="/posts/segment-routing"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:200px;height:200px;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><img alt="Segment Routing" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fixed" class="RowCard_row_card__thumbnail__Dh_84" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="Segment Routing" srcSet="https://euidong.github.io/images/forwarding.jpg?imwidth=256 1x, https://euidong.github.io/images/forwarding.jpg?imwidth=640 2x" src="https://euidong.github.io/images/forwarding.jpg?imwidth=640" decoding="async" data-nimg="fixed" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="RowCard_row_card__thumbnail__Dh_84" loading="lazy"/></noscript></span></a><div class="RowCard_row_card__tray__trcA5"><a class="RowCard_row_card__tray__title__lVniM" tabindex="-1" href="/posts/segment-routing">Segment Routing</a><div class="RowCard_row_card__tray__date__3cY_j">2022년 5월 23일 10시 41분</div><ul class="RowCard_row_card__tray__tag__qXmOl"><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/Routing"># <!-- -->Routing<!-- --></a></ul></div></div><div class="RowCard_row_card__wrapper__kohuv"><a class="RowCard_row_card__thumbnail__wrapper__bedY4" href="/posts/mpls"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:200px;height:200px;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><img alt="MPLS" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fixed" class="RowCard_row_card__thumbnail__Dh_84" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="MPLS" srcSet="https://euidong.github.io/images/routing.jpg?imwidth=256 1x, https://euidong.github.io/images/routing.jpg?imwidth=640 2x" src="https://euidong.github.io/images/routing.jpg?imwidth=640" decoding="async" data-nimg="fixed" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="RowCard_row_card__thumbnail__Dh_84" loading="lazy"/></noscript></span></a><div class="RowCard_row_card__tray__trcA5"><a class="RowCard_row_card__tray__title__lVniM" tabindex="-1" href="/posts/mpls">MPLS</a><div class="RowCard_row_card__tray__date__3cY_j">2022년 5월 22일 15시 25분</div><ul class="RowCard_row_card__tray__tag__qXmOl"><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/Routing"># <!-- -->Routing<!-- --></a></ul></div></div></ul></div></section><footer class="Layout_footer__EL5v8"><div class="Layout_footer__copyright__r5baC"><span>Copyright © euidong</span><br/><span>모든 컨텐츠에 대한 저작권은 작성자에게 존재합니다. <!-- --><br/>불법 복제를 통한 상업적 사용을 절대적으로 금지합니다. <!-- --><br/>단, 비상업적 이용의 경우 출처 및 링크를 적용한다면 자유롭게 사용가능 합니다.<!-- --></span><span>Also I use photos by<!-- --> <!-- --><a href="https://unsplash.com/@lorenzoherrera?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Lorenzo Herrera</a> <!-- -->on<!-- --> <!-- --><a href="https://unsplash.com/s/photos/tech?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Unsplash</a></span></div><div class="Layout_footer__contents__YZWSm"><a class="Layout_footer__contents__link__K_TKH" href="https://github.com/euidong" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>github</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://euidong.github.io/portfolio" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M6 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-5 6s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H1zM11 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5zm.5 2.5a.5.5 0 0 0 0 1h4a.5.5 0 0 0 0-1h-4zm2 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2zm0 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2z"></path></svg><span>portfolio</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://chrome.google.com/webstore/detail/bonfire/nkooidijgbppkojdgkoafcoppnohdfka?hl=ko" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M5.016 16c-1.066-2.219-0.498-3.49 0.321-4.688 0.897-1.312 1.129-2.61 1.129-2.61s0.706 0.917 0.423 2.352c1.246-1.387 1.482-3.598 1.293-4.445 2.817 1.969 4.021 6.232 2.399 9.392 8.631-4.883 2.147-12.19 1.018-13.013 0.376 0.823 0.448 2.216-0.313 2.893-1.287-4.879-4.468-5.879-4.468-5.879 0.376 2.516-1.364 5.268-3.042 7.324-0.059-1.003-0.122-1.696-0.649-2.656-0.118 1.823-1.511 3.309-1.889 5.135-0.511 2.473 0.383 4.284 3.777 6.197z"></path></svg><span>chat</span></a></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"content":"\n## Reference\n\n- Thumbnail : Photo by [Nick Seagrave](https://unsplash.com/@seagrave?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/route?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n\n## Routing Vs Switching Vs Forwarding\n\n매우 유사한 개념이지만 이에 대해서 알아두고 가는 것이 중요하다.\n\n- `Switching` : Inbound Interface에서 Outbound Interface로 packet들을 전송 시키는 것을 의미한다. 즉, 하나의 기기 내부에서 발생하는 일을 의미하는 경우가 많다.\n- `Forwarding` : 한 장치가 목적지로 가는 경로에 있는 다음 장치로 packet을 전송하는 것을 의미한다. 하지만, Switching과 동일한 뜻으로도 많이 사용된다.\n- `Routing` : 논리적으로 Network Topology를 학습하여, 이를 기반으로 최적의 경로를 찾아 이동하는 것을 의미한다. 따라서, 전체적인 길을 찾는 것과 이를 따라가는 과정을 의미한다.\n\n## Switch\n\nSwitch를 부르는 명칭 역시 다양하고, 상황에 따라 역할도 어느정도 다르기 때문에 정리를 한다. 대게 OSI 7계층에 기반하여 분류를 하는 것이 일반적이다.\n\n- `L2 Switch` : Ethernet Switch를 대게 의미하며, 일반적으로 Switch라고 부르는 장치가 이를 의미한다. MAC 주소에 기반한 Forwarding을 수행하는 장치이다.\n- `L3 Switch` : Router라고도 불리는 장치로, IP 주소에 기반하여 최적의 경로를 학습하는 알고리즘을 포함한 Switch이다.\n- `L4 Switch` : Port 번호를 기반으로 Switching을 수행하는 장치로 대게 Machine 내부에서 Software적으로 구현하는 Switch일 가능성이 높다.\n- `L7 Switch` : Application Level에서 모든 Traffic을 관리 및 URL, Cookie 기반으로 자유롭게 Switching을 수행할 수 있다. 일반적으로 생각하는 Load Balancing과 같은 작업도 쉽게 구현이 가능하다. 마찬가지로 Software적으로 구현되어진다.\n\n## Routing 영역\n\n우리가 Routing을 수행하는 경우에 case는 크게 두 가지로 나뉘어진다. **AS 내부인가? 외부인가?** 이다. `AS`란 Autonomous System의 약자로 하나의 기관에서 관리하는 IP subnet들과 Router들의 집합을 의미한다. 각 AS는 고유 식별값인 ASN(AS Number)에 의해서 식별되며 각 기업, 통신 사업자, 대학, 언론 기관 등이 이를 갖고 있다. 이렇게 같은 AS 내부에 존재하는 기기 간의 Protocol을 Interior Gateway Protocol(**IGP**)이라고 하고, 그렇지 않은 경우 Exterior Gateway Protocol(**EGP**)라고 한다.\n\n## Base\n\n각 Routing Protocol에 대해서 자세히 살펴보기에 앞 서 기본적인 Network 환경에 대한 이해가 필요하다. 그러기 위해서 아래 개념에 대한 숙지 여부를 확인하자.\n\n1. MAC/IP  \n   MAC은 특정 Network 연결 단자(Network Interface Card, NIC)에게 주어지는 고유값으로 볼 수 있다. 그렇기에 하나의 기기는 하나 이상의 NIC를 가진다면, 하나 이상의 MAC address를 갖게 되고, 이에 따라 특정 기기를 정확하게 가르키기 위해서 IPv4 주소를 사용한다. 그러나, IP 부족 현상으로 인해 현재에는 내부 네트워크에서는 private IP라는 별도의 영역으로 표기를 하고, 네트워크의 대표 IP를 내세우는 방식으로 변화하였다. 아직까지는 큰 문제가 발생하고 있지 않지만, 후에는 IPv6로 넘어가야할 수도 있다.\n2. Broadcast Address  \n   Network에서 Traffic을 Network에 연결된 모든 Node에게 보내야할 경우가 있다. 이때, 만약 모든 IP address를 1로 표기한다면, 이는 모든 Network를 향한 Broadcast Request로 받아들여진다. 초기에 Network에서는 모든 요청이 Broadcast되고 이를 받은 사용자가 취사 선택하는 구조를 가졌었지만, Broadcast 요청이 loop가 생기면서, Network 전체를 마비시키거나 보안상/성능상의 문제로 인해 Broadcast되는 영역을 줄이고자 한다.\n3. Subnet  \n   Broadcast Traffic이 많아진다는 것은 Network의 혼란을야기할 수 있다. 따라서, 이러한 Broadcast의 영역을 최소한으로 표현하고자 Subnet을 정의하였다. 즉, Network를 더 작은 Subnetwork로 나누자는 것이다. 이를 표시하기 위해서 Subnet Mask라는 것을 활용하며, Network prefix를 이용하여, 영역을 명확하게 구분한다. 그리고 이를 통해서 나뉘어진 Network 끼리는 다른 Broadcast 영역을 가지게 되고, 서로 Broadcast message가 전파되지 않는다. 이에 따라 나뉘어진 Network의 가장 끝(All One Address)는 Broadcast address가 되고, 가장 처음(All Zero Address)는 Network의 주소를 가르키는 값으로 사용된다.  \n   현대에는 이러한 Subnet을 표기할 때, 별도의 Public IP를 사용하지 않고, Private IP를 사용하는 것이 일반적이다. 이를 통해서 더욱 IP address를 절약할 수 있다. 이를 위해서는, 송신 시 Router IP로 Private IP를 바꾸고, 응답이 돌아왔을 때 원래 Node로 돌려주기 위한 번역 과정이 필요한데 이때 NAT(Network Address Translation) 기술이 사용된다.\n4. CIDR  \n   Subnet을 나눌 때, 위에서 IP를 구분할 때 사용하는 A(8bits prefix), B(16bits prefix), C(24bits prefix) class로 나누어 사용했었는데, 이러한 범위가 Subnet에게는 너무 컸기 때문에 이를 임의의 bit 단위로 구분할 수 있도록 하는 방법이다. 이를 통해서, Subnet 범위를 더 세분화할 수 있다.\n5. Loopback Address  \n   자기 자신을 가르키는 addrsss로 대게 `127.0.0.1`을 사용하는데, 필요에 따라 특정 IP를 별도로 자기 자신을 가르키도록 설정하는 것도 가능하다. 이는 Network Testing을 수행할 때 사용되는데, Router의 Loopback Address와 외부 장치 IP Address에 ping을 보내며 통신 상태를 확인할 수 있다.\n6. Default Gateway  \n   Node에 가장 근접한 Router의 주소를 의미하며, 이를 통해서 Internet에 연결된다.\n7. Collision Domain / VLAN  \n   하나의 hub(Switch 이전에 널리 쓰이던 L2 장치, Switch Hub라고도 부름)로 연결된 장치는 전달되는 모든 packet을 해당 hub의 모든 port로 flooding(forwarding)하는데, 이는 Broadcasting과 같다고 볼 수 있다. 이러한 Broadcasting은 성능상으로도 보안상으로도 치명적이기 때문에, 이를 방지하기 위해서 나온 것이 VLAN이다. 기존의 Subnet의 L3에서의 Broadcasting을 막았다면, VLAN은 L2에서 이를 막기 위한 시도이다. Virtual LAN의 약자로 하나의 Switch가 각 Port마다 Collision Domain(L2 Broadcasting이 수행되는 영역)을 분리시킬 수 있는 방법이다. 이를 통해서, Broadcast의 범위를 더 잘게 조갤 수 있다.\n8. ARP  \n   Address Resolution Protocol의 약어로, 하나의 Subnet 내에서 Broadcast를 이용해, 기기의 IP 주소를 통해서 해당 기기의 MAC address를 알아내는 Protocol이다. 예시로, Default Gateway의 IP 주소를 통해서 해당 Router의 MAC address를 찾을 때 사용할 수 있다. 또한, 일반 Node에서 Server로 Request를 보낼 때에도 MAC address는 모르기 때문에, 이를 통해서 MAC address를 찾는다. 이러한 Traffic은 최소화하는 것이 좋기 때문에 이를 위한 응용 기술도 존재한다.\n   - ARP Cache : 데이터를 전송할 때마다 ARP를 수행하는 것은 비효율적이기 때문에, IP와 대응하는 MAC 주소를 저장한 Mapping table을 저장해두는 것을 의미한다. PC 환경에서는 Network의 변경이 적기 때문에 20분 단위로 재실행하지만, mobile 장치에서는 30초 단위로 단축되었다.\n   - Proxy ARP : Router가 수신 Host까지의 경로를 이미 알고 있는 경우에, 송신 Host에게 수신 Host에 대한 MAC address가 아닌 Router의 MAC address를 전송하는 방식으로 Router에게 전적인 대리 작업을 맡기는 것이기에 보안상에서는 좋지 않을 수 있다.\n\n## Routing Protocol\n\n가장 기본적으로 모든 Routing 장비에서 기본적으로 적용되는 Protocol(STP)를 적용하여 Topology에서 Loop를 제거하는 과정을 거친다. 이후에는 Routing Table(RIB)와 Forwarding Table(FIB)을 구축하는 것이 가장 큰 목표가 된다. Routing Table은 특정 Router 와 연결된 Router의 정보를 Protocol마다 정의하여 보관하는 것이다. Router에서 Routing Table은 사용하는 Routing Protocol의 수 만큼, 즉 여러 개 존재할 수 있다. 이러한 Routing Table들에 기록된 정보를 통해서, 단 하나의 Forwarding Table을 각 Router에서 구성하게 된다. (이때에 각 Protocol의 우선순위에 따라서 Forwarding Table이 구성된다.) 이는 실제로 어떤 Port로 어떤 packet이 들어왔을 때, 어떤 Port로 Forwarding 할 것인지를 기록해둔다.\nRouting의 종류는 위에서 보았던 IGP/EGP 뿐만 아니라 언제 설정 방법에 따라서 2 가지로 나뉘어진다. Traffic이 전달되기 이전에 관리자에 의해서 사전에 직접 Routing을 정의(Static Routing Protocol)하는 방법과 스스로 규칙에 따라 학습을 통해 최적 경로를 찾는 방법(Dynamic Routing Protocol)이 있다.\n\n각 Routing Protocol을 알아보기 이전에 기본적으로는 다음과 같은 원칙을 따라야 한다.\n\n1. Longest match Rule : Subnet mask가 긴 Protocol을 우선시한다.\n2. AD(Administrative Distance) : Protocol간의 우선 순위에 따라서 우선 적용한다. 대게 Static Routing이 Dynamic Routing보다 우선시되어진다.\n3. *Spanning Tree Protocol에 기반하여 먼저, Topology 내에 Loop를 제거해야 한다.\n\n### STP(Spanning Tree Protocol)\n\n2계층 Protocol로 Collision Domain 내부에서 Broadcast Storm을 방지하기 위해서 Loop를 막는 것을 목표로 한다.\n\nGraph 형태로 구성된 Network 장비 간의 연결을 Tree 형태로 재구성 해주면, Loop를 해결할 수 있으므로, 특정 Port를 Block하거나 Traffic이 오가는 것을 막는 등의 작업을 수행한다.\n\n설명하기 앞서 기본적인 용어를 먼저 정의해야 한다.\n\n1. Root Switch  \n   Tree를 구성할 때, 어떤 Switch를 root로 할 것인지에 대한 결정\n2. Root / Designated / Alternated Port  \n   Root Switch로 선택되지 못한 모든 장비들은 Root Switch로 연결되는 port를 선정해야 한다. 이를 Root Port라고 하고, 그 반대 방향에 해당하는 Designated Port를 선정한다. 그리고, 이 둘에 포함되지 않는 Port는 Alternated Port로 분류되어서 일반 통신 시에는 Block되어 사용이 차단된다. 여기서 Root Port가 된다는 것은 해당 Port로 내보내면 결국에는 데이터를 성공적으로 보낼 수 있다는 확신을 가질 수 있다.\n\n이제 Root Switch와 각 Port를 분류하기 위한 BPDU(Bridge Protocol Data Unit)을 알아야 한다. 이는 Spanning Tree를 구성하기 위해서 실제로 각 Switch가 주고 받는 Frame으로, Switch에 연결된 모든 Port에서 전송 또는 수신된다. 초기 Configuration을 수행하거나 Network 상태가 바뀌었을 때, 재합의 과정을 수행할 때 이 Data Unit을 각 Switch 간에 전송한다. 이때 포함되는 가장 중요한 정보가 **Bridge ID**이다. 이는 해당 Switch의 `VLAN 번호`, `MAC address`, `임의의 값`에 의해서 결정된다. 여기서 **Bridge ID**가 가장 낮은 Switch가 Root Switch가 된다. 이것이 완료되면 이제 각 Switch의 각 Port를 식별하는 과정을 거쳐야 한다. 과정은 다음과 같다.\n\n1. Bridge ID가 작은 Switch부터 Root Switch까지의 거리가 가장 짧은 Port는 Root Port가 된다. 만약 동일하다면 Bridge ID, Port ID를 비교하여 선택한다.\n2. 하나의 `Segment`(Switch간의 연결)에 반드시 하나의 Designated Port가 존재하도록 한다. 즉, 두 개의 Switch가 연결되었고, 한 Switch에서 특정 Port를 Root Port로 정했다면, 다른 Switch에서는 이와 연결된 Port를 Designated로 지정해야 한다.\n3. 어떠한 Port도 존재하지 않는다면, 남는 Port를 Designated Port로 지정하고, 이 반대 Port는 Alternated Port로 지정한다.\n\n이 과정이 끝나면, 이제 각 Port는 5가지 상태로 분류되어진다.\n\n1. Listening State(청취)  \n   Switch가 최초에 전원이 켜지면, 모든 Port는 Listening 상태에 들어간다. 그리고, 해당 Port가 만약 Alternated Port로 지정된다면, 이는 Block State로 변경된다. 그렇지 않고 Root/Designated Port로 지정된다면, 15초 정도의 여유를 두고 Learning State로 변경된다.\n2. Learning State(학습)  \n   전송을 수행하기 이전에, 연결된 Switch들의 MAC address를 학습하는 단계이다. 해당 단계가 15초 지속된 뒤에, Forwarding State로 넘어간다. 이 과정에서 갑자기 Port가 Alternated Port로 변경된다면, 이 또한 Block State로 바로 넘어간다.\n3. Forwarding State(전송)  \n   실제로 Data를 전송하는 단계이다. 이때에는 실제로 각 장치 간에 데이터가 이동할 수 있다.\n4. Blocking State(차단)  \n   이 상태에서도 해당 Port가 Root/Designated Port가 될 수 있다. 그럴 경우 Listening State로 변경되고, 통신 준비를 한다.\n5. Disable State(비활성)  \n   해당 Port가 고장 또는 비연결 등으로 비활성화되어 있는 상태이다.\n\n이렇게 결국은 Forwarding State에 도달하게 되었을 때 실제로 데이터를 주고 받는 것이 가능해지게 된다. 중간에 연결이 끊기더라도 유기적으로 계속해서 BPDU를 주고 받으면서 Root/Designated/Alternated Port로 역할이 계속해서 바뀌면서, 지속적인 연결을 추구한다. 하지만, 이 합의 과정이 생각보다 길기 때문에(Block -\u003e Forwarding 45초 소요) 이를 해결하기 위한 RSTP, MSTP, SPB 와 같은 방법론도 있다.\n\n### Static Routing Protocol\n\ndata의 Route를 사전에 관리자가 직접 정의하는 방법이다. 이는 인터넷 가입자 구간에서 설정 시에 사용하며, 대표적인 예시가 Default Gateway 등을 지정하는 과정이다. 장애가 발생하더라도 계속해서 동일한 곳으로 요청을 보내기 때문에 장애에 대한 책임은 온전히 설정을 수행한 관리자에게 달려있다. AS에 상관없이 각 Router에서 직접적으로 다음 Link를 선택하기 때문에 AS에 상관없이 동일하게 설정한다.\n\n### Dynamic Routing Protocol\n\nRouter가 실행 중에 계속해서 장애에 대응하면서, 가용성 높은 Routing을 제공하기 위해서 경로를 최적화하는 방식이다. 이는 AS에 따라서 설정 방법이 상이하기 때문에 이에 따라서 분류한다.\n\n- **Interior(IGP)** : AS 내부에서의 Routing Protocol이며, Link의 상태를 기반으로 하는지 hop 수(중간 Router의 수)를 기반으로 하는지에 따라서 두 가지 종류로 나누어진다.\n  - **Distance Vector**  \n    Distance(Router 간의 Hop 수)와 Vector(방향)만을 고려하여 Routing Table을 구성한다. 인근 Router에 의해서 받은 정보를 통해서 구성하게 되며, Link의 Bandwidth, 현재 상태를 알지 못하기 때문에 최적화와는 거리가 멀다. 심지어는 반대 방향으로 돌아가는 현상도 발생할 수 있다. 종류는 대표적으로 아래 두 가지가 있다.\n    1. **RIP(Routing Information Protocol)**  \n       최초의 Dynamic Routing Protocol로 각 Router간의 Hop 수를 기반으로 Distance를 추정한다. 소규모 네트워크를 구축할 때는 매우 간단하게 설정이 가능하지만, Hop 수 만을 활용하기 때문에 복잡한 네트워크 구성에는 적절치 않다. 또한, 30초 단위로 업데이트가 발생하기 때문에, 빠른 장애 회복이 되지 않는다. 또한, 최대 Hop 수를 15로 제한하였고, 그 이상은 Network가 연결되지 않았다고 인식한다. version은 1,2가 존재하고, 2 역시 1과 대동소이 한다.\n    2. **IGRP(Interior Gateway Routing Protocol)**  \n      RIP와 유사하고, 기존 90초 단위로 Routing Table을 갱신하며, Hop 수를 255까지 확장하였다.\n  - **Link State**  \n    Link(통신선) 상태 역시 고려하는 Protocol이다. 단순한 기기 간의 거리 뿐만 아니라 bandwidth 등과 같은 정보도 활용한다. 또한 Network 전체의 정보를 포함하고 있다. 즉, **Routing Table의 크기가 굉장히 커질 수 있다. 이는 Router의 Memory 소모와 CPU 소모를 급격하게 늘린다.** 또한, Routing Table을 동일하게 유지해주는 Convergence(이것이 제대로 수행되지 않으면 통신 실패가 발생할 수도 있다.)를 수행하기 위해 소모되는 시간인 `Convergence Time`이 과도하게 커질 수도 있다. 이러한 문제를 해결하는 것이 해당 Link State 방식의 주요 목표이다.\n    1. **OSPF(Open Shortest Path First)**  \n      Network를 Area라는 단위로 나누고, 각 Area에서는 해당 Area에 해당하는 Routing Table을 보관하게 하여 전체 Routing Table의 크기를 줄인 방식이다. 같은 Area 내에서는 모든 Router가 동일한 Routing Table을 소지한다. 만약, 두 개 이상의 Area에 속한다면, 해당 Router는 두 개의 Routing Table을 소지하게 된다. Area가 하나일 경우에는 임의의 Area No을 사용해도 상관이 없지만, Area가 여러 개일 경우에는 Area 0이 반드시 존재해야 하며, 해당 Area 0를 중심으로 Topology가 구성되기 때문이다. 가장 대중적으로 많이 사용되는 Routing Protocol로 IGP 내에서는 Conversionce Time이 짧고 효율적이다. 최단 거리를 찾을 때에는 Dijkstra Algorithm을 활용하여 최단거리를 탐색한다.\n    2. **ISIS(Intermediate System - Intermediate System)**  \n       Intermediate System은 Router를 의미하며, 같은 Area에 속하는 Router간의 Routing Table을 공유하는 개념으로 Router를 총 두 가지로 나눈다. 하나는 여러 Area에 걸쳐 있는 Level 2, 하나의 Area에 속하는 Level 1이다. 대게 모든 Router가 Level 2에 속하기 때문에 굉장히 큰 Routing Table을 가지게 된다. Routing Table이 커질 수 있지만 Conversionce Time이 줄어들고, Backborn을 Area 0으로 제한하지 않기 때문에 OSPF보다 더 유연한 네트워크 구조를 구축할 수 있다.\n  - **Hybrid**\n    - **EIGRP(Enhanced Interior Gateway Routing Protocol)**  \n      Hop 수를 256개로 늘리고, 주기 없이 Network 환경이 변화되면 바로 적용되도록 바꾸었다. 또한, Hop 수 외에도 Bandwidth, Delay, Load, MTU 등을 추가적으로 계산하여 Link State 역시 활용하는 방식이다.\n- **Exterior(EGP)**  \n  나뉘어진 AS 간의 통신을 지원하기 위한 방법이다.\n  - **BGP(Border Gateway Protocol)**  \n    서로 다른 AS를 연결하는 Protocol로 TCP에 기반하며, IGP와 같이 연동하여 전체 네트워크를 구성할 수도 있고, 자체적으로 정의한 Interior BGP를 활용하여 BGP만으로 네트워크를 구성하는 것도 가능하다. 따라서, BGP는 iBGP(interior BGP), eBGP(exterior BGP)로 나눌 수 있다. BGP는 여타 IGP들과는 다르게 AS간의 Routing을 중계하기 때문에 Routing Table의 크기가 매우 크고, 이에 대한 처리에 특화되어있다. 하지만, 대게 BGP라고 하면 eBGP를 의미한다. 특이하게 BGP는 기존의 Link State나 Hop 수에 기반하지 않고 Attribute(Hop, Bandwidth, ACL, Weight 등)라는 것을 별도로 활용한다. Dynamic Routing 방식이지만, 각 Link에 대한 정보는 앞에서 언급한 Attribute를 이용하여 수동으로 설정해주어야 한다. 하지만, BGP는 Broken Gateway Protocol이라는 별명이 있을 정도로 현재 많은 문제를 야기하고 있다. BGP Table의 크기가 102.4만 개를 초과할 시에 일부 Router의 Memory가 부족해지는 현상이 발생할 수 있다. 현재 해당 크기에 도달 시점을 2023년 말 정도로 예측하고 있다. 또한, 이렇게 커진 Table의 크기로 인해 Convergence Time도 굉장히 많이 소모하고 있다.(완전 수렴까지 15분 소요)\n","slug":"routing","date":"2022-05-30 12:28","title":"Routing","category":"Network","tags":["Routing","RIP","EIGRP","OSPF","BGP","ISIS"],"thumbnailSrc":"https://euidong.github.io/images/routing-hero.jpg"},{"content":"\n### Reference\n\n- Thumbnail: Photo by [Arno Senoner](https://unsplash.com/@arnosenoner?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/forwarding?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n\n---\n\nSegment Routing은 MPLS의 차세대 버전으로, 초기에는 MPLS의 문제를 해결하기 위해서 제시되었다. 예를들면, TE(Traffic Engineering) 시에 Star Topology에서는 효율이 안나온다던지 ECMP(Traffic을 여러 output interface로 분배시키는 방식)을 활용할 수 없다와 같은 제한을 해결하고자 등장하였다. 그렇지만, 현재에 와서 와서 더 중요시 여겨지는 것은 **네트워크 구조의 단순화**이다. 즉, 기존의 복잡하던 Switch의 설정 방법(통신장비 vender 마다 다른 설정법, 여러 Protocold이 존재)과 운용 방법을 통일하고, 단순화 시킴으로써 사람에 의한 에러(Human Error)를 최소화하고자 하는 노력이라고 볼 수 있다.\n\n### 용어\n\n- **Segment** : 하나의 path가 여러 개의 작은 path들로 구성되는 것에서 유래하였다고 보며, 하나의 명령어(instruction)을 segment라고도 부른다. 명령어는 어디로 전달할 것인가와 packet을 어떻게 변형할 것인가에 대한 내용을 포함한다.  \n  Segment는 SID라는 id값을 통해서 구분하며, 이는 [0, 1,048,575] 까지를 사용할 수 있다. 특별한 목적을 가지는 [0, 15,000) 예약된 SID이고, [15,000 ~ 16,000)는 인접한 egress Router를 가르키는데 사용하는 `Adjacency SID`이고, [16,000, 24,000)는 Segment Routing이 유효한 범위 내에서 각 Router에 임의 설정이 가능한 영역대로 `Prefix SID` 라고 부른다. 그 외에 영역은 동적으로 할당되는 SID로 자동 할당 시에 사용된다. 여기서 중요한 점은 **Adjacency SID와 Prefix SID만 있으면, 모든 경로를 표현하는 것이 가능하다는 것이다.** 추가적으로, SR Policy를 재사용하고 싶은 경우가 발생할 수 있는데 이를 위해서 SR Policy 자체에 SID를 부여하는 것이 BSID(Binding SID)이다.  \n  ![SID-table](/images/sid-table.jpeg)\n- **Headend Router** : Segment Routing 영역으로 들어오는 Ingress Router이다.\n\n### 동작 원리\n\nSegment Routing 영역으로 Packet이 진입하면, 해당 packet의 Destination과 부가 정보를 확인하여, SR Policy(=Segment List, 방문해야할 경로를 순서대로 나열해놓은 리스트)를 MPLS 또는 IPv6의 부가 공간에 삽입한다. 이때에는 Stack 형태로 List를 구성하고, 중간 Router들에서는 Segment에 따라서 동작을 수행하며, packet을 최종 Egress Router까지 전달한다. 여기서 각 경로는 모든 세세한 경로를 표시할 필요는 없다. 만약 A에서 B로 가는 SID를 설정했어도, 그 내부에서 어떤 경로를 선택할지는 System적으로 알아서 Routing하도록 설정하는 것도 가능하다.(`Loose Source Routing`) Ingress에서 SR Policy를 지정하면 이를 `Push`라고 하고, 내부 Router는 가장 아래 Segment를 확인하고 자신과 관련 있는 경우에는 `Pop`을 수행하여 하나의 Segment를 삭제 후 이에 따라 동작을 수행하고, 그렇지 않으면 연결된 Link로 기존 BGP에 따라 알아서 Routing을 수행한다. 이를 `Continue`라고 한다.\n\n### Usecase\n\n다음과 같은 형태로 Routing을 설정하는 것이다. 아래 예시에서는 모두 1 -\u003e 2 -\u003e 3 -\u003e 4 순으로 Routing을 수행하기를 원한다고 생각하자.\n\n`SID 16002`의 경우에는 `1 -\u003e 2`로 이동하는 것이 `1 -\u003e 4 -\u003e 3 -\u003e 2` 보다 IGP cost가 적으므로, `1 -\u003e 2`로 원하는대로 이동할 것이라고 예상할 수 있다.\n이후 `SID 16004`의 경우에도 `2 -\u003e 3 -\u003e 4`로 이동하는 것이 `2 -\u003e 1 -\u003e 4`로 이동하는 것보다 IGP cost가 적으므로, `2 -\u003e 3 -\u003e 4`로 원하는대로 이동하는 것을 예상할 수 있다.\n\n![sr example 1](/images/sr-example-1.jpeg)\n\n하지만, IGP cost가 우리의 바램과는 다른 경우에는 다음과 같은 현상이 발생할 수도 있다.\n아래에서 `SID 16004`를 보면, `2 -\u003e 1 -\u003e 4`가 `2 -\u003e 3 -\u003e 4`보다 IGP cost가 적기 때문에 우리가 원하는 방향과는 반대로 동작할 것임을 예상할 수 있다. 따라서, 이를 해결하기 위해서 우리는 다음과 같은 경로를 채택해야 한다.\n\n![sr example 2](/images/sr-example-2.jpeg)\n\n여기서는 `1 -\u003e 2 -\u003e 3`이 `1 -\u003e 4 -\u003e 3`보다 크기 때문에 원하는대로 `1 -\u003e 2 -\u003e 3`으로 움직일 것이다. 하지만, 여기서 `3 -\u003e 4`로 가는 경로가 어려울 수 있다. 이 경우에는 앞 서 보았던 Adjacency SID를 활용하여야 한다. 이는 마지막으로 가야할 egress Router를 지정하기 때문에 routing 시에 costing을 고려하지 않고, 바로 Static Routing이 가능하다. 따라서, 이를 활용하면 최종으로 `3 -\u003e 4`로 가는 경로를 획득하는 것이 가능하다.\n\n![sr example 3](/images/sr-example-3.jpeg)\n\n### Configuration\n\n- SR-MPLS : MPLS와 같은 방식을 추구하지만, 설정 방식에서 LDP와 RSVP를 사용하지 않고 IGP를 활용해서 이를 수행할 수 있도록 하여 Protocol을 단순화하였다.  \n  Segment List(`SR Policy`)를 전달하는 과정이 MPLS의 Label을 전달하는 방식과 유사하며, 지나야하는 경로를 명시하여 stack 형태로 쌓아서 전달하면, 각 내부 Router는 이를 참고하여 제거 또는 유지하며, Egress Router를 찾는다.\n- SRv6 : IGP와 IPv6 Protocol만을 활용하여 네트워크를 구성할 수 있도록 하는 것이 목표이다. 네트워크 자체를 프로그래밍 하고자 하는 요구 때문에 필요성이 강조되었다. 이는 IPv6의 주소값인 128bit를 topology를 식별할 주소값과 packet 처리를 위한 값(특정 packet에게는 다른 routing table을 적용 등)으로 나누어 사용함으로써 구현이 가능하다. 따라서, IPv4의 짧은 주소 체계로는 이를 수행할 수 없다. 따라서, IPv6 Protocol을 이용하여 수행하는 것이다.  \n  Segment List(`SR Policy`)를 전달하는 과정은 위와 유사하지만, 이를 IPv6 Option 영역에 stack형태로 저장한다.\n\n### Traffic Engineering\n\nTraffic을 제어하고, 해당 제어를 위한 제한사항들을 실시간으로 update하고, 운용 관리하는 것이 가능하다. MPLS에서 수행하던 TE(Traffic Engineering)과 유사하지만, Bandwidth를 사용하지 않는 대신에 delay라는 조건을 갖고 있다. 이는 packet이 도착하는데 걸리는 시간을 측정한 값이다.  \n해당 조건들을 활용하여 Traffic을 입맛에 맞게 변경하는 것이 가능하다.\n\n또한, 장애 대책 시에도 Segment Routing은 강점을 가지고 있다. 일반적인 OSPF를 활용하는 경우에는 LFA(Loop Free Alternate)를 통해서 우회 경로를 계산한다. 하지만, 이는 생각보다 비효율적인 경로 계산을 수행하게 된다. 따라서, 이를 개선하는데 Segment Routing이 적절하다. 다음 예시를 보자.\n\n[그림]\n\n장애 이전에 `1 -\u003e 2 -\u003e 3 -\u003e 5` 그리고 `6 -\u003e 2 -\u003e 3 -\u003e 5` 라는 traffic이 존재할 때, 만약 `2 -\u003e 3` link가 끊어지면, 기존의 LFA를 이용하면 찾게 되는 경로는 다음 경로와 같아진다. 이는 상당히 비효율적인 경로인데, 이렇게 계산을 수행하는 이유는 `1 -\u003e 2 -\u003e 6 -\u003e 7 -\u003e 3 -\u003e 5` 라는 차선 경로로 가는 도중에 `2 -\u003e 6`으로 이동 이후에 기존 Traffic에 영향으로 인해 `6 -\u003e 2`로 다시 돌아오는 현상이 발생하기 때문이다. 따라서, 결론상 더 큰 비용이 발생하는 경로(`2 -\u003e 9`)로 들어가서 오히려 더 많은 비용이 발생하게 된다.\n\n이를 해결하기 위해서는 장애가 발생한 이후에 다시 IGP가 계산하는 최단 경로인 `Post-Convergence Path`를 사용하면 된다. 하지만, 해당 경로는 Loop를 야기할 가능성이 존재한다. 이로 인해, 해당 방식을 사용하지 않았었는데, Segment Routing을 이용하여 경로를 제한함으로써 Post Convergence Path를 사용할 수 있게 되었다. 즉, Segment Routing의 Adjacency SID를 이용해서 나가야할 지점을 명확하게 하며, Loop가 발생할 수 있는 지점에서 Static Routing을 지정하면서, Prefix SID를 통해서 경로를 적절히 지정하여 해결이 가능한 것이다.\n\n### Programmable\n\nSegment Routing의 또 하나의 강점은 SDN 지향적인 구조라는 것이다. 즉, 중앙에서 각 Switch의 동작을 제어하는 Controller를 Segment Routing을 통해서 직접 구현이 가능하다는 것이다. 즉, Segment Routing Network가 특정 Controller에게 자신의 상태 정보 등을 주기적으로 보내면, Controller에서는 이를 이용해서 Database를 구축하고, 이를 바탕으로 Routing Table을 완성하는 것이다. 이를 기반으로, 후에 요청이 Headend 장치로 들어오면, 해당 장치는 Controller에게 처리를 요청하고, 이에 대한 응답을 받은 Headend 장비는 적절하게 SR Policy를 해당 packet에 저장하여 Routing이 가능해지는 것이다.\n\n### Summary\n\n|                   | MPLS                                                               | SR-MPLS                  | SRv6                 | Segment Routing의 장점                                                            |\n| :---------------- | :----------------------------------------------------------------- | :----------------------- | :------------------- | :-------------------------------------------------------------------------------- |\n| 제어 프로토콜     | 기반 : IGP/BGP, 추가 : LDP/RSVP-TE                                 | IGP/BGP                  | IGP/BGP              | LDP/RSVP-TE 와 같은 추가 Protocol이 없음                                          |\n| 데이터 평면       | MPLS 데이터 평면을 정의해서 사용                                   | MPLS 데이터 평면을 활용  | IPv6를 활용          | IPv6를 활용한 경우 추가적인 설정이 필요없음                                       |\n| 경로 계산 및 조정 | 사실 Ingress에서 설정하지만 각 노드가 관여                         | Source(Ingress)에서 결정 | 동일                 | Source Routing으로 명확한 구조                                                    |\n| LSP의 Label 관리  | LSP의 갯수가 많아질 수록 각 노드의 부담 증가                       | 인접 노드, 링크만 관리   | 동일                 | 내부 Router의 부담이 크게 감소                                                    |\n| Operation         | Push, Swap, Pop                                                    | Push, Next, Continue     | 동일                 | Swap 연산이 필요없다.                                                             |\n| 장애 대책         | Fast ReRoute                                                       | TI-LFA, Fast ReRoute     | 동일                 | Fast ReRoute는 convergence time이 길어 실용 사례가 적다.                          |\n| Programmability   | 불가능                                                             | 불가능                   | Network Programmable | IPv6를 이용한다면, Traffic Engineering, VPN을 Programming을 통해 구현이 가능하다. |\n| 네트워크 확장성   | 일반적으로는 높다. 하지만, RSVP-TE를 활용하는 경우 낮아질 수 있다. | 확장성이 높다.           | 동일                 | 확장성이 높다.                                                                    |\n| 네트워크 구조     | 일반적인 분산 제어 구조                                            | SDN 적용이 가능          | 동일                 | SDN 기반의 중앙집중 제어와 기존 방식으로 분산 제어도 가능함                       |\n","slug":"segment-routing","date":"2022-05-23 10:41","title":"Segment Routing","category":"Network","tags":["Routing"],"thumbnailSrc":"https://euidong.github.io/images/forwarding.jpg"},{"content":"\n### References\n\n- Thumbnail : Photo by [Tyler Farmer](https://unsplash.com/@tylerfarmer?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/forwarding?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n- \u003chttps://www.itworld.co.kr/tags/6580/MPLS/108621\u003e\n- \u003chttps://blog.naver.com/thorong/70147777745\u003e\n\n---\n\n기존의 Routing에서는 매 hop(router)당 Routing Table을 참조하여 packet을 전송했다. 하지만, 이 과정은 생각보다 많은 시간이 필요하다. 이를 이용해서 화상 통화 등을 한다면, 서비스 품질이 매우 떨어질 위험이 있다. 따라서, MPLS는 Routing를 더 빠르게 하고, 품질 항상을 위해서 만들어졌다. 이는 Multi-Protocol Label Switching(MPLS)이라는 말처럼, 기존의 IP를 이용한 Routing이 아닌 Label(또는 tag)이라는 별도의 data를 이용하여, 3계층을 거치지 않고, Routing을 고속화하는 역할을 할 수 있다.\n\n또한, **MPLS**에서는 사전에 고효율 경로를 설정하고, 이를 통해서 통신하도록 하여 성능 문제를 해결한다. 예를 들어, Packet이 들어오면, 진입점에 있는 Router(Ingress Router)가 해당 Packet에 Label을 표기하고 내부 Network로 전송하게 된다. 이제 내부 Router에서는 Packet을 모두 확인하지 않고, 해당 Label만을 이용하여 Forwarding을 수행한다. 그렇기에 더 빠른 Routing이 가능해지는 것이다.\n\n![MPLS packet](/images/mpls-label.jpeg)\n\n하지만, 그 외에도 추가로 더 많은 장점을 보유하고 있다.\n\n1. 여러 Protocol과 호환이 가능하도록 overlay로 개발되었다. (2.5 Layer라고도 불리는 이유이다.)\n2. TE(Traffic Engineering)를 위한 여러 설정을 제공한다. 따라서, bandwidth, QoS(서비스 품질)에 따라서 Traffic을 제어하는 것이 가능하다.\n\n## 용어\n\n- MPLS Network : **MPLS**를 통해서 구축한 Network를 의미한다. 해당 Network로 진입하는 순간 Packet에는 Label과 부가적인 header가 추가된다.\n- Label : Label은 각 Router에게 하나씩 주어지는 Router의 고유 식별값이다.\n- LER(Label Edge Router) : Network 제공자 입장에서 Edge Router로 두 가지 종류로 나뉜다.  \n  Ingress와 Egress는 항상 고정인 것이 아니라 packet에 입장에서 계속해서 변경된다.\n  - Ingress Router: packet이 Network로 진입하는 Router로 실제 Network를 전체 조회하고, Label을 추가하는 역할을 한다.\n  - Egress Router : packet이 Network를 탈출하는 Router로 Packet의 남아있는 Label을 삭제한다.\n- LSR(Label Switched Router) : MPLS Network 내부에 존재하는 LER이 아닌 Router들로 이들은 Packet의 Label을 Switching하고, Forwarding하는 역할을 수행한다.\n\n![mpls-example](/images/mpls-example.jpeg)\n\n## 동작 원리\n\n`LSP(Label Switched Path)라는 최단 경로를 찾고, 이를 통해서 Packet을 전달시킨다.`가 Protocol의 핵심적인 전략이다. 형성된 LSP에 따라서 labe들을 설정해두면, 이제 내부 Router에서는 자신에게 해당하는 Label을 교환하여 다시 Forwarding을 수행하면 되는 것이다. 따라서, 3계층을 거치지 않고 Routing이 가능하다. 위에서 나온 용어로 정리하자면, Ingress LER에서는 packet의 목적지와 요청지 정보 등을 활용하여 LSP을 구성하고, 이에 알맞는 Label을 packet에 추가한다. 이제 이 packet을 받은 LSR에서는 Label을 하나 빼고, 다음 LSR을 찾아가기를 반복하며, egress LER에 도달한다. egress에서는 Label이 남아있다면, 모두 제거하고, 원래 사용 중이던 Protocol에 맞게 다시 Routing을 수행한다.\n\n![mpls-example](/images/mpls-example-2.jpeg)\n\n### LSP 구성\n\n총 3가지 방법을 통해서 생성이 가능하다. 이는 후에 나올 Configuration에 따라서 어느정도 바뀌게 된다.\n\n1. Best Effort LSP : Label 할당이 알고리즘에 의해서 자동적으로 할당되며, 항상 연결이 지속될 수 있도록 하는 것을 최대 목표로 하기 때문에 여타 방식들에 비해 성능이 떨어질 수도 있지만, 장애 대응에 적절하다고 할 수 있다.\n2. Static LSP : Label을 직접 수작업을 통해서 할당해주며, 경로를 customizing할 수 있지만, 이로 인해서 예상치 못한 문제가 발생할 수도 있다.\n3. Signaled LSP : 일정 이상의 자원(Bandwidth, 등)을 제한하여 경로를 최적화할 수 있다.\n\n### Configuration\n\nMPLS network를 구성하기 위해서는 결국 각 Router에 Label을 나누어주는 것과 LSP를 구성하는 것이 중요하다. 아래에는 대표적인 MPLS의 Topology를 살펴본다.\n\n- LDP : 위에서 설명한 Best Effort LSP를 구성하는 Protocol로 Label을 분배하고, 각 Router에서는 Label의 Push/POP/Swap을 수행한다.\n- RSVP-TE : 특정 제약 조건을 먼저 제시를 하고, 이를 기반으로 이와 일치하는 경로를 찾아서 packet을 Routing하는 방식이다.\n\n## Versus\n\n| 구분                   | ATM       | IP        | MPLS      |\n| :--------------------- | :-------- | :-------- | :-------- |\n| IP Traffic Engineering | 우수      | 보통      | 매우 우수 |\n| 고속 포워딩            | 매우 우수 | 보통      | 우수/보통 |\n| QoS                    | 매우 우수 | 보통      | 우수      |\n| VPN 비용               | 고가      | 저가      | 중가      |\n| 확장성                 | 우수      | 매우 우수 | 매우 우수 |\n| 구축 / 유지 비용       | 매우 고가 | 저가      | 고가      |\n","slug":"mpls","date":"2022-05-22 15:25","title":"MPLS","category":"Network","tags":["Routing"],"thumbnailSrc":"https://euidong.github.io/images/routing.jpg"}],"params":{"subject":"Routing"}},"__N_SSG":true},"page":"/tags/[subject]","query":{"subject":"Routing"},"buildId":"gNWoromiMtipQCBoztIg7","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>