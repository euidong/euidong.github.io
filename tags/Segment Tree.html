<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="description" content="Network 분야에 관심이 많은 개발자로 Computer Engineering 관련 Posting을 주로 다룹니다."/><meta property="og:description" content="Network 분야에 관심이 많은 개발자로 Computer Engineering 관련 Posting을 주로 다룹니다."/><meta property="og:type" content="blog"/><meta property="og:site_name" content="JustLog"/><meta property="og:image" content="https://euidong.github.io/logo192.png"/><title>#Segment Tree | JustLog</title><meta property="og:title" content="#Segment Tree | JustLog"/><link rel="canonical" href="https://euidong.github.io/tags/Segment Tree"/><meta property="og:url" content="https://euidong.github.io/tags/Segment Tree"/><meta name="next-head-count" content="11"/><link rel="icon" href="https://euidong.github.io/favicon.png"/><link rel="apple-touch-icon" href="https://euidong.github.io/logo192.png"/><link rel="preload" href="/_next/static/css/d4ec5c8b3df09443.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d4ec5c8b3df09443.css" data-n-g=""/><link rel="preload" href="/_next/static/css/6dc16d084a5153e5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6dc16d084a5153e5.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" id="Adsense-id" data-ad-client="ca-pub-7452732177557701" async="" defer="" data-nscript="beforeInteractive"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-81da43a8dcd978d9.js" defer=""></script><script src="/_next/static/chunks/main-7b6c38cbad60dfcf.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6cd222d8e75f49d5.js" defer=""></script><script src="/_next/static/chunks/675-ae8e8a351ce30ae2.js" defer=""></script><script src="/_next/static/chunks/pages/tags/%5Bsubject%5D-8f5ae22995c00eb4.js" defer=""></script><script src="/_next/static/oSh_239mr3F_rTzlkFM_Q/_buildManifest.js" defer=""></script><script src="/_next/static/oSh_239mr3F_rTzlkFM_Q/_ssgManifest.js" defer=""></script><script src="/_next/static/oSh_239mr3F_rTzlkFM_Q/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_wrapper__dKJSz root"><header class="Layout_header__XosLl" style="position:static"><div><button tabindex="1" class="SideBarToggler_search_bar_toggler__CEuUg"><svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 24 24" height="35px" width="35px" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor"></path><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor"></path><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor"></path></svg></button><nav class="SideBar_side_bar__wrapper--close__8Nwnr"><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/">Home</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/tags">Tags</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Algorithm">Algorithm<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->11<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Computer%20Architecture">Computer Architecture<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->7<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Tech">Tech<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->17<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Web">Web<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->4<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Paper">Paper<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->2<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Network">Network<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->11<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/AI">AI<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->12<!-- -->)<!-- --></span></a></nav></div><a class="Logo_logo___yD0t" tabindex="1" href="/"></a><div><button class="SearchBarToggler_search_bar_toggler__3dHbA" tabindex="2"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="25px" width="25px" xmlns="http://www.w3.org/2000/svg"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"></path></svg></button></div></header><section><div class="RowCard_row_card__list__background___xFj5"><h1 class="RowCard_row_card__list__title__t4a2h"> Segment  Tree</h1><label class="RowCard_row_card__list__select__wrapper__TZ4_9"><select class="RowCard_row_card__list__select__dxkxA"><option class="RowCard_row_card__list__select__option__GRKZU">최신순<!-- --></option><option class="RowCard_row_card__list__select__option__GRKZU">AtoZ<!-- --></option><option class="RowCard_row_card__list__select__option__GRKZU">ZtoA<!-- --></option></select></label><ul class="RowCard_row_card__list__wrapper__5Gtgi"><div class="RowCard_row_card__wrapper__kohuv"><a class="RowCard_row_card__thumbnail__wrapper__bedY4" href="/posts/accumerated-number"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:200px;height:200px;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><img alt="누적합" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fixed" class="RowCard_row_card__thumbnail__Dh_84" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="누적합" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=256 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="fixed" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="RowCard_row_card__thumbnail__Dh_84" loading="lazy"/></noscript></span></a><div class="RowCard_row_card__tray__trcA5"><a class="RowCard_row_card__tray__title__lVniM" tabindex="-1" href="/posts/accumerated-number">누적합</a><div class="RowCard_row_card__tray__date__3cY_j">2022년 4월 30일 14시 09분</div><ul class="RowCard_row_card__tray__tag__qXmOl"><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0"># <!-- -->자료구조<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/Segment%20Tree"># <!-- -->Segment Tree<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/Fenwick%20Tree"># <!-- -->Fenwick Tree<!-- --></a></ul></div></div></ul></div></section><footer class="Layout_footer__EL5v8"><div class="Layout_footer__copyright__r5baC"><span>Copyright © euidong</span><br/><span>모든 컨텐츠에 대한 저작권은 작성자에게 존재합니다. <!-- --><br/>불법 복제를 통한 상업적 사용을 절대적으로 금지합니다. <!-- --><br/>단, 비상업적 이용의 경우 출처 및 링크를 적용한다면 자유롭게 사용가능 합니다.<!-- --></span><span>Also I use photos by<!-- --> <!-- --><a href="https://unsplash.com/@lorenzoherrera?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Lorenzo Herrera</a> <!-- -->on<!-- --> <!-- --><a href="https://unsplash.com/s/photos/tech?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Unsplash</a></span></div><div class="Layout_footer__contents__YZWSm"><a class="Layout_footer__contents__link__K_TKH" href="https://github.com/euidong" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>github</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://euidong.github.io/portfolio" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M6 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-5 6s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H1zM11 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5zm.5 2.5a.5.5 0 0 0 0 1h4a.5.5 0 0 0 0-1h-4zm2 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2zm0 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2z"></path></svg><span>portfolio</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://chrome.google.com/webstore/detail/bonfire/nkooidijgbppkojdgkoafcoppnohdfka?hl=ko" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M5.016 16c-1.066-2.219-0.498-3.49 0.321-4.688 0.897-1.312 1.129-2.61 1.129-2.61s0.706 0.917 0.423 2.352c1.246-1.387 1.482-3.598 1.293-4.445 2.817 1.969 4.021 6.232 2.399 9.392 8.631-4.883 2.147-12.19 1.018-13.013 0.376 0.823 0.448 2.216-0.313 2.893-1.287-4.879-4.468-5.879-4.468-5.879 0.376 2.516-1.364 5.268-3.042 7.324-0.059-1.003-0.122-1.696-0.649-2.656-0.118 1.823-1.511 3.309-1.889 5.135-0.511 2.473 0.383 4.284 3.777 6.197z"></path></svg><span>chat</span></a></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"content":"\n## Intro\n\n**구간 누적합**을 구하는 경우가 많이 발생한다. 하지만, 이를 저장하기 위해서 너무 많은 공간을 쓸 수는 없다. 예를 들어서 크기가 10,000인 집합에서 누적합으로 만들 수 있는 특정 수의 경우의 수를 구하고자 한다고 가정하자.\n\n이 경우에 우리는 모든 누적합을 저장하기에는 공간이 너무 크다는 것을 알 수 있고, 이를 그렇다고 Brute Force하게 수행하기에도 시간이 충분하지 않을 수도 있다.\n\n따라서, 우리는 효율적으로 누적합 정보를 저장할 수 있는 자료구조를 만들었다.\n그것이 `Segment Tree`와 `Fenwick Tree`이다. 이들을 하나씩 살펴보도록 하자.\n\n## Segment Tree\n\n이전에 tree posting에서 Tree를 표현하는 방법으로 List를 소개하였다. 여기서도 그 방식을 이용해야 하니 잘 알지 못하겠다면, 한 번 보고 오도록 하자. 👉 [posting](/posts/tree)\n\n우선 Segment Tree는 누적합을 표현하기 위한 이진 트리 형태의 자료구조이다. 이전에 트리는 데이터를 분류하기 위해 자주 사용한다고 하였는데, 이곳에서도 동일하다.\n\n이는 트리의 leaf node가 원래 누적합을 배우고자 하는 리스트의 원소가 된다. 그리고 그 부모는 해당 원소들의 합으로 표현된다. 이렇게 하여 root는 전체 리스트의 총합이 되는 형태로 구현하는 것이다.\n\n이러한 자료 구조를 가지게 되면 우리는 두 가지의 장점을 가질 수 있다.\n\n1. 특정 구간에서의 누적합을 굉장히 빠르게 구할 수 있다. ($\\log{N}$)\n2. 업데이트 시에도 깨지지 않고, 이를 빠르게 적용할 수 있다. ($\\log{N}$)\n\n### 누적합 구하기 in segment\n\n우선 해당 트리가 이미 만들어졌다는 가정하에서 어떻게 $\\log{N}$ 만에 **누적합을 찾을 수 있는지**를 확인해보자.\n\n이는 1번째 index b에서부터 6번째 index g까지의 합을 구하는 연산이다.\n\n![segment tree find](/images/segment-tree-find.jpeg)\n\n위에서 부터 탐색을 하기 위해서 다음과 같은 동작을 수행한다.\n\n1. 내가 조회하고자 하는 범위가 해당 지점이 표현하는 범위의 밖이라면, 해당 지점은 의미없으므로, 탐색을 중지한다.\n2. 조회 범위가 해당 지점을 완전 포함한다면, 해당값을 반환한다. (가장 큰 범위를 포함하는 지점에서부터 탐색하기 때문에 조회 범위에 엉뚱한 것이 섞이지 않는다.)\n3. 만약, 그렇지 않다면 해당 지점에 포함된 영역을 더 추출해야 하기 때문에 하위 지점으로 이동한다.\n\n노드 방문 횟수가 대략 $\\log{N}$ 까지 감소하는 것을 볼 수 있다.\n\n### 누적합 갱신 in segment\n\n이제 실제로 **update를** 수행해보자.\n\n5번째 index f에 1을 더하는 연산을 수행하는 그림이다.\n\n![segment tree update](/images/segment-tree-update.jpeg)\n\n위에서 부터 변동사항을 적용하기 위해서 다음과 같은 동작을 수행한다.\n\n1. 내가 추가하고자 하는 위치가 해당 지점이 표현하는 범위의 밖이라면, 해당 지점은 의미없으므로, 탐색을 중지한다.\n2. 추가하고자 하는 값을 해당 지점에 추가한다.\n3. 해당 지점이 leaf 인지 확인하고, 맞다면 종료한다.\n4. 그렇지 않다면, 하위 지점을 더 탐색한다.\n\n### 구현 in segment\n\n업데이트 시에도 복잡한 연산이 없이 바로 내려가면서, 덧셈이 필요한 구역에 더해주는 것으로 쉽게 구현이 가능하다.\n\n```python\nS = [1,2,3,4,5,6,7]\n# tree의 크기는 원래 원래의 배열의 크기보다 큰 2의 제곱수 * 2 - 1이다.\n# 하지만, 이를 더 쉽게 만드는 방법은 간단하게 곱하기 4하는 것이다.\ntree = [0] * (len(S) * 4)\n\n# 트리를 구성하는 함수이다.\n# 루트에서부터 호출하지만, 결과는 밑에서 부터 구하면서 올라온다.\ndef make_seg(start=0, end=len(S) - 1, cursor=1):\n  if start == end:\n    tree[cursor] = S[start]\n    return tree[cursor]\n  mid = (start + end) // 2\n  tree[cursor] = make_seg(start, mid, 2 * cursor) + \\\n                  make_seg(mid + 1, end, 2 * cursor + 1)\n  return tree[cursor]\n\n# 위에서 보았던 누적합을 조회하는 연산이다.\ndef find(left, right, cursor=1, start=0, end=len(S)-1):\n  if left \u003e end or right \u003c start:\n    return 0\n  if left \u003e= start and right \u003c= end:\n    return tree[cursor]\n  mid = (start + end) // 2\n  return find(left, right, cursor * 2, start, mid) \\\n    + find(left, right, cursor * 2 + 1, mid + 1, end)\n\n# 위에서 보았던 누적합을 업데이트 하는 연산이다.\ndef update(idx, diff, cursor=1, start=0, end=len(S) - 1):\n  if idx \u003e end or idx \u003c start:\n    return\n  tree[cursor] += diff\n  if start == end:\n    return\n  mid = (start + end) // 2\n  update(idx, diff, start, mid)\n  update(idx, diff, mid + 1, end)\n\nmake_seg() \nprint(find(1, 6)) # 28\nupdate(3, 5)\nprint(find(1, 6)) # 33\n```\n\n## Fenwick Tree\n\nsegment tree와 동일하게 fenwick tree도 list를 통해서 tree를 표현한다.\n또한, segment tree에서는 기존 배열의 시작점을 어디로 하던 상관없었지만, 구현 상의 편의를 위해서 기존 배열을 왼쪽에서 한 칸 밀어주는 것을 추천한다.\n\n기본적으로 Fenwick Tree는 이진수의 특징을 활용한 연산을 통해서 합을 빠르게 찾을 수 있다. 먼저 Fenwick tree는 다음과 같은 형태로 구조화된다.\n\n![fenwick-tree](/images/fenwick-tree.jpeg)\n\n즉, 해당 수의 약수 중 가장 큰 2의 제곱 수만큼 자신을 포함한 하위 수의 누적합을 포함하는 방식이다. 따라서, 홀수의 경우는 자신만을 누적합으로 가지는 것을 볼 수 있다.\n이렇게 구조화된 데이터는 LSB(Least Significant Bit, 이진수에서 가장 오른쪽에 있는 bit를 의미한다.)라는 특징을 이용해서 누적합과 해당 원소를 포함한 대상들을 찾기에 유용하다.\n\n### 누적합 구하기 in Fenwick\n\n우선 Fenwick Tree는 구간합을 반드시 맨 처음부터 특정 위치까지 구하는 연산만 수행가능하다. 따라서 구간이 처음부터가 아니라면, Fenwick Tree의 조회 연산을 두 번 수행하여 두 값을 빼서 구한다.\n\n\u003e 예시\n\n1. h라는 값을 조회하는 경우  \n  $$\n  \\begin{align}\n      \u0026= origin[8] \\notag \\\\\n      \u0026= sum(8) - sum(7) \\notag \\\\\n      \u0026= fenwick[8] - (fenwick[4 to 7]) \\notag\n  \\end{align}\n  $$\n2. e + f + g의 구간합이 필요한 경우  \n  $$\n  \\begin{align}\n      \u0026= origin[5to7] \\notag \\\\\n      \u0026= sum(7) - sum(4) \\notag \\\\\n      \u0026= (fenwick[4 to 7]) - fenwick[4] \\notag\n  \\end{align}\n  $$\n\n여기서 `sum`을 구현하기 위해서 parameter로 들어온 값의 LSB에서 부터 1을 삭제하면서 진행하면 된다.\n즉, 7이 들어왔다면, 이는 이진수로 $111_{(2)}$이고, 오른쪽에서부터 1을 발견할 때마다 해당 값을 누적합에 축적하고, 삭제하면 된다.\n\n1. 누적합 acc를 0으로 초기화한다.\n2. $111_{(2)}$는 LSB가 1이다. 따라서, 누적합에 fenwick[$111_{(2)} = 7$]를 더한다.\n3. $111_{(2)}$에서 마지막 1을 지운다. (결과값은 $110_{(2)}$)\n4. $110_{(2)}$는 LSB의 다음이 1이다. 따라서, 누적합에 fenwick[$110_{(2)} = 6$]를 더한다.\n5. $110_{(2)}$에서 마지막 1을 지운다. (결과값은 $100_{(2)}$)\n6. $100_{(2)}$는 LSB의 다다음이 1이다. 따라서, 누적합에 fenwick[$100_{(2)} = 6$]를 더한다.\n7. $100_{(2)}$에서 마지막 1을 지운다. (결과값은 $000_{(2)}$)\n8. 결과값이 0이므로 탐색을 종료한다.\n\n![fenwick-tree-add](/images/fenwick-sum.jpeg)\n\n### 누적합 갱신 in fenwick\n\n특정 값에 누적합을 갱신하는 것 역시 간단하게 구현이 가능하다. LSB에서 가장 가까운 1에 1을 더해주는 연산을 더해가면서 업데이트를 수행해주면 된다.\n\n1. $11_{(2)}$는 LSB가 1이다. 따라서, fenwick[$11_{(2)} = 3$]에 값을 더한다.\n2. $11_{(2)}$에서 가장 오른쪽의 1을 더한다. (결과값은 $100_{(2)}$)\n3. $100_{(2)}$는 LSB의 다디음이 1이다. 따라서, fenwick[$100_{(2)} = 4$]에 값을 더한다.\n4. $100_{(2)}$에서 마지막 1을 더한다. (결과값은 $1000_{(2)}$)\n5. $1000_{(2)}$는 LSB의 다다다음이 1이다. 따라서, 누적합에 fenwick[$1000_{(2)} = 8$]에 값을 더한다.\n6. 더이상 더하는 것은 범위 밖이므로 종료한다.\n\n![fenwick-tree-update](/images/fenwick-update.jpeg)\n\n### 구현 in fenwick\n\n```python\norigin = [None, 1,2,3,4,5,6,7,8,9]\nfenwick = [0] * len(origin)\n\ndef update(idx, val):\n  while idx \u003c len(fenwick):\n    fenwick[idx] += val\n    idx += (idx \u0026 -idx)\n\ndef sum(idx):\n  acc = 0\n  while idx \u003e 0:\n    acc += fenwick[idx]\n    idx -= (idx \u0026 -idx)\n  return acc\n\ndef make_fen(origin):\n  for idx in range(1, len(origin)):\n    update(idx, origin[idx])\n\nmake_fen(origin)\nprint(sum(7) - sum(4)) # 18\nupdate(5, 5)\nprint(sum(7) - sum(4)) # 23\n```\n\n## Versus\n\n둘 다 구간합을 구하기에 적합한 구조이지만 다음과 같은 차이점을 가지고 있다는 점을 명시하자. 상대적으로 활용성이 높은 Segment Tree를 사용하는 것이 대다수 좋을 수 있지만, Fenwick Tree가 가지는 크기의 장점과 코드의 구현이 쉽다는 점은 굉장한 이점이다.\n\n|                    | Segment Tree                                      | Fenwick Tree                  |\n| :----------------- | :------------------------------------------------ | :---------------------------- |\n| find 시간복잡도    | $O(\\log{N})$                                      | $O(\\log{N})$                  |\n| update 시간복잡도  | $O(\\log{N})$                                      | $O(\\log{N})$                  |\n| 공간복잡도(사이즈) | $2^{k + 1}$($2^{k} \\ge$ len(origin))              | len(origin)                   |\n| 활용성             | 구간 내 합 뿐만 아니라 최대, 최소값으로 응용 가능 | **오직 구간 합에만 사용가능** |\n| 구현 코드 길이     | 상대적으로 김                                     | 상대적으로 짧음               |\n","slug":"accumerated-number","date":"2022-04-30 14:09","title":"누적합","category":"Algorithm","tags":["자료구조","Segment Tree","Fenwick Tree"],"desc":"구간 누적합을 구하는 경우가 많이 발생한다. 하지만, 이를 저장하기 위해서 너무 많은 공간을 쓸 수는 없다. 예를 들어서 크기가 10,000인 집합에서 누적합으로 만들 수 있는 특정 수의 경우의 수를 구하고자 한다고 가정하자.이 경우에 우리는 모든 누적합을 저장하기에는 공간이 너무 크다는 것을 알 수 있고, 이를 그렇다고 Brute Force하게 수행하기에도 시간이 충분하지 않을 수도 있다.따라서, 우리는 효율적으로 누적합 정보를 저장할 수 있는 자료구조를 만들었다.그것이 Segment Tree와 Fenwick Tree이다. 이들을 하나씩 살펴보도록 하자.","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"}],"params":{"subject":"Segment Tree"}},"__N_SSG":true},"page":"/tags/[subject]","query":{"subject":"Segment Tree"},"buildId":"oSh_239mr3F_rTzlkFM_Q","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>