<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta property="og:type" content="blog"/><meta property="og:site_name" content="JustLog"/><meta property="og:image" content="https://euidong.github.io/logo192.png"/><title>#PCFG | JustLog</title><meta name="description" content="#PCFG 관련 Posting"/><meta property="og:description" content="#PCFG 관련 Posting"/><meta property="og:title" content="#PCFG | JustLog"/><link rel="canonical" href="https://euidong.github.io/tags/PCFG"/><meta property="og:url" content="https://euidong.github.io/tags/PCFG"/><meta name="next-head-count" content="11"/><link rel="icon" href="https://euidong.github.io/favicon.png"/><link rel="apple-touch-icon" href="https://euidong.github.io/logo192.png"/><link rel="preload" href="/_next/static/css/d4ec5c8b3df09443.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d4ec5c8b3df09443.css" data-n-g=""/><link rel="preload" href="/_next/static/css/6dc16d084a5153e5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6dc16d084a5153e5.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" id="Adsense-id" data-ad-client="ca-pub-7452732177557701" async="" defer="" data-nscript="beforeInteractive"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-81da43a8dcd978d9.js" defer=""></script><script src="/_next/static/chunks/main-7b6c38cbad60dfcf.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8d9b43c3d8042477.js" defer=""></script><script src="/_next/static/chunks/675-ae8e8a351ce30ae2.js" defer=""></script><script src="/_next/static/chunks/pages/tags/%5Bsubject%5D-0fc8f67b45fbbd0f.js" defer=""></script><script src="/_next/static/OvWLoXKcdteK-xIHNhJEy/_buildManifest.js" defer=""></script><script src="/_next/static/OvWLoXKcdteK-xIHNhJEy/_ssgManifest.js" defer=""></script><script src="/_next/static/OvWLoXKcdteK-xIHNhJEy/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_wrapper__dKJSz root"><header class="Layout_header__XosLl" style="position:static"><div><button tabindex="1" class="SideBarToggler_search_bar_toggler__CEuUg"><svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 24 24" height="35px" width="35px" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor"></path><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor"></path><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor"></path></svg></button><nav class="SideBar_side_bar__wrapper--close__8Nwnr"><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/">Home</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/tags">Tags</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Algorithm">Algorithm<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->11<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Computer%20Architecture">Computer Architecture<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->7<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Tech">Tech<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->17<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Web">Web<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->4<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Paper">Paper<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->2<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Network">Network<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->11<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/AI">AI<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->20<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Memoir">Memoir<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->1<!-- -->)<!-- --></span></a></nav></div><a class="Logo_logo___yD0t" tabindex="1" href="/"></a><div><button class="SearchBarToggler_search_bar_toggler__3dHbA" tabindex="2"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="25px" width="25px" xmlns="http://www.w3.org/2000/svg"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"></path></svg></button></div></header><section><div class="RowCard_row_card__list__background___xFj5"><h1 class="RowCard_row_card__list__title__t4a2h">PCFG</h1><label class="RowCard_row_card__list__select__wrapper__TZ4_9"><select class="RowCard_row_card__list__select__dxkxA"><option class="RowCard_row_card__list__select__option__GRKZU">최신순<!-- --></option><option class="RowCard_row_card__list__select__option__GRKZU">AtoZ<!-- --></option><option class="RowCard_row_card__list__select__option__GRKZU">ZtoA<!-- --></option></select></label><ul class="RowCard_row_card__list__wrapper__5Gtgi"><div class="RowCard_row_card__wrapper__kohuv"><a class="RowCard_row_card__thumbnail__wrapper__bedY4" href="/posts/nlp-language-parsing"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:200px;height:200px;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><img alt="[NLP] 8. Language Parsing" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fixed" class="RowCard_row_card__thumbnail__Dh_84" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="[NLP] 8. Language Parsing" srcSet="https://euidong.github.io/images/nlp-thumbnail.jpg?imwidth=256 1x, https://euidong.github.io/images/nlp-thumbnail.jpg?imwidth=640 2x" src="https://euidong.github.io/images/nlp-thumbnail.jpg?imwidth=640" decoding="async" data-nimg="fixed" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="RowCard_row_card__thumbnail__Dh_84" loading="lazy"/></noscript></span></a><div class="RowCard_row_card__tray__trcA5"><a class="RowCard_row_card__tray__title__lVniM" tabindex="-1" href="/posts/nlp-language-parsing">[NLP] 8. Language Parsing</a><div class="RowCard_row_card__tray__date__3cY_j">2022년 11월 7일 15시 05분</div><ul class="RowCard_row_card__tray__tag__qXmOl"><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/NLP"># <!-- -->NLP<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/POS"># <!-- -->POS<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/PCFG"># <!-- -->PCFG<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/Morphology"># <!-- -->Morphology<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/Syntax"># <!-- -->Syntax<!-- --></a><a class="RowCard_row_card__tray__tag__li__7_3Zt" tabindex="-1" href="/tags/Semantics"># <!-- -->Semantics<!-- --></a></ul></div></div></ul></div></section><footer class="Layout_footer__EL5v8"><div class="Layout_footer__copyright__r5baC"><span>Copyright © euidong</span><br/><span>모든 컨텐츠에 대한 저작권은 작성자에게 존재합니다. <!-- --><br/>불법 복제를 통한 상업적 사용을 절대적으로 금지합니다. <!-- --><br/>단, 비상업적 이용의 경우 출처 및 링크를 적용한다면 자유롭게 사용가능 합니다.<!-- --></span><span>Also I use photos by<!-- --> <!-- --><a href="https://unsplash.com/@lorenzoherrera?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Lorenzo Herrera</a> <!-- -->on<!-- --> <!-- --><a href="https://unsplash.com/s/photos/tech?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Unsplash</a></span></div><div class="Layout_footer__contents__YZWSm"><a class="Layout_footer__contents__link__K_TKH" href="https://github.com/euidong" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>github</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://euidong.github.io/portfolio" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M6 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-5 6s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H1zM11 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5zm.5 2.5a.5.5 0 0 0 0 1h4a.5.5 0 0 0 0-1h-4zm2 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2zm0 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2z"></path></svg><span>portfolio</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://chrome.google.com/webstore/detail/bonfire/nkooidijgbppkojdgkoafcoppnohdfka?hl=ko" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M5.016 16c-1.066-2.219-0.498-3.49 0.321-4.688 0.897-1.312 1.129-2.61 1.129-2.61s0.706 0.917 0.423 2.352c1.246-1.387 1.482-3.598 1.293-4.445 2.817 1.969 4.021 6.232 2.399 9.392 8.631-4.883 2.147-12.19 1.018-13.013 0.376 0.823 0.448 2.216-0.313 2.893-1.287-4.879-4.468-5.879-4.468-5.879 0.376 2.516-1.364 5.268-3.042 7.324-0.059-1.003-0.122-1.696-0.649-2.656-0.118 1.823-1.511 3.309-1.889 5.135-0.511 2.473 0.383 4.284 3.777 6.197z"></path></svg><span>chat</span></a></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"content":"\n## Intro\n\n우리가 NL을 제대로 분석하기 위해서 각 단어가 가진 의미를 알아야하며, 이를 넘어서 문장이 가지는 의미를 파악해야 한다. 결론적으로 이 과정이 고도화된 NLP를 위한 핵심 단계이다. 이를 위해서는 Raw한 형태로 주어진 text를 처리해서 더 나은 형태의 구조를 만들 필요가 있다. 따지고 보면 하나의 전처리 과정이라고 볼 수 있다. 그치만 이전 text processing chapter과 다른 점은 문장 구분과 같은 간단한 과정이 아닌 Linguistic 단계에 따른 처리 과정을 수행한다고 볼 수 있다. 또한, 각 단계 역시 NLP 중에 하나라고 할 수 있으므로 이 또한 ML과 DL을 통해서 고도화하는 것도 가능하다. Morphology 단계부터 시작하여 Syntax, Semantic까지 어떻게 다루게 되는지를 살펴보도록 하겠다.\n\n## POS tagging\n\nMorphology 단계에서 가장 기본이되는 요소이기 때문에 이를 먼저 살펴보도록 하겠다. Part of Speech라는 단어의 뜻 자체가 \"품사\"이다. 이는 단어의 문법적인 기능이나 형태 등을 표현하기 위해서 제시되었다. 이를 구분하려는 시도는 디오니소스 이전부터 있었지만 근본적인 형태를 제시한 것은 디오니소스가 첫 번째이다. 그는 기원전 100년에 지금과 굉장히 유사한 형태의 8개의 품사를 제시하였다. 지금도 8개지만, 감탄사와 형용사 등이 추가되고 몇몇 요소가 빠졌다. 이를 NLP 과정에서 input으로 활용하게 되면 언어의 모호성을 해결하는데 도움을 줄 수 있다. 품사를 통해서 단어가 가지는 뜻의 범위가 더 줄어들 수 있기 때문이다. 따라서, 이를 각 단어마다 표시하는 절차를 preprocessing으로 진행하는 경우도 많다.\n\n우선 POS의 일반적인 종류는 다음과 같다.\n\n- Noun(명사)\n- Verb(동사)\n- Adjective(형용사)\n- Adverb(부사)\n- Preposition(전치사)\n- Conjunction(접속사)\n- Pronoun(대명사)\n- Interjection(감탄사)\n\n하지만, Computer Science에서는 이를 좀 더 명확하게 표현하기 위해서 더 많은 분류(tag)를 사용하는 것이 일반적이다. 대표적인 예시가 [🔗 Penn Treebank](https://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html)이다. 여기서는 36개의 종류를 활용하여 표기한다. 이외에도 Brown Corpus 등 다양한 tagging 방법이 있다. 또한, 언어에 따라서는 별도의 품사를 정의하는 경우도 많기 때문에 언어마다 적절한 방식을 사용해주는 것이 좋다.\n\ntag를 정할 때 일반적인 규칙은 우리가 중/고등학교 시간에 배웠을 문법 요소를 적용한 것이 많다는 점을 기억하면 된다. NNS 같은 경우는 복수명사 뒤에 붙은 s를 포함하는 tag를 의미하고, VBD는 동사 과거형을 의미한다. 이와 같은 형태로 품사를 좀 더 세분화한 것 외에는 차이가 없다.\n\n### How can I get?\n\n그렇다면, 어떻게 하면 POS tagging된 데이터를 얻을 수 있을지가 궁금할 것이다. 신기하게도 가장 쉬운 추론을 하더라도 90%의 정확도를 가질 수 있다. 다음과 같은 방법이다.\n\n1. 단어가 가지는 품사 중 가장 빈도가 높은 것을 표기한다.\n2. 못 본 단어인 경우 Noun(명사)로 표기한다.\n\n이것이 가능한 이유는 사실상 대부분의 word는 모호하지 않다는 점이다. 대부분의 word는 품사 앞에서는 그렇게 변화무쌍하지 않다. **하지만,** 특정 word는 사람 조차도 헷갈리는 경우가 있다. 대게 통계적으로 11%정도는 사람 조차도 헷갈릴 수 있는 형태의 품사가 주어진다고 한다. 그래서, 이를 해결하기 위해서 Statistic Inference를 활용하는 경우가 있고, 우리가 앞 서 배웠던 HMM을 활용하면 97%, MaxEnt를 활용하면 99% 정확도를 가지는 tagger를 만들 수 있다. 물론 더 복잡한 Deep Learning을 활용한다면 더 높은 성능도 가능은 할 것이다.\n\n## Morphology\n\nMorphology 단계에서 POS tagging이 중요하긴 하지만 더 나아갈 필요가 있다. 결국 우리가 원하는 것은 단어의 의미를 더 완벽하게 찾는 것이다. 따라서, 대게의 경우 POS tagging을 포함하는 Morphology tagging을 수행한다. 특정 단어를 사전형 기본형(lemma) 또는 더 나아가 가장 뿌리가 되는 요소 root와 stem으로 나누고 여기에 품사를 덧붙이는 형태이다. 우리가 얻은 품사(tag)와 lemma만 갖고도 우리는 원래 단어를 만드는 것이 가능하고, 뜻의 범위를 더 한정할 수 있다. 더 나아가 root와 stem으로 나누게 되면 보지 못한 데이터에 대해서도 더 면밀한 의미 파악이 가능해진다. 이를 구현할 때에는 대게 4가지 방법 중에 하나를 수행하는 것이 일반적이다.\n\n1. Word form list  \n   간단하게 생각하면, word list에서 단어를 조회하는 방식이다. 대게 key, value보다는 Trie 형태로 담는 것을 선호한다. Trie는 각 node가 sequence 데이터의 요소 하나하나가 되는 tree를 의미하며, sequence 데이터의 조회를 위해 사용된다.\n2. Direct coding  \n   root와 stem을 찾는 과정은 사실 영어에서는 간단하다. 앞 뒤에서 부터 진행하면서 대표적인 stem을 제거해 나가면, root만 남기 때문이다. 하지만, 일부 일본어와 같은 경우에는 이것이 불가능한 경우도 있다. 이 경우에는 다른 방식을 적용해야 한다.\n3. Finite state machinery  \n   각 단어의 형태를 FSM으로 정의하여 변할 수 있는 형태와 이에 따른 품사 등을 미리 표현하여 정의하는 방법이다.\n4. CFG, DATR, Unification  \n   언어학에 기반한 분석법이다.\n\n사실 이러한 방법을 직접 구현하는 것은 한계가 있을 수 있다. 따라서, 이미 구현되어 있는 POS tagger를 사용하는 것이 현명할 수 있다. 일반적으로 가장 많이 사용되는 POS tagger는 다음과 같은 것들이 있다.\n\n| Library | Language | ProgrammingLanguage |\n| :------ | :------- | :------------------ |\n| NLTK    | English  | Python              |\n| spaCy   | English  | Python              |\n| KoNLPy  | 한글     | Python              |\n\n## Syntactic Analysis\n\nMorphology 단계에서는 각 word의 뜻을 다루었다면, 이 단계는 word의 결합으로 이루어지는 문장 구조를 분석하는 단계이다. 문장 구조를 분석(구문 분석)하는 방법은 크게 두 가지로 나뉘어진다.\n\n1. \u003cmark\u003e**Phrase Structure**\u003c/mark\u003e  \n   문장을 Phrase(구) 단위로 나누어 구조화 시키는 방법이다. 단어 각 각의 품사에서 부터 시작하여 이들을 묶어서 하나의 문장 요소(대게 phrase)를 만들어 하나의 문장을 만드는 구조를 가진다.\n2. \u003cmark\u003e**Dependency Structure**\u003c/mark\u003e  \n   문장에서 각 단어가 가지는 의존 관계를 나타낸 구조이다.\n\n각 구조는 둘다 Tree 형태로 이루어지며, 분석하는 방법도 서로 매우 다르다. 각 방법은 밑에서부터 자세히 다루도록 하겠다.\n\n### Phrase Structure\n\n문장을 이루는 요소들과 요소들의 구조화 규칙을 정의해야 우리는 이를 분석할 수 있을 것이다. 따라서, 이를 정의한 것을 Grammar라고 한다. 그리고 이를 위해서 대표적으로 사용되는 것이 **CFG**이다. **CFG**는 Context Free Grammar의 약자로, 모든 잘 구조화된 문장들을 정의할 수 있는 규칙들을 의미한다. 각 각의 Rule은 왼쪽에는 문법적 type이 주어지고, 오른쪽에는 이를 이루는 요소들이 정의되어진다. 각 요소는 하위 문법적 type 또는 이전에 제시한 POS가 될 수 있다.\n\n가장 기본적으로 사용되어지는 문법적 type들은 다음과 같다. 이외에도 기술하지 않은 POS도 사용이 가능하다.\n\n| Symbol  | Mean               | Korean   |\n| :------ | :----------------- | :------- |\n| NP      | Noun Phrase        | 명사 구  |\n| VP      | Verb Phrase        | 동사 구  |\n| S       | Sentence           | 문장     |\n| DET(DT) | Determiner         | 관사     |\n| N       | NOUN               | 명사     |\n| V       | Verb               | 동사     |\n| PREP    | Preposition        | 전치사   |\n| PP      | Preposition Phrase | 전치사구 |\n\n이에 따라 대표적인 Rule은 다음과 같다.\n\n- S -\u003e NP VP\n- NP -\u003e (DT) N\n- NP -\u003e N\n- VP -\u003e V (NP)\n\n위에 제시된 Rule은 가장 기본적인 규칙으로 여기서 더 확장된 규칙을 만들어서 Parsing을 수행할 수 있다. 하지만, 이렇게 규칙을 만들어서 수행을 하게 되면 문제가 발생할 수 있다. 바로 여러 개의 Parsing Result가 만들어졌을 때 이 중에서 어떤 것이 가장 적절한지를 알 수 없다는 것이다. 즉, 너무 구체적인 Rule을 만들기에는 Parsing이 하나도 되지 않는 문장이 만들어질 가능성이 높고, 그렇다고 너무 적은 Rule을 적용하게 되면 Parsing이 너무 많이 만들어지게 된다.\n\n따라서, 결론적으로 말하자면 위와 같은 형태의 CFG로는 phrase structure를 구조화하는데 한계가 있다는 결론을 내리게 된다. 결국 아래와 같은 두 개의 문제점에 직면하게 되고 이를 해결하기 위한 방법이 각 각 제시된다.\n\n1. Repeated work  \n   문장 구조가 동일한 경우 결국 동일한 작업을 반복하게 된다. 이를 해결하기 위해서 Treebank라는 구조를 도입하고, 이것의 일부를 Dynamic Programming의 Memoization처럼 저장해두었다가 쓰는 방식을 적용한다. 즉, 기존에는 Rule만을 저장하고, 때에 따라 이를 적용하였다면, 이제는 모든 단어의 품사와 구조를 기록해두는 것이다. 이를 통해서 이미 나왔던 작업의 경우 빠른 처리가 가능해진다.\n2. Choosing the correct parse  \n   위에서 말했던 것처럼 우리는 결국 \u003cmark\u003e가장 적절할 거 같은 parsing result를 선택해야 한다.\u003c/mark\u003e Rule에 기반한 방식으로는 한계가 있지만 우리가 Statistic한 방식을 활용한다면 이를 극복할 수 있다. 따라서, 우리는 CFG에서 나아가 PCFG(Probabilistic CFG)를 적용하여 이를 처리할 수 있다. 이러한 Statistical한 결과를 얻기 위해서도 Treebank 구조가 필요하다.\n\n![nlp-cfg-treebank](/images/nlp-cfg-treebank.jpg)\n\n이제부터는 실제로 PCFG를 어떻게 수행할 수 있는지를 자세히 다뤄보도록 하겠다.\n\n#### PCFG\n\n앞 서 얘기한 것처럼 Probabilistic CFG로, 각 Rule마다 Probability를 적용하는 것이다. 여기서 유의할 것은 다음 내용이다.\n\n1. 기존 정의한 문법적 type을 만드는 Rule에 각 각의 확률을 정의한다.\n2. 이때 각 문법적 type을 만들 수 있는 Rule의 확률의 합은 반드시 1이다.\n3. 또한, 각 단어가 특정 POS일 확률도 같이 구해야 한다.  \n   ex. N -\u003e fish (0.5), V -\u003e fish (0.1)  \n   (실제로 이렇게 크게 나오지 않는다. N 또는 V 일 때, Fish일 확률이므로 굉장히 작은 값이 나오는 것이 일반적이다.)\n\n따라서, 어떤 treebank가 더 적절한 지는 각 각의 treebank의 모든 Rule의 확률의 곱을 구해서 비교하면 된다. 굉장히 쉽게 이 과정이 가능한 것이다. 아래는 간단한 예시이다.\n\n![nlp-pcfg](/images/nlp-pcfg.jpg)\n\n이렇게 주어졌을 때, $p(t_1)$과 $p(t_2)$는 아래와 같이 구할 수 있다.\n\n$$\n\\begin{align*}\np(t_{1}) \u0026= 1.0 \\\\\n\u0026\\times 0.3 \\times 0.6 \\\\\n\u0026\\times 0.4 \\\\\n\u0026\\times 0.5 \\times 0.1 \\times 0.4 \\times 1.0 \\times 0.4  \\\\\n\u0026= 0.000576 \\\\\n\\\\\np(t_{2}) \u0026= 1.0 \\\\\n\u0026\\times 0.3 \\times 0.4 \\\\\n\u0026\\times 1.0 \\\\\n\u0026\\times 0.4 \\\\\n\u0026\\times 0.5 \\times 0.6 \\times 1.0 \\times 1.0 \\times 0.4 \\\\\n\u0026= 0.00576 \\\\\n\\\\\n\\therefore p(t_{1}) \u0026\\lt p(t_{2})\n\\end{align*}\n$$\n\n따라서, $t_{2}$ 형태가 더 적절하다고 판별할 수 있는 것이다.\n\n```plaintext\n 🤔 Chomsky Normal Form\n\n 기존 CFG의 형태의 모호함을 제거하고, 좀 더 명확한 형태로 정의하는 것을 의미한다.\n 대표적으로 모호한 내용이 Sentence안에 Sentence를 포함하는 경우(n-ary)라든지,\n 명령문과 같은 문장을 위한 주어 삭제(unary/empty) 등이 존재한다.\n 이를 해결하기 위한 recursive 형태나 empty 형태 등을 제거하는 것을 의미한다.\n\n 결론상 PCFG에서는 확률 표기시에 모호한 표기를 제거할 수 있다는 장점이 있다.\n```\n\n#### CKY Parsing\n\n앞 서 우리가 treebank 중에서 더 큰 확률곱 값을 가지는 것이 최적값이라는 것을 알 수 있었다. 하지만, 사실 이 과정이 그렇게 쉽지는 않다. 왜냐하면, 우리가 가지는 Parsing Result는 굉장히 많을 수도 있기 때문이다. 그렇다면, 이를 연산하는 비용이 굉장히 비싸진다. 이를 효과적으로 연산하기 위한 알고리즘으로 제시된 것이 CKY Parsing이다.\n\nPseudo code는 다음과 같다.\n\n```javascript\nfunction CKY(words, grammar) returns [scores, backpointers]\n  // score[i][j] = \n  // 모든 Symbol(문법적 type, ex. S, NP, VP)에 대하여 \n  // i부터 j까지 word를 사용했을 때의 최댓값을 저장\n  score = new double[#(words) + 1][#(words)+1][#(Symbol)]\n  // back[i][j] = \n  // 모든 Symbol(문법적 type, ex. S, NP, VP)에 대하여 \n  // i부터 j까지 word를 사용했을 때의 최댓값을 만드는 요소의 위치를 저장\n  // (=back pointer)\n  back = new Pair[#(words)+1][#(words)+1][#(Symbol)]\n  for (i=0; i \u003c #(words); i++)\n    // 초기화 단계로 각 단어가 Symbol일 확률을 입력\n    for (A in Symbol)\n      if A -\u003e words[i] in grammar\n        score[i][i+1][A] = P(A -\u003e words[i])\n    // unary 즉 생략되어서 표현되는 경우를 위해서 확률 재계산\n    // ex. Stop!! (S-\u003eVP,VP-\u003eV)\n    boolean added = true\n    while (added)\n      added = false\n      for A, B in Symbol\n        if score[i][i+1][B] \u003e 0 \u0026\u0026 A -\u003e B in grammar\n          prob = p(A -\u003e B) * score[i][i+1][B]\n          if prob \u003e score[i][i+1][A]\n            score[i][i+1][A] = prob\n            back[i][i+1][A] = B\n            added = true\n  for (span = 2 to #(words))\n    for (begin = 0 to #(words) - span)\n      // 일반적인 두 항의 합으로 이루어지는 경우를 계산\n      end = begin + span\n      for (split = begin + 1 to end-1)\n        for (A, B, C in Symbol)\n          prob = score[begin][split][B] * score[split][end][C]*P(A -\u003e B C)\n          if prob \u003e score[begin][end][A]\n            score[begin][end][A] = prob\n            back[begin][end][A] = new Triple(split, B, C)\n      // unary인 경우를 고려해서 재계산\n      boolean added = true\n      while (added)\n        added = false\n        for (A, B in Symbol)\n          prob = P(A -\u003e B) * score[begin][end][B]\n          if prob \u003e score[begin][end][A]\n            score[begin][end][A] = prob\n            back[begin][end][A] = B\n            added = true\n  return score, back\n```\n\n전체적인 동작과정은 그림을 통해서 이해할 수 있다. 먼저초기 score 할당부터 첫 단계에 데이터를 저장하기까지는 아래 그림으로 이해할 수 있다.\n각 그림을 다음을 의미한다.\n\n1. score를 위한 공간 할당\n2. score에 가장 기본이 되는 Symbol -\u003e word 확률 입력\n3. unari case를 확인해서 확률 입력\n\n![nlp-cky-1](/images/nlp-cky-1.png)\n\n그 다음 단계로는 단계적으로 관계를 적립한다.\n\n1. 같은 형광펜으로 칠해진 데이터간 관계가 최댓값을 가진다.\n2. unari case도 확인한 결과 S-\u003eVP가 초기화 된다.\n\n![nlp-cky-2](/images/nlp-cky-2.png)\n\n마지막에서 다시 관계를 정리할 때, 유의할 점이 있다. 바로 score\\[0\\]\\[3\\]와 score\\[1\\]\\[4\\]도 중요하지만 score\\[0\\]\\[2\\]와 score\\[2\\]\\[4\\]에 의한 관계도 반드시 유의해서 보아야 한다.\n\n![nlp-cky-3](/images/nlp-cky-3.png)\n\n#### modeling\n\n원래라면, modeling 단계도 다루어야하지만, 해당 단계에서는 넘어가도록 한다. 이를 수행하기 위해서는 간단하게는 단순히 빈도를 확인하는 것부터 EM algorithm을 활용하여 업데이트 하는 방식이 있다. 하지만 여기서는 자세히 다루지 않겠다.\n\n### Dependency Structure\n\n문장에서 각 단어의 의존 관계를 나타내는 Dependency Structure는 중심 의미를 가지는 word로 부터 이에 의존하는 word들의 관계로 확장되며 표기된다. 따라서, 문장에서는 대게 동사가 중심이 되고, 그리고 그 다음으로는 전치사, 명사 등이 뒤를 잇게 된다. 이를 파악하게 되면, 단어가 연관성과 전체적인 구조의 안정성 등을 파악하는데 도움을 줄 수 있다.\n\n이 형태를 얻기 위해서 할 수 있는 대표적인 방법은 다음과 같은 방법이 있다.\n\n1. Dynamic Programming  \n   아주 쉽게 생각할 수 있는 방법으로 **PCFG를 활용**하는 것이다. 일반적으로 PCFG를 활용하여 tree 형태를 구축하면 이를 이용하여 Dependency Structure를 쉽게 구할 수 있다. 단순히 tree의 아래서 부터 의존 관계를 가진 단어를 고르면서 root까지 올라오면 이것으로 충분하다. 하지만, 이 과정은 시간적 비용이 많이 든다는 단점이 있다.\n2. Graph Algorithm  \n   **가장 정확도가 높은 방식**으로 Sentence에 대한 Minimum Spanning Tree를 구성하고, 이를 활용하여 ML classifier를 제작하여 구현할 수 있다. 가장 높은 정확도를 원한다면 해당 방식을 활용하는 경우가 많다.\n3. Constraint Satisfaction  \n   모든 경우의 수를 만들고 거기서 제한사항을 만족하지 않는 구조를 제거하는 방식이다. 이 또한 많이 사용되지는 않는다.\n4. Deterministic Parsing  \n   Greedy algorithm에 기반하여 구현된 방식으로 매우 높지는 않지만 적절한 정확도에 **빠른 속도**를 가지기 때문에 많이 사용되어진다.\n\n#### Malt Parser\n\n여기서는 Deterministic Parsing 중에서 가장 쉬운 방법 중에 하나인 Malt Parser를 좀 더 다뤄보도록 하겠다.\n\n이는 3개의 자료 구조와 4개의 action을 통해서 정의되는 알고리즘이다.  \n먼저 자료구조는 다음과 같다.\n\n1. stack($\\sigma$)  \n   dependency tree의 상위 요소를 저장해두는 공간으로, 처음에는 ROOT라는 요소를 갖고 시작한다.\n2. buffer($\\beta$)  \n   input sequence를 저장하는 공간으로, 처음에는 input sequence를 전체를 저장하고 있다.\n3. arcs($A$)  \n   최종으로 만들고자 하는 dependency tree를 의미한다. 처음에는 비어 있는 상태로 시작한다.\n\naction은 다음과 같다.\n\n1. Reduce  \n   stack($\\sigma$)에서 word를 pop한다.\n2. Shift  \n   buffer($\\beta$)에서 stack($\\sigma$)으로 word를 push한다. 이때 문장의 앞의 단어부터 차례대로 전달한다.\n3. Left-Arc  \n   stack($\\sigma$)의 현재 word가 buffer($\\beta$)의 다음 word에 의존하는 경우, 이 관계를 연결하여 arcs($A$)에 저장한다.  \n   결론상 stack($\\sigma$)에서는 pop이 되고, buffer($\\beta$)는 그대로 유지되며, arcs($A$)에는 depdendency가 하나 추가된다.\n4. Right-Arc  \n   buffer($\\beta$)에서 다음 word를 stack($\\sigma$)에 push하고, 기존 stack($\\sigma$)의 이전 word에 의존하는 관계를 arcs($A$)에 추가한다.\n5. Finish  \n   buffer($\\beta$)에 더 이상 word가 없다면, 모든 연산을 마무리할 수 있다.\n\n이 또한 예시를 통해서 알아보는 것이 명확하다.\n\n우리가 `Happy children like to play with their friends.`를 분석하고 싶다고 하자. 그렇다면, 절차는 다음과 같이 진행된다.\n\n| Index | Action    | Stack($\\sigma$)                   | Buffer($\\beta$)        | Arcs($A$)                                      |\n| :---- | :-------- | :-------------------------------- | :--------------------- | :--------------------------------------------- |\n| 0     |           | [ROOT]                            | [Happy, children, ...] | $\\empty$                                       |\n| 1     | Shift     | [ROOT, Happy]                     | [children, like, ...]  | $\\empty$                                       |\n| 2     | LA(amod)  | [ROOT]                            | [children, like, ...]  | {amod(children, happy) = $A_{1}$}              |\n| 3     | Shift     | [ROOT, children]                  | [like, to, ...]        | $A_{1}$                                        |\n| 4     | LA(nsubj) | [ROOT]                            | [like, to, ...]        | $A_{1} \\cup ${nsubj(like, children)} = $A_{2}$ |\n| 5     | RA(root)  | [ROOT, like]                      | [to, play, ...]        | $A_{2} \\cup ${root(ROOT, like)} = $A_{3}$      |\n| 6     | Shift     | [ROOT, like, to]                  | [play, with, ...]      | $A_{3}$                                        |\n| 7     | LA(aux)   | [ROOT, like]                      | [play, with, ...]      | $A_{3} \\cup ${aux(play, to)} = $A_{4}$         |\n| 8     | RA(xcomp) | [ROOT, like, play]                | [with, their,...]      | $A_{4} \\cup ${xcomp(like, play)} = $A_{5}$     |\n| 9     | RA(prep)  | [ROOT, like, play, with]          | [their, friends, .]    | $A_{5} \\cup ${prep(play, with)} = $A_{6}$      |\n| 10    | Shift     | [ROOT, like, play, with, their]   | [friends, .]           | $A_{6}$                                        |\n| 11    | LA(poss)  | [ROOT, like, play, with]          | [friends, .]           | $A_{6} \\cup ${poss(friends, their)} = $A_{7}$  |\n| 12    | RA(pobj)  | [ROOT, like, play, with, friends] | [.]                    | $A_{7} \\cup ${pobj(with, friends)} = $A_{8}$   |\n| 13    | Reduce    | [ROOT, like, play, with]          | [.]                    | $A_{8}$                                        |\n| 14    | Reduce    | [ROOT, like, play]                | [.]                    | $A_{8}$                                        |\n| 15    | Reduce    | [ROOT, like]                      | [.]                    | $A_{8}$                                        |\n| 16    | RA(punc)  | [ROOT, like, .]                   | []                     | $A_{8} \\cup${punc(like, .)} = $A_{9}$          |\n| 17    | Finish    | [ROOT, like, .]                   | []                     | $A_{9}$                                        |\n\n자 이런 예시를 보았다면, 당연히 궁금해할 것은 어떻게 Action을 고를 것인가이다. 이는 Discriminative classifier 즉, Maxent나 여타 Machine Learning 방법을 동원하여 결정한다. PCFG를 활용하는 방식보다는 성능이 약간 낮을지라도 이를 활용하면 매우 빠르게 parsing이 가능하다는 장점이 있다.\n\n```plaintext\n 🤔 Projectivity\n \n 사실 여태까지 우리는 연속되어 있는 word간의 의존성을 파악하는 과정을 살펴보았다.(특히 PCFG)\n 하지만, 그렇지 않은 경우도 분명히 존재한다. 대표적인 예시가 아래이다.\n Who did Bill buy the coffee from yesterday?\n 여기서 from은 Who와 관계가 있지만, 우리가 여태까지 살펴본 PCFG와 Malt Parser로 \n 이 관계를 밝히는데에는 한계가 있다.\n 따라서, 이를 해결하기 위해서 후처리나 추가적인 action을 Malt Parser에 더하거나 \n 아니면 아예 다른 방식을 앙상블하여 해결하기도 한다.\n```\n\n## Semantics\n\n자세히 여기서 다루지 않지만, 구문 분석을 통해 얻은 Tree를 통해서 어떻게 의미를 추출할 수 있는지를 알아보겠다. 먼저, 우리는 전체 요소를 다시 한 번 두 가지로 나눈다.\n\n1. Entities  \n   특정 의미를 가지는 하나의 주체이다. 주로 NP가 모두 여기에 속한다.\n2. Functions  \n   Entity 또는 다른 Function에게 동작, 특성, 등을 적용한다. 형용사, 동사 등이 여기에 속한다.\n\n따라서, 우리가 `Every nation wants George to love Laura.`라는 문장을 갖고 있다면, 우리는 아래와 같이 Tree를 그릴 수 있고, 이를 이용해서 의미 분석이 가능하다.\n\n![nlp-semantic](/images/nlp-semantic.jpg)\n\n위 Tree를 아래에서부터 연결해서 나가면 다음과 같이 구조화되는 것을 알 수 있다.\n\n| Index | Expression                                                |\n| :---- | :-------------------------------------------------------- |\n| 1     | love(x, Laura)                                            |\n| 2     | love(x, Laura)                                            |\n| 3     | love(George, Laura)                                       |\n| 4     | want(x, love(George, Laura))                              |\n| 5     | present(want(x, love(George, Laura)))                     |\n| 6     | Every(nation)                                             |\n| 7     | present(want(Every(nation), love(George, Laura)))         |\n| 8     | assert(present(want(Every(nation), love(George, Laura)))) |\n\n## Reference\n\n- Tumbnail : Photo by [David Ballew](https://unsplash.com/@daveballew?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/@daveballew?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n- Penn Treebank POS tagging, \u003chttps://www.ling.upenn.edu/courses/Fall_2003/ling001/penn_treebank_pos.html\u003e\n- spaCy, \u003chttps://spacy.io/\u003e\n- NLTK, \u003chttps://www.nltk.org/\u003e\n- KoNLPy, \u003chttps://konlpy.org/ko/latest/index.html\u003e\n- NLP CFG, \u003chttps://tildesites.bowdoin.edu/~allen/nlp/nlp1.html\u003e\n","slug":"nlp-language-parsing","date":"2022-11-07 15:05","title":"[NLP] 8. Language Parsing","category":"AI","tags":["NLP","POS","PCFG","Morphology","Syntax","Semantics"],"desc":"우리가 NL을 제대로 분석하기 위해서 각 단어가 가진 의미를 알아야하며, 이를 넘어서 문장이 가지는 의미를 파악해야 한다. 결론적으로 이 과정이 고도화된 NLP를 위한 핵심 단계이다. 이를 위해서는 Raw한 형태로 주어진 text를 처리해서 더 나은 형태의 구조를 만들 필요가 있다. 따지고 보면 하나의 전처리 과정이라고 볼 수 있다. 그치만 이전 text processing chapter과 다른 점은 문장 구분과 같은 간단한 과정이 아닌 Linguistic 단계에 따른 처리 과정을 수행한다고 볼 수 있다. 또한, 각 단계 역시 NLP 중에 하나라고 할 수 있으므로 이 또한 ML과 DL을 통해서 고도화하는 것도 가능하다. Morphology 단계부터 시작하여 Syntax, Semantic까지 어떻게 다루게 되는지를 살펴보도록 하겠다.","thumbnailSrc":"https://euidong.github.io/images/nlp-thumbnail.jpg"}],"params":{"subject":"PCFG"}},"__N_SSG":true},"page":"/tags/[subject]","query":{"subject":"PCFG"},"buildId":"OvWLoXKcdteK-xIHNhJEy","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>