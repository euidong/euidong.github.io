<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="description" content="Just Tech Blog"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta property="og:type" content="blog"/><meta property="og:site_name" content="JustLog"/><title>JustLog</title><link rel="canonical" href="https://euidong.github.io"/><meta property="og:title" content="JustLog"/><meta property="og:description" content="Just Tech Blog"/><meta property="og:url" content="https://euidong.github.io"/><meta property="og:image" content="https://euidong.github.io/logo192.png"/><meta name="next-head-count" content="11"/><link rel="icon" href="https://euidong.github.io/favicon.png"/><link rel="apple-touch-icon" href="https://euidong.github.io/logo192.png"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7452732177557701" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/ef7c1611da8b69bb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ef7c1611da8b69bb.css" data-n-g=""/><link rel="preload" href="/_next/static/css/f89b60421b997868.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f89b60421b997868.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-81da43a8dcd978d9.js" defer=""></script><script src="/_next/static/chunks/main-7b6c38cbad60dfcf.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2fcbb58b06805e67.js" defer=""></script><script src="/_next/static/chunks/260-70537706ba3e961b.js" defer=""></script><script src="/_next/static/chunks/pages/index-fe5276623109be05.js" defer=""></script><script src="/_next/static/SZR6hfY4iOgLPmapXPdc9/_buildManifest.js" defer=""></script><script src="/_next/static/SZR6hfY4iOgLPmapXPdc9/_ssgManifest.js" defer=""></script><script src="/_next/static/SZR6hfY4iOgLPmapXPdc9/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_wrapper__dKJSz root"><header class="Layout_header__XosLl" style="position:sticky"><div><button tabindex="1" class="SideBarToggler_search_bar_toggler__CEuUg"><svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 24 24" height="35px" width="35px" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor"></path><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor"></path><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor"></path></svg></button><nav class="SideBar_side_bar__wrapper--close__8Nwnr"><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/">Home</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/tags">Tags</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Algorithm">Algorithm<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->11<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Computer%20Architecture">Computer Architecture<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->7<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Docker">Docker<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->1<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Web">Web<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->3<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Network">Network<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->5<!-- -->)<!-- --></span></a></nav></div><a class="Logo_logo___yD0t" tabindex="1" href="/"></a><div><button class="SearchBarToggler_search_bar_toggler__3dHbA" tabindex="2"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="25px" width="25px" xmlns="http://www.w3.org/2000/svg"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"></path></svg></button></div></header><section><div class="Home_home__wrapper__6H7iH"><div class="ColumnCard_column_card__list__background__kZObh"><h2 class="ColumnCard_column_card__list__title__pawoL">Recent Post</h2><div class="ColumnCard_column_card__list__wrapper__lsbEP"><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/making-blog"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/blog.png?imwidth=384 1x, https://euidong.github.io/images/blog.png?imwidth=640 2x" src="https://euidong.github.io/images/blog.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/making-blog">블로그 제작기</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/frontend"># <!-- -->frontend<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/react"># <!-- -->react<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/gatsby"># <!-- -->gatsby<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/nextjs"># <!-- -->nextjs<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/github"># <!-- -->github<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/architecture-parallel-processors"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/default.jpg?imwidth=384 1x, https://euidong.github.io/images/default.jpg?imwidth=640 2x" src="https://euidong.github.io/images/default.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/architecture-parallel-processors">6. Parallel Processors</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Computer%20Organization%20And%20Design"># <!-- -->Computer Organization And Design<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Multi%20Processors"># <!-- -->Multi Processors<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Multi%20Threading"># <!-- -->Multi Threading<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/MTU"># <!-- -->MTU<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/binary-search"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=384 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/binary-search">Binary Search</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Binary%20Search"># <!-- -->Binary Search<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Upper%20Bound"># <!-- -->Upper Bound<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Lower%20Bound"># <!-- -->Lower Bound<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EC%A4%91%EB%B3%B5%20%EC%88%98%EC%9D%98%20%EA%B0%AF%EC%88%98"># <!-- -->중복 수의 갯수<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/openflow"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/switch-with-cable.jpg?imwidth=384 1x, https://euidong.github.io/images/switch-with-cable.jpg?imwidth=640 2x" src="https://euidong.github.io/images/switch-with-cable.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/openflow">OpenFlow</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/SDN"># <!-- -->SDN<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/ONF"># <!-- -->ONF<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/sdn"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/network-background.jpg?imwidth=384 1x, https://euidong.github.io/images/network-background.jpg?imwidth=640 2x" src="https://euidong.github.io/images/network-background.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/sdn">SDN</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/SDN"># <!-- -->SDN<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/NFV"># <!-- -->NFV<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/mininet"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/switch-with-cable.jpg?imwidth=384 1x, https://euidong.github.io/images/switch-with-cable.jpg?imwidth=640 2x" src="https://euidong.github.io/images/switch-with-cable.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/mininet">Mininet</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Emulator"># <!-- -->Emulator<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Tool"># <!-- -->Tool<!-- --></a></ul></div></div></div></div><div class="ColumnCard_column_card__list__background__kZObh"><h2 class="ColumnCard_column_card__list__title__pawoL">Algorithm</h2><div class="ColumnCard_column_card__list__wrapper__lsbEP"><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/binary-search"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=384 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/binary-search">Binary Search</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Binary%20Search"># <!-- -->Binary Search<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Upper%20Bound"># <!-- -->Upper Bound<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Lower%20Bound"># <!-- -->Lower Bound<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EC%A4%91%EB%B3%B5%20%EC%88%98%EC%9D%98%20%EA%B0%AF%EC%88%98"># <!-- -->중복 수의 갯수<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/brute-force"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=384 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/brute-force">Brute Force</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/BruteForce"># <!-- -->BruteForce<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EC%88%9C%EC%97%B4"># <!-- -->순열<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EC%A1%B0%ED%95%A9"># <!-- -->조합<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EB%B6%80%EB%B6%84%20%EC%A7%91%ED%95%A9"># <!-- -->부분 집합<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/dfs1"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=384 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/dfs1">DFS(1)-기본</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/DFS"># <!-- -->DFS<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Graph"># <!-- -->Graph<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Tree"># <!-- -->Tree<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/dfs2"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=384 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/dfs2">DFS(2)-DFS Spanning Tree</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/DFS"># <!-- -->DFS<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Graph"># <!-- -->Graph<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Tree"># <!-- -->Tree<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Cycle%20%EC%B0%BE%EA%B8%B0"># <!-- -->Cycle 찾기<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/dynamic-programming"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=384 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/dynamic-programming">Dynamic Programming</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Dynamic%20Programming"># <!-- -->Dynamic Programming<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/BOJ2133"># <!-- -->BOJ2133<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/BOJ11726"># <!-- -->BOJ11726<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/BOJ14002"># <!-- -->BOJ14002<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/BOJ1912"># <!-- -->BOJ1912<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Memoization"># <!-- -->Memoization<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Optimal%20Structural"># <!-- -->Optimal Structural<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Overlapping%20Subproblem"># <!-- -->Overlapping Subproblem<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Referential%20Transparency"># <!-- -->Referential Transparency<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/graph"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=384 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/graph">Graph</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0"># <!-- -->자료구조<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Graph"># <!-- -->Graph<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/list"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=384 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/list">List 갖고 놀기</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/List"># <!-- -->List<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Python"># <!-- -->Python<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EC%88%9C%ED%99%98"># <!-- -->순환<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EB%B3%B5%EC%82%AC"># <!-- -->복사<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EC%9E%90%EB%A5%B4%EA%B8%B0"># <!-- -->자르기<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EB%B0%98%EC%A0%84"># <!-- -->반전<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%ED%9A%8C%EC%A0%84"># <!-- -->회전<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/tree"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=384 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/tree">Tree</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0"># <!-- -->자료구조<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Graph"># <!-- -->Graph<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/modulo"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=384 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/modulo">modulo</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Modulo"># <!-- -->Modulo<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EB%82%98%EB%A8%B8%EC%A7%80"># <!-- -->나머지<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/accumerated-number"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=384 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/accumerated-number">누적합</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0"># <!-- -->자료구조<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Segment%20Tree"># <!-- -->Segment Tree<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Fenwick%20Tree"># <!-- -->Fenwick Tree<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/find-prime"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/algorithm.png?imwidth=384 1x, https://euidong.github.io/images/algorithm.png?imwidth=640 2x" src="https://euidong.github.io/images/algorithm.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/find-prime">소수찾기</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EC%86%8C%EC%88%98%EC%B0%BE%EA%B8%B0"># <!-- -->소수찾기<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98%20%EC%B2%B4"># <!-- -->에라토스테네스의 체<!-- --></a></ul></div></div></div></div><div class="ColumnCard_column_card__list__background__kZObh"><h2 class="ColumnCard_column_card__list__title__pawoL">Computer Architecture</h2><div class="ColumnCard_column_card__list__wrapper__lsbEP"><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/digital-logic-circuit"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/default.jpg?imwidth=384 1x, https://euidong.github.io/images/default.jpg?imwidth=640 2x" src="https://euidong.github.io/images/default.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/digital-logic-circuit">0. 논리회로 요약</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EB%85%BC%EB%A6%AC%ED%9A%8C%EB%A1%9C"># <!-- -->논리회로<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/architecture-base"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/default.jpg?imwidth=384 1x, https://euidong.github.io/images/default.jpg?imwidth=640 2x" src="https://euidong.github.io/images/default.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/architecture-base">1. Base</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Computer%20Organization%20And%20Design"># <!-- -->Computer Organization And Design<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/ISA"># <!-- -->ISA<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/architecture-instruction"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/default.jpg?imwidth=384 1x, https://euidong.github.io/images/default.jpg?imwidth=640 2x" src="https://euidong.github.io/images/default.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/architecture-instruction">2. Instruction</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Computer%20Organization%20And%20Design"># <!-- -->Computer Organization And Design<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Instruction"># <!-- -->Instruction<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/ISA"># <!-- -->ISA<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/architecture-arithmetic"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/default.jpg?imwidth=384 1x, https://euidong.github.io/images/default.jpg?imwidth=640 2x" src="https://euidong.github.io/images/default.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/architecture-arithmetic">3. Arithmetic</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Computer%20Organization%20And%20Design"># <!-- -->Computer Organization And Design<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Arithmetic"># <!-- -->Arithmetic<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/architecture-processor"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/default.jpg?imwidth=384 1x, https://euidong.github.io/images/default.jpg?imwidth=640 2x" src="https://euidong.github.io/images/default.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/architecture-processor">4. Processing</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Computer%20Organization%20And%20Design"># <!-- -->Computer Organization And Design<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Processing"># <!-- -->Processing<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/MIPS%20Implementation"># <!-- -->MIPS Implementation<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Pipeline"># <!-- -->Pipeline<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Branch%20Prediction"># <!-- -->Branch Prediction<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/SuperScalar"># <!-- -->SuperScalar<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/architecture-memory"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/default.jpg?imwidth=384 1x, https://euidong.github.io/images/default.jpg?imwidth=640 2x" src="https://euidong.github.io/images/default.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/architecture-memory">5. Memory Hierarchy</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Computer%20Organization%20And%20Design"># <!-- -->Computer Organization And Design<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Memory"># <!-- -->Memory<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Memory%20Hierarchy"># <!-- -->Memory Hierarchy<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Cache"># <!-- -->Cache<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Directed%20Mapping"># <!-- -->Directed Mapping<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Virtual%20Memory"># <!-- -->Virtual Memory<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Page"># <!-- -->Page<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/architecture-parallel-processors"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/default.jpg?imwidth=384 1x, https://euidong.github.io/images/default.jpg?imwidth=640 2x" src="https://euidong.github.io/images/default.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/architecture-parallel-processors">6. Parallel Processors</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Computer%20Organization%20And%20Design"># <!-- -->Computer Organization And Design<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Multi%20Processors"># <!-- -->Multi Processors<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Multi%20Threading"># <!-- -->Multi Threading<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/MTU"># <!-- -->MTU<!-- --></a></ul></div></div></div></div><div class="ColumnCard_column_card__list__background__kZObh"><h2 class="ColumnCard_column_card__list__title__pawoL">Docker</h2><div class="ColumnCard_column_card__list__wrapper__lsbEP"><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/docker-mysql"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/hero.png?imwidth=384 1x, https://euidong.github.io/images/hero.png?imwidth=640 2x" src="https://euidong.github.io/images/hero.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/docker-mysql">Docker Mysql</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/virtualEnv"># <!-- -->virtualEnv<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/mysql"># <!-- -->mysql<!-- --></a></ul></div></div></div></div><div class="ColumnCard_column_card__list__background__kZObh"><h2 class="ColumnCard_column_card__list__title__pawoL">Web</h2><div class="ColumnCard_column_card__list__wrapper__lsbEP"><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/gatsby"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/gatsby.png?imwidth=384 1x, https://euidong.github.io/images/gatsby.png?imwidth=640 2x" src="https://euidong.github.io/images/gatsby.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/gatsby">Gatsby</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Gatsby"># <!-- -->Gatsby<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/MDX"># <!-- -->MDX<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Blog"># <!-- -->Blog<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/seo"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/web.jpg?imwidth=384 1x, https://euidong.github.io/images/web.jpg?imwidth=640 2x" src="https://euidong.github.io/images/web.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/seo">SEO</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/SEO"># <!-- -->SEO<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/GoogleSearchEngine"># <!-- -->GoogleSearchEngine<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EA%B2%80%EC%83%89%EC%96%B4%20%EB%85%B8%EC%B6%9C"># <!-- -->검색어 노출<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/%EA%B5%AC%EA%B8%80%20%EA%B2%80%EC%83%89%EC%96%B4%20%EB%85%B8%EC%B6%9C"># <!-- -->구글 검색어 노출<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/making-blog"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/blog.png?imwidth=384 1x, https://euidong.github.io/images/blog.png?imwidth=640 2x" src="https://euidong.github.io/images/blog.png?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/making-blog">블로그 제작기</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/frontend"># <!-- -->frontend<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/react"># <!-- -->react<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/gatsby"># <!-- -->gatsby<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/nextjs"># <!-- -->nextjs<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/github"># <!-- -->github<!-- --></a></ul></div></div></div></div><div class="ColumnCard_column_card__list__background__kZObh"><h2 class="ColumnCard_column_card__list__title__pawoL">Network</h2><div class="ColumnCard_column_card__list__wrapper__lsbEP"><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/mpls"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/routing.jpg?imwidth=384 1x, https://euidong.github.io/images/routing.jpg?imwidth=640 2x" src="https://euidong.github.io/images/routing.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/mpls">MPLS</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Routing"># <!-- -->Routing<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/mininet"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/switch-with-cable.jpg?imwidth=384 1x, https://euidong.github.io/images/switch-with-cable.jpg?imwidth=640 2x" src="https://euidong.github.io/images/switch-with-cable.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/mininet">Mininet</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Emulator"># <!-- -->Emulator<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Tool"># <!-- -->Tool<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/openflow"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/switch-with-cable.jpg?imwidth=384 1x, https://euidong.github.io/images/switch-with-cable.jpg?imwidth=640 2x" src="https://euidong.github.io/images/switch-with-cable.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/openflow">OpenFlow</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/SDN"># <!-- -->SDN<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/ONF"># <!-- -->ONF<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/sdn"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/network-background.jpg?imwidth=384 1x, https://euidong.github.io/images/network-background.jpg?imwidth=640 2x" src="https://euidong.github.io/images/network-background.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/sdn">SDN</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/SDN"># <!-- -->SDN<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/NFV"># <!-- -->NFV<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/segment-routing"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/forwarding.jpg?imwidth=384 1x, https://euidong.github.io/images/forwarding.jpg?imwidth=640 2x" src="https://euidong.github.io/images/forwarding.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/segment-routing">Segment Routing</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Routing"># <!-- -->Routing<!-- --></a></ul></div></div></div></div></div></section><footer class="Layout_footer__EL5v8"><div class="Layout_footer__copyright__r5baC"><span>Copyright © euidong</span><br/><span>모든 컨텐츠에 대한 저작권은 작성자에게 존재합니다. <!-- --><br/>불법 복제를 통한 상업적 사용을 절대적으로 금지합니다. <!-- --><br/>단, 비상업적 이용의 경우 출처 및 링크를 적용한다면 자유롭게 사용가능 합니다.<!-- --></span><span>Also I use photos by<!-- --> <!-- --><a href="https://unsplash.com/@lorenzoherrera?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Lorenzo Herrera</a> <!-- -->on<!-- --> <!-- --><a href="https://unsplash.com/s/photos/tech?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Unsplash</a></span></div><div class="Layout_footer__contents__YZWSm"><a class="Layout_footer__contents__link__K_TKH" href="https://github.com/euidong" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>github</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://euidong.github.io/portfolio" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M6 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-5 6s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H1zM11 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5zm.5 2.5a.5.5 0 0 0 0 1h4a.5.5 0 0 0 0-1h-4zm2 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2zm0 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2z"></path></svg><span>portfolio</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://chrome.google.com/webstore/detail/bonfire/nkooidijgbppkojdgkoafcoppnohdfka?hl=ko" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M5.016 16c-1.066-2.219-0.498-3.49 0.321-4.688 0.897-1.312 1.129-2.61 1.129-2.61s0.706 0.917 0.423 2.352c1.246-1.387 1.482-3.598 1.293-4.445 2.817 1.969 4.021 6.232 2.399 9.392 8.631-4.883 2.147-12.19 1.018-13.013 0.376 0.823 0.448 2.216-0.313 2.893-1.287-4.879-4.468-5.879-4.468-5.879 0.376 2.516-1.364 5.268-3.042 7.324-0.059-1.003-0.122-1.696-0.649-2.656-0.118 1.823-1.511 3.309-1.889 5.135-0.511 2.473 0.383 4.284 3.777 6.197z"></path></svg><span>chat</span></a></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"recentPosts":[{"content":"\n해당 포스팅은 블로그를 직접 만드는 과정에서 겪은 시행착오를 정리한 내용이다.\n\n나의 블로그 포스팅을 향한 일대기는 2019년도에서 부터 시작된다.\n\n## JSP / Servlet\n\n2019년도에 군대를 막 전역하고, 학점을 잘 챙기면서 여러가지 행사에 참여했다. 그 과정에서 기술 블로그를 제작하겠다는 꿈을 꾸고 작업에 착수한다.\n그 당시에는 JSP와 Servlet을 이용한 방법을 통해서 Posting하는 것을 시도했다.\n\ngithub : [euidong/blog](https://github.com/euidong/blog)\n\n해당 방식은 markdown file을 그대로 가져와서 rendering하여 만들었다. 하지만, jar file을 실행해야 한다. 따라서, JAVA Virtual Machine이 필요하기에 결론적으로 이를 호스팅할 machine이 필요하다. 따라서, AWS free tier를 이용해서 배포했지만, 다소 배포 관리가 귀찮고, 당시에는 frontend \u0026 backend 등 아직 개념이 제대로 스지 않았기 대문에 중간에 포스팅을 조기 종료했다.\n\n결국 JSP + Servlet을 이용한 시도는 종료된다.\n\n## Gatsby\n\n후에 2021년도 1월에 다시 새롭게 블로그를 쓰겠다는 포부를 갖고, 블로그 작성 방법을 찾는다. 당시에는 React를 이용해서 다수의 Application을 제작해본 경험이 있었기 때문에 이를 이용한 Blog를 만들려고 했다. 자세히 기억은 안나는데 Gatsby Showcase에 있는 source code를 이용해서 Blog를 제작했다. 하지만, Gatsby에 대해 아는게 없고, 시간을 쓸 여유가 없어서 결국에는 중도에 멈춘다. 추가적으로 Github action으로 CI/CD 구현을 수행하는 작업까지도 진행하였다. 하지만 결국 제대로 진행된 것 없이 종료되었다.\n\ngithub : [euidong/euidong.github.io/dev@deprecated](https://github.com/euidong/euidong.github.io/tree/dev%40deprecated)\n\n## Tistory\n\n2021년도 3월에 결국 직접 제작을 하는 것을 포기하고, Tistory를 이용해서 블로그에 포스팅을 시작한다. 해당 시기부터 시작해서 몇 개의 포스팅을 작성하였다. 대략 35개 정도의 포스팅을 작성했고, 최근에 이르러서 작성의 한계를 느끼며 갈아타야겠다고 생각했다.\n\n다음은 직접 커스텀을 해야겠다고 생각했던 이유이다.\n1. 호환성이 떨어진다. =\u003e Markdown으로 변환도 가능하지만, Github와 완벽한 호환이 안된다.\n2. 가끔 모바일에서 문자가 깨진다. =\u003e 아마 MAC으로 작성하는 경우 문자가 깨지는 것 같다. 근데, 이를 매번 모바일로 켜서 확인하기에는 너무 번거롭다.\n3. 커스텀을 할 때 다른 Library를 맘대로 가져와서 쓸 수 있지만, pure js, jquery 기반으로만 가능하고, 유지보수가 쉽지 않다.\n4. 가끔 작성 결과가 너무 예측 불가능하다. \n5. tag 관리가 불편하다.\n6. 기본 UI가 안이쁘다.\n\n몇 가지 이유가 더 있었던 거 같은데, 아마 이정도가 문제였던 거 같다. 암튼 내가 관리하지 못하는 것으로 인한 스트레스가 있었기 때문에 이를 해결하기 위해서 완전 커스텀을 다시 결정하였다.\n\ntistory: [justlog](https://justlog.tistory.com)\n\n## 완전 커스텀\n\n### 생 React\n\n처음에는 생 React를 통해서 Blog를 만들어야겠다고 생각했다. 가장 일반적으로 할 수 있는 작업이고, 다른 static page generating 기능을 수행하는 react framework를 다시 공부하는 workload를 지고 싶지 않았고, 굳이 필요하지 않은 의존성을 만들고 싶지 않아서 결국 생 React로 바로 작업을 시작한다. \n\n당시에는 Tistory에서 한계를 느꼈던 부분을 고치면서, Tistory에서 갖고 싶었던 장점을 가져가고자 했다.\n1. 호환성이 떨어지던 점은 Markdown을 이용해서 작성하고, Github viewer style(GFM, Github Flavor Markdown)을 사용하기로 한다. 따라서, 해당 블로그의 모든 글을 Github에 올려도 이미지 경로 빼고는 매우 잘 작동할 것이다. (이는 후에 이미지 호스팅 CDN을 따로 설정하면 해결됨.)\n2. Tistory에서 장점이라고 생각했던, Category로 작성글을 묶고, Tag들로 다시 한 번 더 분류한다.\n3. Posting을 보기 쉽게 정리되어있어야 한다.\n4. Dark Mode를 지원해야 한다.\n5. 조회수 관리를 위해서 Google Analytics 설정을 해야한다.\n6. 구글 / 네이버 검색에 노출되어야 한다.\n7. 광고를 게시할 수 있어야 한다.\n8. Github에 Push하는 것만으로 Posting이 게시될 수 있어야 한다. (Github Action)\n9. Category와 Tag들은 Markdown안에 작성하지만, 이를 조회할 수 있어야 한다. 따라서, code를 build할 때 json으로 generating 할 수 있는 로직을 설계한다.\n10. UI는 최대한 Simple 하고 깔끔하게 만드는 것을 목표로 하였다.\n\n따라서, 모든 Button 부터 모든 UI를 직접 제작(여타 디자인 사용 x - material, ant 등)하고, Routing 설정하고, 작업을 모두 마무리한다.\n\n여기까지는 모든 작업이 순조롭게 진행되고, 마무리가 되었다. 하지만, SEO(검색 엔진 최적화) 작업을 진행하면서, 결국 static page가 필요함을 깨닫는다. 왜냐하면, 기존의 React Router를 사용하게 되면, https://euidong.github.io/posts/dfs1 를 찾을 수가 없다. 왜냐하면, github에서는 page를 직접 접근할 때에는 배포 branch에서 해당 파일을 찾게 되는데 해당 파일이 없으면 결국 404 Not Found를 노출하게 된다. 이를 해결하기 위해서, dummy redirect로 root로 돌려보내줄 수도 있지만, 결코 좋은 방법은 아니다. 검색엔진 최적화에도 좋지 못하다. 따라서, static file을 각 각의 url마다 생성해주는 Static Page Generating이 필요하다고 느낀다. 따라서, Gatsby와 NextJS 중에서 선택을 하기로 한다.\n\n이제 추가된 요구사항은 다음과 같다.\n\n1. 기존 코드를 그대로 활용할 수 있어야 한다. \n2. Static Page Generating을 지원해야 한다.\n\ngithub : [euidong/euidong.github.io/dev@pure-react](https://github.com/euidong/euidong.github.io/tree/dev%40pure-react)\n\n### Gatsby\n\n다시 돌아와 Gatsby를 시도하기로 한다. 애초에 GraphQL과 React 모두 경험이 있기 때문에 쉽게 할 수 있을 거라고 생각했다. 하지만, 생각보다 GraphQL Query의 제한점이 많아서 결국 Gatsby는 포기하기로 한다. 물론 Gatsby의 확장 도구들은 유용했지만 위에서 제시한 9번을 구현하기에 한계를 느꼈다. (내 딴에는 GraphQL로 만들고 싶었는데 사실 포기하고 JSON으로 만들었으면 가능했을 듯하다.) \n\n### NextJS\n\n그래서 다음으로 시도한 것이 NextJS이다. NextJS는 생성 시에 내부 API를 정의하여 이를 기반으로 미리 compile을 완료한 html 파일들을 생성해두고, 제공하면서도, 그 내부에서는 SPA 처럼 동작할 수 있도록 돕는 방식이다. React를 이용한 Framework인 만큼 기존의 code를 그대로 사용할 수 있어서 쉽게 사용이 가능했다. 하지만, Gatsby와 마찬가지로 어느정도의 한계는 존재했기 때문에 결국은 react만 생성하던 방식처럼 JSON file을 generating하여 category와 tag들을 수집하였다.\n\n그 결과 지금과 같은 형태의 블로그를 완성하였다. 현재 포스팅을 계속해서 진행할 예정이며, 광고 및 여타 설정들도 추가로 진행할 예정이다.\n\n![blog-view](/images/blog.png)\n\ngithub : [euidong/euidong.github.io/dev](https://github.com/euidong/euidong.github.io/tree/dev)\n\n최종으로 만들어진 Blog는 다음과 같은 요구사항을 만족한다.\n\n- [x] Markdown을 통해서 작성이 가능하고, 이는 DB 즉, BackEnd를 필요로 하지 않는다.\n- [x] Category로 작성글을 묶고, Tag들로 다시 한 번 더 분류하는 것이 가능하다.\n- [x] Dark Mode를 지원한다.\n- [x] 조회수 관리를 위해서 Google Analytics를 사용한다.\n- [x] 구글 / 네이버 검색에 노출되어있다.\n- [x] 광고를 게시하였다.\n- [x] Github에 Push하는 것만으로 Posting이 게시된다. (Github Action)\n- [x] Build 시에 SEO에 필요한 sitemap을 자동 생성한다.\n- [x] Theme는 Github의 color palette에 기반하여 설정하여, 친숙하다.\n- [x] 모바일을 지원한다.\n- [x] 이미지 크기를 재설정할 수 있는 command를 포함한다. \n","slug":"making-blog","title":"블로그 제작기","category":"Web","tags":["frontend","react","gatsby","nextjs","github"],"date":"2022년 5월 5일 21:54","thumbnailSrc":"https://euidong.github.io/images/blog.png"},{"content":"\n## **Reference**\n\n![\u003cimg src=\"/images/default.jpg\" width=\"190\" /\u003e](/images/default.jpg)\n\nDavid A. Patterson, John L. Hennessy, Computer Organization and Design\n\n본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 \"-다\"로 표현합니다.\n\n---\n\n우리가 원하는 것은 강한 performance를 발휘하면서도, 가용성(availability, 끊김 없이 사용할 수 있는 능력의 정도)가 높은 computer를 만드는 것이다. 이를 위해서, 우리는 단순히 하나의 processor를 정교하게 만들기보다는 동등한 기능을 하는 여러 개의 processor를 연결하여 사용하는 것이 더 효율적이라는 것이라는 것을 알아냈다. (이를 software가 잘 활용할 수만 있다면, 성능이 크게 향상될 것이다.)\n\n- 하나의 장치를 동작시키는 방식보다 적은 에너지로 같은 작업을 수행할 수 있다. (동시에 실행시키기 때문에 더 짧은 시간 사용할 수 있다.)\n- n개의 processor에서 하나가 실패하여도 n-1개는 정상 작동하기 때문에 전체 시스템은 문제 없이 동작한다. (Redundant, 추가자원을 통해서 가용성을 향상시킴)\n\n이에 따라 우리는 multi-processor를 사용한다. \n이는 multi-processor가 어떻게 존재하느냐에 따라서 다음과 같은 형태로 나눈다.\n\n1. **Multicore Microprocessor** : 하나의 IC(집적 회로) 칩에 여러 개의 processor(core)가 존재한다.\n2. **Multiple Processor** : IC칩의 갯수를 늘린다.\n3. **Cluster System** : Machine(Computer) 자체의 갯수를 늘린다.\n\n따라서, 개인 PC에서는 Multiple Multicore Microprocessor를 지원하고, 있는 상황이고, Datacenter와 같은 환경에서는 이러한 Machine들이 여러 개 존재하는 Cluster System이라고 생각하면 되겠다.\n\n또한, 이용하는 방식에 따라 크게 두 가지로 나눌 수 있다. \n\n1. Task Level Parallelism(=Process Level Parallelism) : 동시에 독립된 여러 program을 실행시키는 방식\n2. Parallel Processing Program : 동시에 여러 개의 processor를 이용하여 하나의 program을 실행시키는 방식\n\n## Parallel Processing Program의 구현\n\n하나의 작업을 더 빠르게 처리하기 위하여 multiple processor를 사용하는 software를 작성하는 것은 어렵다. 이는 processor의 수가 늘어날 수록 심해진다. multiprocessor program을 이용할 경우에, 수가 늘어날 수록 우리는 다음과 같은 작업에 대한 부담을 가질 수 밖에 없다.\n\n1. **Scheduling** : process 또는 thread를 scheduling하여 어떤 것을 먼저 실행시킬지에 대한 scheduling 역시 큰 부담이다.\n2. **Partitioning** : Memory의 구간을 각 processor에게 어떻게 나누고 서로 독립되게 존재하기 위한 관리를 수행하는 것 역시 큰 부담이 된다.\n3. **Balancing the Load** : 작업을 각 processor에게 균등히 분배하는 것 역시 어렵다.\n4. **Time to Synchronize** : 여러 개가 동시에 하나의 process를 실행시키면, 읽고 쓰기에서 충돌이 발생하는 것에 의한 문제가 발생하고 이를 해결하기 위해서 시간을 사용할 수 밖에 없다.\n5. **Overhead for Communication** : 각 processor간의 의사소통에 너무 큰 비용이 발생하는 경우 오히려 하나의 processor가 실행시키는 것보다 더 많은 시간을 요구할 수도 있다.\n\n이 모든 것을 software에서 제대로 관리할 수 있을 때, 그제서야 우리는 multi processor 시스템을 제대로 활용할 수 있는 것이다.\n\n우리가 processor의 갯수를 늘림으로써 얻을 수 있는 혜택은 각 processor에 전달되는 작업의 수를 균등하게 나누어, 기존에 하나의 processor가 할 수 없던 일을 처리(weak scaling)하거나, 기존의 문제를 더 빠르게 처리(strong scaling)할 수 있다.\n\n## Data Stream, Instruction Stream\n\nprocessor들로 들어오는 data의 양을 의미하는 **Data Stream**과 instruction의 양을 의미하는 **Instruction Stream**에 따라서, 우리는 각 processor들을 다양한 이름으로 부른다.\n\n1. **SISD**(Single Instruction Stream, Single Data Stream) : 대게 single processor일 경우 이와 같은 형태를 채택한다.\n2. **MIMD**(Multiple Instrunction Stream, Multiple Data Stream) : Multiple Processor System에서는 당연히 이와 같은 시스템을 채택한다.\n3. **MISD**(Multiple Instrunction Stream, Single Data Stream) : 잘 사용하지 않는 형태이다. 대게는 Data의 처리가 더 많이 발생하기 때문이다.\n4. **SIMD**(Single Instruction Stream, Multiple Data Stream) : 하나의 Instruction을 이용하여 복합적인 여러 개의 데이터를 한 번에 처리하는 vector 연산 등을 빠르게 처리할 수 있다.   \n   1. vector 연산 하나가 for loop 하나를 의미할 수 있다. 이는 processor part의 각 pipeline 단계에서 fetch와 decode에 의한 비용을 크게 감소시킬 수 있다.\n   2. 하나의 vector 연산은 내부에서 각각이 독립적으로 수행되기 때문에, data hazard를 check하는 비용이 발생하지 않는다. 👉 따라서, vector의 각 요소를 모두 검사하는 것이 아닌 vector 외부 간의 data hazard 유무만 확인하면 된다.\n   3. Main Memory에서 데이터를 불러올 경우에도 각 요소를 불러오는 것이 아닌 한 번에 가져올 수 있기 때문에 매우 빠르다.\n   4. Loop를 표현이 vector 연산으로 대체되기 때문에, Loop Branch가 줄어든다.   \n\n## Hardware Multithreading\n\nprogrammer의 입장에서 MIMD는 hardware multithreading처럼 동작한다고 생각하게 한다. 이는 processor의 사용성을 최대화하기 위해서, 특정 thread가 stall 되었을 때, 다른 thread를 수행하도록 하는 방식이다. 즉, 하나의 processor에서 여러 개의 thread를 실행시킨다는 것이다. 그러기 위해 사실상 여러 processor가 존재하는 multiprocessor 환경에서 서로간 실행 환경을 서로 공유해야 한다. 이를 실현하려면, 각 thread의 독립된 상태를 복사할 수 있어야 한다. 즉, 각 각의 register file과 PC가 존재해야 한다. 이들 간의 Memory 공유 같은 경우는 이전에 보았던 Virtual Memory 정보를 공유하여 수행하게 된다. 그리고 무엇보다 중요한 것은 이 실행하는 thread를 바꾸는 시간적 비용이 작아야 한다. 이를 위해서, process가 아닌 thread를 바꾸는 것이다. process를 바꾸는 것보다는 비용이 훨씬 적기 때문이다. \n\nthread를 변경 시에 어떤 방법을 택할 것인가 역시 중요한데, 아래와 같은 방법론이 존재한다.\n\n\u003e **1. Fine Grained Multithreading**\n\nthread의 명령어를 round robine 방식을 이용하여 매번 바꾸면서 실행시키는 방식이다. 변경한 thread 역시 stall이 된 thread라면, 건너뛰고 다음 thread를 실행시킨다.\n\n- 장점 : stall 기간이 짧던 길던 이로 인한 손실을 감추고, 그 동안 다른 thread를 실행시킬 수 있다.\n- 단점 : 실행 준비가 된 상태(stall이 아닌 상태)에서도 다음 차례가 올 때까지 반드시 기다려야 하기 때문에 하나의 thread에 대한 처리 속도가 dramatic하게 줄어든다.\n\n\u003e **2. Coarse Grained Multithreading**\n\n하나의 thread에 대한 Instruction만 처리하다가 stall이 발생했을 때에만 thread를 변경하도록 하는 방식이다.\n\n- 장점 : 하나의 thread에 대한 처리 속도의 손실이 적고, switching을 빨리 하는 것에 대한 부담이 적다.\n- 단점 : 하나의 thread에 대한 Instruction만 처리하기 때문에, thread를 변경하는 것에 대한 비용이 크다. (long pipeline setup time) 따라서, 짧은 기간의 stall인 경우에는 해당 stall이 끝나길 기다린다.\n\n\u003e **3. Simultaneous Multithreading(SMT)**\n\nThread Level에서 Parallelism과 Instruction Level에서의 Parallelism을 동시에 수행하는 방식이다. Multiple Instruction 시스템에서는 더 많은 functional unit(register, pc, etc)이 있기 때문에 이를 Multi Threading에서도 적절히 사용할 수 있다는 접근법에서 나왔다. 여기서는 register renaming과 dynamic scheduling을 이용하여 multiple thread에서 여러 개의 Instruction을 빈틈없이 배치할 수 있다. 의존성은 dynamic scheduling이 해결하고, register renaming을 통해 필요에 따라 여분의 register를 불러와서 사용하는 것이 가능해졌다. 이를 통해서 위의 두 방식으로 할 수 없었던, multi processor를 최대한으로 사용하는 효과를 볼 수 있다.\n\n![multi-threading](/images/multi-threading.png)\n\n## GPU(Graphic Processing Unit)\n\ngame 산업 및 그래픽 분야의 큰 성장에 힘업어 graphic 처리에 대한 processor의 성능 향상이 필요했다. 즉, 기존 micro processor와 겉아 다용도로 사용되는 것이 아닌 graphic 연산만을 빠르게 처리할 수 있는 processor를 분리할 필요가 생긴 것이다. 이것만을 위해서 만들어진 것이 GPU이다.\n\nGPU는 앞 서 설명한 Multi Threading 기술을 적극 도입했기 때문에 Memory 접근에 따른 Latency가 성능에 큰 영향을 미치지 않는다. 그런 만큼 반대로 높은 Bandwidth를 가진 저장 장치를 필요로 한다.\n\n후에는 이 장치가 수행하는 vector 연산이 여러 용도로 사용됨에 따라 이를 위한 programming language들도 만들어졌다. 대표적인 것이 NVidia가 C를 통해서 만든 CUDA이다.","slug":"architecture-parallel-processors","title":"6. Parallel Processors","category":"Computer Architecture","tags":["Computer Organization And Design","Multi Processors","Multi Threading","MTU"],"date":"2022년 5월 2일 20:22","thumbnailSrc":"https://euidong.github.io/images/default.jpg"},{"content":"\nBinary Search는 가장 기본적이면서도 효과적인 탐색 방법이다. 이는 굉장히 많은 알고리즘의 기본 알고리즘으로 많이 사용된다. 따라서, Binary Search를 제대로 사용할 줄 알아야 한다. 또한, 뒤에 부분에서는 이를 이용해서 중복수를 찾아내는 연산을 어떻게 Binary Search를 통해서 할 수 있는지를 알아볼 것이다.\n\nBinary Search를 하기 위해서는 먼저 list를 정렬해야 한다. 그렇게 하게 되면, 특정 수를 찾기 위해서 최대 list 전체를 탐색하는 것에서 리스트의 크기를 log 취한 만큼 만 연산해도 충분하다.\n\n일반적인 예시가 Up\u0026Down 게임이다. 이는 특정 범위 안의 숫자를 맞히고자 할 때 기회를 여러 번주고, 시도할 때마다 시도한 값과 목표 값을 비교하여 목표값이 더 크면 Up, 더 작으면 Down을 알려주는 게임이다. 우리가 값을 맞추고자할 때마다 해당 값에 대한 힌트가 주어지게 되는데, 만약 우리가 매번 수의 중앙 값을 말한다면, 얻을 수 있는 정보의 질이 굉장히 높아진다. 물론 범위가 100이고 맞추고자 하는 값이 100일 때, 99라고 말하고 Up을 듣는다면 최상의 정보를 얻게 되는 것이지만, 만약 Down이라면, 받을 수 있는 정보의 질이 굉장히 떨어진다. 왜냐하면 내가 해당 수를 외침으로써 다음 시도에서 제외할 수 있는 수는 2개 밖에 없기 때문이다.\n\n결국 우리는 특정 수를 맞추지 못했을 경우, 고급 정보를 얻어 다음 도전을 할 수도 있고, 안좋은 정보를 얻어 다음 도전에 도움이 덜 될 수도 있다. 즉, 우리가 맞추어야 할 수가 하나라면, 위와 같은 요행에 기대어 도전하는 것도 나쁘지 않은 선택이라고 할 수 있다. 예를들어, 2의 배수 순으로 조회하는 것이다.\n\n하지만, 우리가 해당 게임을 여러 번 진행할 것이고, 범위가 넓어질 경우 질이 안좋은 정보를 얻었을 경우의 Risk가 너무 클 수 있다. 따라서, 우리는 어떤 숫자가 들어오더라도 **확정적으로 연산 횟수를 줄이기를 기대할 것**이다. 그 방법이 항상 범위의 중앙값을 선택하는 것이다. 그렇다면, 어떤 수가 목표이더라도 우리는 선택지를 매번 반으로 나눌 수 있다. 결론상 중앙값 선택을 k 번했을 때, 사실상 $2^{n-1} + 2^{n-2} + ... + 2^{n-k}$ = $2^{n}(1-{1\\over{2^k}})$ = $\\text{전체} \\times (1 - {1 \\over {2^k}})$개를 조회한 것과 같은 효과를 보는 것이다. 이 효과를 본 결과 우리가 K번 시도 후에 정답일 가능성이 있는 수를 나열해보라고 한다면, 해당 수는 $\\lfloor{\\text{전체} \\over {2^k}}\\rfloor$ 개만 남아있게 된다. 결과적으로 우리는 $\\lfloor{\\text{전체} \\over {2^k}}\\rfloor = 0$이 되는 k번만 수행하면, 어떤 수가 들어오더라도 목표값을 확정적으로 구할 수 있다.\n\n이진 탐색을 하기 위해서는 **결국 중앙값을 빠르게 찾는 것이 중요하다.** 따라서, 정렬이 중요한 것이다. 정렬을 하게 되면, 중앙값을 단순히 전체 크기의 반에 위치한 값으로 찾을 수 있기 때문에 이 연산이 매우 간단해진다.\n\n이를 구현하면 다음과 같다.\n\n```python\ndef binary_search(arr, target):\n  start = 0\n  end = len(arr)\n  # end는 이미 봤거나 배열범위의 밖이다.\n  while end \u003e start:\n    mid = (start + end) // 2\n    if arr[mid] \u003e target:\n      end = mid\n    elif arr[mid] \u003c target:\n      start = mid + 1\n    else:\n      return mid\n  return len(arr)\n\nA = [1,2,3,4,5,6,7,8]\nB = [1,3,5,7,10,15,50]\nC = [1,3,-7,-4,-1,-5]\n\nbinary_search(A, 3) # 2 \nbinary_search(B, 5) # 2\nbinary_search(B, 14) # 못찾아서, 배열의 크기(7)을 return\nbinary_search(C, 3) # 못찾고, 배열의 크기(6)를 return\nbinary_search(sorted(C), 3) # 5\n```\n\n다른 언어에서는 -1을 return하는 경우도 있지만, python에서는 -1을 index로 찾을려고 해도 compile 오류가 안나기 때문에 배열의 크기를 return하여 compile 에러를 만드는게 낫다.\n\n## Lower Bound / Upper Bound\n\n이분탐색의 응용으로 나오는 것이 하한선(Lower Bound)과 상한선(Upper Bound)이다. Lower Bound는 특정 수 이상의 값이 처음 나오는 index를 의미하고, Upper Bound는 특정 수를 초과하는 값이 처음 나오는 index를 의미한다.\n\n이들을 찾는 과정이 이분 탐색과 매우 유사하다.\n\n```python\ndef lower_bound(arr, target):\n  start = 0\n  end = len(arr)\n  while end \u003e start:\n    mid = (start+end) // 2\n    if arr[mid] \u003c target:\n      start = mid + 1\n    else:\n      end = mid\n  return end\n\ndef upper_bound(arr, target):\n  start = 0\n  end = len(arr)\n  while end \u003e start:\n    mid = (start + end) // 2\n    if arr[mid] \u003c= target:\n      start = mid + 1\n    else:\n      end = mid\n  return end\n```\n\n## 중복수의 갯수\n\n우리가 중복수를 셀 때 어떻게 해야할까? \n\n1. 앞에서 부터 찾아나간다. $O(N)$\n2. 특정 수를 찾고, 좌우 값을 찾는다. $O(N)$\n3. 해당 수 이상이 처음 나오는 위치를 찾고, 해당 수를 초과한 값이 처음 나오는 위치를 찾는다. $(O(\\log{N}))$\n\n극단적인 예시로 0이 연속으로 1조개 이상 있는 list에서 0의 중복 횟수를 셀려면 100억번의 연산이 필요하다. 하지만, 3번 방법을 사용하면, $2^{40} \\ge \\text{1조}$이므로 총 80회 정도의 연산으로 성공적인 연산이 가능하다.\n\n하지만, 유의할 것은 lower_bound가 해당 값을 실제로 찾았는가이다. 따라서, lower_bound를 통해서 얻은 index가 실제로 해당 목표값이 맞는지를 반드시 확인하자.\n(왜냐하면, return값이 0인 경우, 찾았을 수도 있고, 못찾았을 수도 있다.)\n\n```python\ndef get_dup_cnt(arr, target):\n  lb = lower_bound(arr, target)\n  if lb \u003c len(arr) and arr[lb] == target:\n    return lb - upper_bound(arr, target)\n  return 0\n```\n","slug":"binary-search","title":"Binary Search","category":"Algorithm","tags":["Binary Search","Upper Bound","Lower Bound","중복 수의 갯수"],"date":"2022년 5월 2일 15:34","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"\n## Reference\n\n- [Openflow specification](https://opennetworking.org/wp-content/uploads/2013/04/openflow-spec-v1.3.1.pdf), ONF, 2012\n- Thumbnail: Photo by [Jordan Harrison](https://unsplash.com/@jordanharrison?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/network?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n\n이전 Posting인 SDN의 본격적인 시작이 OpenFlow라고 보아도 무방하다. OpenFlow는 2007년 Stanford 대학에서 개발이 시작되었고, 지금도 de facto standard(사실상의 표준)으로 받아들여지고 있는 Protocol이다. 해당 Protocol의 핵심은 기존 Switch/Router를 data plane(데이터 평면)과 control plane(제어 평면)으로 나누고, 제어 평면을 OpenFlow Protocol에 따르는 Controler로 대체하면서, OpenFlow Protocol을 따르는 Switch는 data plane만을 포함하여, 둘 간의 통신을 통해서 제어 평면을 구성하자는 것이다. 여기서 데이터 평면은 실제로 interface로 packet이 들어오고, 내보내는 역할을 하는 계층이라고 보면 되고, 제어 평면은 packet에 어떤 동작을 수행시킬지 그리고 어느 interface로 내보낼지를 결정하는 역할을 하는 계층이라고 보면 된다. 이러한 구성을 통해서, 결국 SDN을 구축할 수 있는 토대를 제공하게 된 것이다.\n\n따라서, OpenFlow Switch는 다음과 같은 형태로 구성되어진다.\n\n![OpenFlow Switch](/images/openflow-switch.jpeg)\n\n## OpenFlow Protocol\n\n해당 사항은 reference에 기반한 version 1.3.1의 기능을 요약한 내용이다.\n\n기본적으로 OpenFlow Protocol을 지원하는 Switch의 구조부터 알아보아야 한다. Switch는 기본적으로 외부와 연결이 가능한 Port, Routing을 위한 여러 개의 Table, 그리고 Controller와의 의사소통을 위한 Channel을 가진다. 각 요소의 역할을 간략히 하나하나 알아보도록 하자.\n\n\u003e **1. Port**\n\nOpenFlow에서 packet이 Switch로 왔다갔다하는 통로라고 볼 수 있다. 대게 Switch를 가르키거나 packet의 진입 위치를 식별할 때 사용된다. 이는 실제로 존재하는 것이 아닌 추상화된 개념으로, 총 3가지의 Port를 통해서 Switch를 가르킬 수 있다. 각 Switch는 여러 개의 Port를 가지고 이를 통해서 다른 Switch들과도 연결되어진다.\n\n- Physical Port : 실제 Switch의 interface와 일대일로 대응되는 가상 Port이다. 즉, 해당 interface로 packet이 들어왔다면, OpenFlow에서는 이와 대응되는 port로 packet이 들어왔다고 판단한다.\n- Logical Port : OpenFlow를 쓰지 않고, Switch 자체적으로 정의한 Tunnel과 Loopback과 같은 가상 Port이다.\n- Reserved Port : OpenFlow Protocol에 의해서 정의된 Port이다. 이를 통해서, Controller, All, Table의 맨 처음, IN_PORT 등을 쉽게 가르킬 수 있다.\n\n\u003e **2. Table**\n\nSwitch는 여러 개의 Table을 가지고 있다. Table을 통해서 Switch는 Routing을 수행하는 것은 기본적인 Switch의 동작과 동일하다. Switch의 특정 Port로 packet이 들어왔을 때, packet의 목적지와 진입한 Port, 그 외에 metadata에 기반하여 matching을 수행하여 일치하는 대상을 찾아서, 해당 Table에 기술된 동작을 수행하는 것이다. 대게 무슨 동작을 수행할 것인가에 따라서 종류가 나뉘어지며, v1.3.1에는 총 3가지의 종류가 존재한다.\n\n1. Flow Table : 대게 어떻게 Packet을 어느 Port로 Routing할 것인가를 다룬다. 뿐만 아니라 Packet의 Header를 변경하거나 MPLS Label과 같은 추가 정보를 더하는 등의 동작을 수행할 수 있다. (각 Switch는 하나 이상의 Flow Table을 소유한다.)\n2. Group Table : 패턴과 일치하는 packet에 대해서 여러 동작을 수행하게 하거나 상황에 따라 다르게 적용하도록 하기 위해서 사용할 수 있다. (각 Switch는 1개 이하의 Group Table을 소유한다.)\n3. Meter Table : packet의 빈도(rate) 조절과 측정을 수행할 수 있다. (Meter Table은 Controller에 의해서 관리된다.)\n\n\u003e **3. OpenFlow Channel**\n\nOpenFlow Switch 내부에서 Controller를 연결하는 Interface로 Switch의 상태를 Controller에게 알리거나 Controller로 부터 변경사항을 전달 받기 위한 통신 채널이다.\n\n---\n\n이렇게 이루어진 OpenFlow Switch들은 서로 연결되어 있으며, 하나 또는 여러 Controller와 각 각 연결되어 있다. Controller는 각 OpenFlow Switch로 부터 상태 정보와 인접 Switch 정보 등을 전달받아서 내부적으로 Flow Table을 구축한다. 그리고, Controller에서 중앙 통제를 통해서 전체 네트워크를 관리할 수 있는 것이다. 이를 수행할 때에는 Controller에서 각 Switch의 Table을 지정함으로써 구현이 가능하다. 그렇다면, Switch에 Table을 설치하였을 때, 어떻게 Packet을 처리하는지에 대해서 알아보자.\n\n### Pipeline\n\nSwitch 내부에는 여러 개의 Table이 존재하는데, Packet이 Switch의 특정 Port로 들어오면, 먼저 Flow Table을 거치게 된다. Switch 내부의 여러 Flow Table 중에서 index($\\ge 0$)가 작은 값부터 시작하여 Flow Table에서 일치하는 pattern의 Flow Entry를 찾게 된다(Flow Table의 하나의 열). 해당 Entry에 적힌 `Instruction`에 따라 `Action`을 바로 수행하거나 `Action Set`에 추가한 후에 다음 Table 또는 Port를 통해서 다음 Switch로 이동하게 된다. 이때 Port 밖으로 나가기 이전에 Action Set에 모아둔 Action을 한 번에 수행한다.  \n만약, Flow Table의 어떤 pattern과도 일치하지 않는다면, 이를 `Table Miss`라고 하고, 미리 지정해둔 miss flow entry에 따라 Action을 수행한다. 아무 설정도 하지 않았다면 default로 해당 packet을 drop한다.\n\n그렇다면, 각 Table을 구성하는 요소(entry)들이 어떻게 구성되는지를 확인해보자.\n\n\u003e **1. Flow Entry**\n\n- Match Field : 일치하는 Packet을 찾기 위하여 Ingress Port / Egress Port / Packet Header / 다른 Table에서 생성된  Metadata 등을 사용한다.\n- Priority : 일치하는 대상이 많을 경우, 높을 수록 조회 시에 우선시 되어진다.\n- Counters : match가 수행된 횟수를 마킹한다.\n- Instructions : packet에 대해서 특정 Action을 수행시키거나 Action Set을 변경한다.\n- Timeout : 최대 처리 시간 또는 남은 시간 등을 표시한다.\n- Cookie : Controller에 의해 설정된 데이터로 대게 해쉬 / 암호화 되어진다. 이는 Controller에서 Flow 관측 및 조절 시에 사용한다.\n\n\n\u003e **2. Group Entry**\n\n- Group Identifier : Group 식별자\n- Action Buckets : 여러 개의 action과 이에 해당하는 parameter를 담은 bucket들을 정렬 후 보관\n- Group Type : Group의 동장 방식을 선택\n  - all :  모든 bucket을 실행\n  - select : bucket을 번갈아가면서 실행하여 Load Balancing을 실행\n  - indirect : bucket 하나만 실행하며, bucket을 여러 개 두는 것을 허락하지 않는다.\n  - fast failover : 가장 먼저 켜져있다고 판단되는 port를 가진 bucket 하나만 실행\n- Counters : Group에 의해 처리된 packet의 수\n\n\u003e **3. Meter Entry**\n\n- Meter Identifier : Meter 식별자\n- Meter Bands : packet rate와 이에 따른 packet 처리 방법을 가진 여러 meter band를 순서없이 저장. band를 선택할 때에는 측정된 rate보다 작으면서 가장 큰 rate를 가진 band를 선택한다. 각 band는 아래와 같이 구성된다.\n  - Band Type : rate를 넘긴 후의 packet 처리 방식을 선택\n    - drop : packet을 버린다.\n    - dscp remark : IP header에 drop 우선순위를 높인다.\n  - Rate : packet rate의 하한선\n  - Couter : 처리된 packet의 수\n  - Type Specific Arguments : 부가 정보\n- Counters : Meter에 의해 처리된 packet의 수\n\n---\n\n마지막으로, Instruction과 Action 그리고 Action Set의 구성을 살펴보자.\n\n\u003e **1. Instruction**\n\nInstruction은 다음과 같은 종류가 있다. 이를 통해서 명령을 적용하거나 Table을 이동하고, ActionSet을 변경하는 것이 가능하다.\n\n1. `meter meter_id` : packet에 특정 meter를 적용\n2. `apply-actions action(s)` : packet에 해당 action(s)를 즉각적으로 수행\n3. `clear-actions` : `Action set`을 바로 비우기\n4. `write-actions action(s)` : Action Set에 해당 action(s)를 추가\n5. `write-metadata metadata/mask` : metadata를 추가\n6. `goto-table next-table-id` : 특정 table로 이동. 단, 반드시 현재 Table index보다 더 큰 index로 이동해야 한다.\n\n\u003e **2. Action Set**\n\npipeline이 종료 된 후에 실행되는 action이 저장되어 있다.\n\naction은 기본적으로 아래 순서대로 실행되지만, 동일한 action은 들어온대로 실행되는 것이 아닌 임의로 실행된다.\n\n1. `copy TTL inwards` : TTL을 체크하는 action을 실행\n2. `pop` : 만약, packet에 tag가 존재한다면, 모두 제거한\n3. `push MPLS` : MPLS tag(=label)을 추가\n4. `push PBB` : PBB tag를 추가\n5. `push VLAN` : VLAN tag를 추가\n6. `copy TTL outwards` : TTL을 체크하는 action을 실행\n7. `decrement TTL` : TTL을 감소시키는 action을 실행\n8. `set` : `set-field`에 해당하는 action을 실행\n9. `qos` : `qos` 관련 action을 실행\n10. `group` : 연관된 group bucket의 action을 실행\n11. `output` : `output` action으로 명시된 port로 packet을 forwarding\n\n\u003e **3. Action**\n\n실제로 packet을 처리하는 방법에 대한 방법이다.\n\n1. `output` : OpenFlow port 중 어디로 forwarding할지를 지정\n2. `set-queue` : QoS 지원을 위해 packet을 내보낼 Switch의 queue Id를 지정\n3. `drop` : 직접 호출할 수는 없지만, output이 없거나 `clean-actions` 수행 시에 내부적으로 수행한다.\n4. `group` : group을 통해 packet을 처리하도록 group table로 packet 전달\n5. `push-tag` : MPLS / VLAN 등의 tag를 추가\n6. `pop-tag` : MPLS / VLAN 등의 tag를 삭제\n7. `set-field` : header의 가장 끝에 특정 값을 추가\n8. `change-ttl` : ttl값을 수정\n\n## 표준화 현황\n\n| version | 발표일  | 주요 기능 추가                                  | 기관                |\n| :------ | :------ | :---------------------------------------------- | :------------------ |\n| OF 1.0  | 2009.12 | MAC, IPv4, Single Table                         | OpenFlow Consortium |\n| OF 1.1  | 2011.2  | MPLS/tunnel, Pipeline(Multi Table), Group Table | OpenFlow Consortium |\n| OF 1.2  | 2011.12 | IPv6, Of-Config, 다중 Controller 지원           | ONF                 |\n| OF 1.3  | 2012.9  | Meter Table(QoS), Controller 별Event Filtering  | ONF                 |\n| OF 1.4  | 2013.10 | Optical port monitoring, Flow 삭제 원인         | ONF                 |\n| OF 1.5  | 2014.12 | Egress Table 추가                               | ONF                 |\n\n현재에는 OpenFlow 표준화는 중단된 상태이다. 모든 요구사항을 받아들이다보니 match field의 크기가 너무나 커졌기 때문이다. 따라서, 이용자의 요구에 따라서 programming 할 수 있는 환경을 제공하기 위한 P4(Programmable Protocol-Independent Packet Protocol)을 제작하였다.\n\n즉, 기존에는 Protocol과 이를 지원하는 Switch를 주요 서비스로 삼았다면, 이제는 Programming이 가능한 언어와 이를 이용할 수 있는 Switch를 제공하는 방향으로 전환하였다.\n","slug":"openflow","title":"OpenFlow","category":"Network","tags":["SDN","ONF"],"date":"2022년 5월 25일 22:23","thumbnailSrc":"https://euidong.github.io/images/switch-with-cable.jpg"},{"content":"\n## Reference\n\n- Thumbnail : Photo by [Nastya Dulhiier](https://unsplash.com/@dulhiier?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/network?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n\nSDN(Software Defined Network)은 기존에 Hardware단에 결합되어 있던 각종 Routing, Forwarding 방식을 별도의 Controller를 통해서 제어하는 방식을 제시한 것이다. 현재 이러한 기술에 대한 연구가 꾸준히 이루어지고 있는데, 이유를 알기 위해서는 기존의 Network 구성 방식의 문제점을 먼저 짚어보자.\n\n## Internet의 문제\n\n\u003e **Traffic 과증가**\n\nTraffic의 매년 20% 이상으로 굉장히 가파르게 성장하고 있다. 이것 자체도 문제가 될 수 있지만, 이로 인한 문제가 더 큰 문제가 되고 있다.\n\n\u003e **통신사업자의 고민**\n\n계속해서 늘어나는 traffic 대비 수익의 정체가 발생하였다. 즉, 증가하는 traffic을 수용하기 위한 link, switch 등의 투자 비용은 계속해서 요구되는 한편 신규 가입자 수는 거의 존재하지 않기 때문에 통신사업자가 가져가는 수익은 현재 매우 정체되어있다. 반면에 늘어난 traffic에 대한 이득은 고스란히 대규모 service 업체에서 가져가고 있다. (ex. Google, Netflix, etc..)\n\n이러한 관점에서 통신사업자와 서비스 사업자 간의 아래와 같은 대립이 계속되고 있다.\n\n- 공정성(Fairity) : traffic 증가는 서비스 사업자도 같이 부담하자.\n- 망중립성(Neutrality) : traffic 증가는 서비스 사업자가 상관할 영역이 아니다.\n\n\u003e **느린 표준화**\n\n표준화라는 절차는 호환성 검사 및 성능 확인 등을 거치면서 굉장히 많은 시간을 요구한다. 하지만, 신기술은 계속해서 쏟아지고 있기 때문에 표준화가 이 속도를 못따라가고 있는 것이 실황이다. 이를 실제 상용에서 적용하는 것 역시 더 많은 시간이 들게 될 수 있다.\n\n\u003e **Vender 의존성**\n\n통신 장비(Switch, Router, Ethernet, etc...)를 제작하는 Vender(Cisco, Juniper, etc...)가 만든 platform에 의존하는 설정 방법이 혼란을 야기했다. 즉, 각 vender마다 다른 시스템과 configuration 방법이 존재하기 때문에 human error를 야기할 가능성이 높았다.\n\n또한, Switch/Router의 동작을 제어하는 것이 해당 vender가 제공하는 API에 제한되기 때문에 사용자가 Programming을 통해 Routing을 제어하는 것이 불가능했다. 그렇기에 신기술에 대한 테스트를 수행할 수 없을 뿐만 아니라 Vender에서 해당 신기술을 적용하기를 기다리는 수 밖에 없었다.\n\n\u003e **Router/Switch의 복잡도 증가**\n\ntraffic의 증가만큼 Router, Switch의 성능적인 향상 및 양적 증가는 많은 문제를 야기하고 있다. 먼저, 성능을 만족하기 위하여 점점 가격이 급격하게 상승하고 있다. 양적으로의 증가는 결국 Routing Table의 크기를 크게 증가시키고 있다. 이는 Table Lookup, Convergence Time 증가를 야기한다.\n\n\u003e **초기 인터넷의 구조적 문제**\n\n초기 인터넷인 ARPANET은 설계 자체가 절대 연결이 끊기지 않는(autonomous, Best Effort) Network를 추구했다. 그렇기에 사람에 의한 개입이 쉽지 않고, 통제가 어려운 구조이다. 따라서, 각 장비에게 부여되는 책임이 커졌다.\n\n\u003e **TCP/IP 기반의 수 많은 Protocol**\n\n지연보다는 연결에 초점을 맞춘 안전한 TCP/IP 기반의 통신은 Network의 성능면에서 많은 어려움을 겪고 있다. 물론 새로운 TCP 방식도 제시되고 있지만, 이를 교체하는 것은 전체 Network를 변경해야하는 경우가 많기에 이에 대한 교체는 사실상 불가능하다고 간주되고 있다(호환성 문제). 또한, IoT 디바이스에서는 해당 TCP/IP가 다소 무거운 구현이기에 이를 포함할 수 없는 경우가 많다. 따라서, 별도의 Protocol을 지원하는 시스템이 필요하다.\n\n### 요약\n\n즉, Traffic은 계속해서 증가하고 있는데, 이를 해결하기 위한 신기술들은 계속해서 적용이 느려지고 있으며, Vender들 마다 다른 표준으로 인해 너무나 복잡한 네트워크 구성은 운영비용의 최적화가 어렵고, 유연한 네트워크 구조를 만드는데 굉장한 부담으로 다가왔다. 따라서, 이를 해결할 방법이 필요해졌다.\n\n## SDN\n\n위에서 제시한 문제들은 결국 각 Switch/Router와 같은 Hardware 장치에 Software가 귀속되어서 발생한다. 따라서, Switch/Router는 단지 Hardware의 기능을 수행하도록하고, Software는 최소한의 기능만을 남긴 후 이들이 수행하는 Forwarding/Routing 등의 동작을 별도의 Generic Computer에 Controller라는 역할을 부여하고, 이 Controller에 의해서 Forwarding/Routing을 제어할 수 있도록 구성한 Network를 통해서 기존 문제를 해결하자는 것이다.\n\n이를 통해서, 결국 각 장치들은 Routing이 어떻게 정해졌는지에 대한 내용은 알지 못한다. 하지만, Hardware적으로 packet의 입력을 받을 수 있을 뿐만 아니라 Controller로부터 어디로 packet을 forwarding 해야할지에 대한 정보는 알고 있고, 이에 따라 packet을 내보내는 것도 가능하다. 따라서, 전체 네트워크가 Controller를 분리함으로써 추상화가 되는 것이다. 이러한 추상화의 장점은 결국 유연한 네트워크를 만들 수 있다는 것이다.\n\n이것이 SDN이 추구하는 사상이다. 이것을 가능하게 한 것이 OpenFlow의 등장이다. OpenFlow에 대한 설명은 별도의 [Posting](/posts/openflow)에서 다룬다.\n\n\n### Google의 SDN 활용 사례\n\n\u003e **문제 상황**\n\nGoogle에서는 매년 40\\~45%의 Traffic의 증가가 발생하였다. 이를 대비하기 위해서, Google에서 전용 해저 케이블을 설치하였다. 이를 통해서, Google의 각 DataCenter 간의 연결 품질을 올리고 싶었다. 하지만, 실제로 DataCenter간의 통신에는 30\\~40% 수준으로만 케이블을 사용했다. 기존의 Routing으로 DataCenter간 서비스의 Traffic을 적절하게 분배하고 싶었지만 이를 수행할 수 없었다.\n\n\u003e **해결책**\n\n자체 개발한 OpenFlow Protocol을 지원하는 Switch를 개발하여, 이를 이용하여, 다음과 같은 서비스에 weight를 부여하여 적절하게 traffic을 분배하였다.\n\n- User data copy : 각 데이터 센터간의 e-mail, video 등의 파일 동기화\n- 검색어 ranking을 위한 데이터 copy\n- Datacenter간 상태 동기화\n\n해당 service에서 발생하는 traffic을 적절하게 weight를 부과하여 SDN을 활용하여 분배하여 결국 Datacenter간의 통신에서 광케이블 활용률이 90%까지 상승했다.\n\n## NFV\n\nSDN과 같이 얘기되어지는 NFV(Network Function Virtualization)도 살펴보고자 한다. 위에서 SDN을 설명하였지만, 결국 아직까지는 DataCenter를 운영하는 서비스 사업자 지향적이다. 대게 닫힌 네트워크 내에서 사용이 용이하다는 것인데, 이는 보안과 관련된 부분도 부족하기 때문이다. 따라서, 통신 사업자들은 SDN을 효과적으로 구성하기 위해서 통신 장비의 하드웨어와 소프트웨어를 분리할 방법을 찾아야 했다. 여기서 나온 방법이 Cloud를 활용하여 소프트웨어 영역을 Cloud 내부에서 구현하고, 통신 장비는 최소한의 소프트웨어만으로 구성하는 것이다. 즉, Network의 특정 기능을 가상화해서 필요에 따라 각 하드웨어 장비가 불러와 사용한다는 개념이다. 결국 통신 사업자 입장에서는 SDN을 구축하기 위해서는 NFV의 구현이 우선시되는 것이다. 이를 수행하게 되면, 당연히 Software의 유연한 구현이 가능하고, 각 장치에서 Software까지 부담해야 하는 비용이 줄기 때문에 설치 및 운영비용(CAPEX / OPEX)에서 큰 이점을 볼 수 있는 것이다.\n","slug":"sdn","title":"SDN","category":"Network","tags":["SDN","NFV"],"date":"2022년 5월 25일 09:00","thumbnailSrc":"https://euidong.github.io/images/network-background.jpg"},{"content":"\n### Reference\n\n- Thumbnail : Photo by [Jordan Harrison](https://unsplash.com/@jordanharrison?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/network-cable?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n- mininet : \u003chttps://github.com/mininet/mininet/wiki/Introduction-to-Mininet\u003e\n\nmininet은 현실적인 가상 네트워크 환경을 구축해주는 `Network Emulator`, 더 정확히는 `NETOWKR Emulation Orchestration System`이다.  \n이를 통해서, 가상의 End Device(Host), 각종 Switch, Router, 그리고 이를 연결하는 Link를 단 하나의 Linux Kernel로 만들 수 있다. 여기서 그치지 않고, 각 Host에 `ssh` 접근을 수행하여 기본 Linux Kernel 동작을 수행하거나 ethernet을 이용해서 각 device로 packet을 전송하는 것과 같은 효과를 볼 수 있다. (실제 speed와 delay에 기반한 속도를 볼 수 있다.) 또한, SDN과 같은 환경에 필요한 Controller 역시 구성하는 것이 가능하다. 그렇기에 실제로 SDN Network를 Test하고 연구하는 목적으로 많이 사용되고 있다.\n\n## 장점\n\n1. Fast - 가상 네트워크의 구성이 굉장히 빠른 시간 내에 구성된다. 실제로 동작해보면, 이를 알 수 있다.\n2. Customize Topology - 간단한 네트워크에서부터 시작해서, Backborn, Datacenter, Internet 등 모든 네트워크 구성이 가능하다.\n3. Can run every programs in Linux - 간단한 Web Server에서부터 시작하여 Mornitoring Service인 Wireshark 등의 활용이 가능하다.\n4. Progammable - 각 Switch의 동작도 programming이 가능하기에 OpenFlow Protocol을 기반으로 packet forwarding 역시 customizing이 가능하다.\n5. LightWeight - Labtop에서 돌아갈 정도로 가볍다.\n6. Can share results - 각 Topology와 같은 구성은 python code로 구성되고, test code 등도 쉽게 공유가 가능하다.\n7. Easy - Mininet 실행과 구축 그리고 운영이 매우 간단한 CLI, Python code로 작성이 가능하기 때문에 매우 쉽다.\n8. OpenSource - 쉽게 커뮤니케이션이 가능하고, 누구나 해당 프로젝트에 참여가 가능하다.\n\n## 주의사항\n\n1. 만약 10Gbps 이상의 traffic을 처리하기를 원하는 경우, 부하를 적절히 분배하기 위한 구조를 실행자 측에서 구성할 필요가 있다.\n2. Mininet은 하나의 Linux Kernel을 통해 모든 Virtual Host를 제어한다. (다른 Platform, Window 등은 지원하지 않는다. VM 필요)\n3. Mininet에서는 OpenFlow Controller를 사용할 수는 있지만, 이를 직접 제어할 방법은 제공하지 않는다.\n4. 기본적으로는 Host LAN과는 분리되어 있다. (물론 `NAT`를 통해서 연결도 가능하다.)\n5. 기본적으로 Mininet에 의해 생성된 Host는 PID와 file system을 공유한다. (물론 바꿀 수는 있지만, 유의하자.)\n6. Simulator가 아니기 때문에, Virtual Time에 대한 매우 정확한 지표를 제시할 수는 없다.\n\n\u003e Mininet 활용\n\nMininet을 제대로 활용하기 위해서는 다음과 같은 사항을 숙지해야 한다.\n\n0. 설치\n1. Topology 생성\n2. Performance 측정\n3. OpenFlow를 이용해서 Custom Routing\n\n이제부터 위의 내용을 하나하나 수행해 볼 것이다.\n\n## 0. 설치\n\n[Mininet Repo](https://github.com/mininet/mininet)\n\n위의 링크에서 INSTALL이라는 파일에 따라서 설치를 진행해보자. 역시 제일 쉬운 것은 제작자가 직접 만들어놓은 Virtual Machine 이미지를 활용하여 실행하는 것이다.\n\n## 1. Topology 생성\n\n아래의 형태가 가장 기본적인 형태의 Topology이다. 이를 실행시키면, 기본적으로 두 개의 Host가 하나의 Switch에 각 각 연결된 형태로 구성되어진다.\n\n![one-switch-topology](/images/one-switch-topo.jpeg)\n\n```python\nfrom mininet.topo import Topo\n\nclass SingleSwitchTopo(Topo):\n  \"Single switch connected to n Hosts.\"\n  # build function 내부에서 topology를 구성하는 요소에 대해 정의\n  # self.__init__의 parameter가 해당 함수로 그대로 전달된다.\n  def build(self, n=2):\n    # s1이라는 이름으로 Switch 생성\n    switch = self.addSwitch('s1')\n    for h in range(n):\n      # h1, h2, ... 이라는 이름으로 Host 생성\n      host = self.addHost('h%s' % (h+1))\n      # h1, h2, ... 을 s1과 연결\n      self.addLink(host, switch)\n\n# 후에 topology를 생성할 때, 아래 이름을 통해서 지정이 가능\ntopos = { 'singleSwitch': (lambda: SingleSwitchTopo())}\n```\n\n이를 파일로 생성하고, 다음과 같이 실행시키면 된다.\n\n```bash\n$ sudo mn --custom [file명.py] --topo [topology 이름],[build function parameters]\n\n# example\n$ sudo mn --custom mytopo.py --topo singleSwitch,3\n```\n\n하지만, 위와 같이 mininet command를 통해서 실행시키는 것은 자동화에는 적절하지 않을 수 있다.  \n만약, 부가적인 설정을 해주고 싶거나 실행 후에 test 및 실험하고자 하는 상황을 만들고자 한다면 추가적인 programming이 필요하다.  \n아래 코드를 추가적으로 살펴보자.\n\n```python\nfrom mininet.topo import Topo\nfrom mininet.net import Mininet\nfrom mininet.util import dumpNodeConnections\nfrom mininet.log import setLogLevel\n\nclass SingleSwitchTopo(Topo):\n  \"Single switch connected to n Hosts.\"\n  def build(self, n=2):\n    switch = self.addSwitch('s1')\n    for h in range(n):\n      host = self.addHost('h%s' % (h+1))\n      self.addLink(host, switch)\n\ndef simpleTest():\n    \"Create and test a simple network\"\n    topo = SingleSwitchTopo(n=4)\n    # Mininet 생성\n    # 이때, Topology, Host, Switch, Controller, Link 등에 대한 Customizing이 가능하다.\n    net = Mininet(topo)\n    # mininet 실행\n    net.start()\n    print( \"Host의 연결 상태를 출력\" )\n    dumpNodeConnections(net.hosts)\n    print( \"Netowork 연결 상태를 체크\" )\n    # ping to every node with each node.\n    net.pingAll()\n    # mininet 정지\n    net.stop()\n\nif __name__ == '__main__':\n    # Tell mininet to print useful information\n    setLogLevel('info')\n    simpleTest()\n```\n\n```bash\npython [file명.py]\n```\n\n이를 통해서, Mininet를 우리가 정의한 Topology에 따라서 실행하고 테스트를 수행하는 code이다.  \n이러한 기능 뿐만 아니라 host의 성능을 제한하거나 Link 용량을 제어할 수도 있고, Switch를 제어할 수도 있고, 특정 Host에서 Command를 실행시키도록 할 수도 있다.  \n더 자세한 사항은 아래 링크를 통해서 확인해보자.\n[More Example](https://github.com/mininet/mininet/tree/master/examples)\n\n위에서 살펴본 사항은 가장 기본적인 Mininet에서 제공하는 Template에 기반하여 programming을 수행하는 것이다. 만약, 직접적으로 제어를 원하는 경우 더 하위 단계의 API를 활용하여 구현하는 것도 가능하다. [API Doc](http://api.mininet.org)\n\n### 추가 참고사항\n\ncode convention이 후에 버전에서는 좀 변경되었다.\n\n- camelCase 표기가 snake_case형태로 변경되었다. example. `addHost -\u003e add_host`.\n- `build`가 `__init__`으로 바뀌어, 나의 기준에서는 이해하기 쉬워졌다.\n\n변경되었지만, 여전히 기존 버전 표기도 지원하기 때문에 사용하는데는 문제가 없다.\n\n\n## 2. Performance 측정\n\n해당 사항은 Mininet에서 권장하는 방법이다.\n\n1. Bandwidth - `bwm-ng`, `ethstats`\n2. Latency - `ping`\n3. Queues - `tc`\n4. TCP Congestion Window statistics - `tcp_probe`\n5. CPU usage - for all: `top`, per host: `cpuacct`\n\n## 3. OpenFlow를 이용해서 Custom Routing\n\nMininet 자체만으로도 값지지만 SDN을 구축하기 위한 OpenFlow Protocol을 이용한 Routing을 Emulating할 때에 굉장한 효과를 얻을 수 있다.  \nMininet을 실행시킬 때에 아무 설정을 하지 않으면 기본 Ethernet switch를 사용하는 기본 Controller를 사용한다. 하지만, Open vSwitch(ovs)와 같은 OpenFlow Protocol을 지원하는 Controller를 활용할 수도 있다.  \n기본적인 Switch(대략 4096개)는 이미 지원을 하고 있다. 이를 불러와서 사용하거나 원하는 경우에는 python을 통해서 직접 구현하여도 무방하다. 심지어는 원격에 있는 controller를 사용할 수도 있다. \n\n이렇게 Controller를 정의하고, 외부에서 해당 Controller의 동작을 정의해주면, Mininet에 의해서 정의된 Network가 의도대로 동작하는지를 계속해서 확인할 수 있다.\n\n## NutShell\n\nMininet에서 어떻게 이렇게 빠르게 가상 Network System을 가볍게 구현할 수 있는가에 대한 열쇠는 `container`이다. 이를 통해서, 서로 완전 분리된 Host를 기본적으로 구성하는 Container이기에 이를 쉽게 구현할 수 있을 뿐만 아니라 Virtual Machine을 직접적으로 구현하지 않기 때문에 가볍고 빠를 수 있는 것이다. 또한, Virtual Link 같은 경우에는 Linux Traffic Control(`tc`)를 활용하여, Virtual Ethernet이 각 Virtual Switch와 Interface들을 통해서 전달되는 것을 제어할 수 있다. 마지막으로, Switch는 기본적인 Linux Bridge를 활요하거나 Open vSwitch를 활용하여 구성하여 가상화가 가능하다.\n\n\n## 결론\n\nMininet은 가상 Network를 Emulating 할 수 있는 Tool이기에 실제로 SDN을 테스트하기 이전에 각종 기능을 체크하기에 용이하다.  \n또한, Network에서 핵심적인 Forwarding에 관한 기술은 다른 기술에게 맡겨서 더 안정적인 구조를 가지고 있다.  \n이에 따라 Open vSwitch를 이용해서 자유롭게 시스템을 제어할 수 있을 뿐만 아니라 ONOS와 같은 도구를 통해서 Network를 구성하는 과정을 테스트하기에 굉장히 유용하다.","slug":"mininet","title":"Mininet","category":"Network","tags":["Emulator","Tool"],"date":"2022년 5월 24일 12:58","thumbnailSrc":"https://euidong.github.io/images/switch-with-cable.jpg"}],"categorizedPosts":{"Algorithm":[{"content":"\nBinary Search는 가장 기본적이면서도 효과적인 탐색 방법이다. 이는 굉장히 많은 알고리즘의 기본 알고리즘으로 많이 사용된다. 따라서, Binary Search를 제대로 사용할 줄 알아야 한다. 또한, 뒤에 부분에서는 이를 이용해서 중복수를 찾아내는 연산을 어떻게 Binary Search를 통해서 할 수 있는지를 알아볼 것이다.\n\nBinary Search를 하기 위해서는 먼저 list를 정렬해야 한다. 그렇게 하게 되면, 특정 수를 찾기 위해서 최대 list 전체를 탐색하는 것에서 리스트의 크기를 log 취한 만큼 만 연산해도 충분하다.\n\n일반적인 예시가 Up\u0026Down 게임이다. 이는 특정 범위 안의 숫자를 맞히고자 할 때 기회를 여러 번주고, 시도할 때마다 시도한 값과 목표 값을 비교하여 목표값이 더 크면 Up, 더 작으면 Down을 알려주는 게임이다. 우리가 값을 맞추고자할 때마다 해당 값에 대한 힌트가 주어지게 되는데, 만약 우리가 매번 수의 중앙 값을 말한다면, 얻을 수 있는 정보의 질이 굉장히 높아진다. 물론 범위가 100이고 맞추고자 하는 값이 100일 때, 99라고 말하고 Up을 듣는다면 최상의 정보를 얻게 되는 것이지만, 만약 Down이라면, 받을 수 있는 정보의 질이 굉장히 떨어진다. 왜냐하면 내가 해당 수를 외침으로써 다음 시도에서 제외할 수 있는 수는 2개 밖에 없기 때문이다.\n\n결국 우리는 특정 수를 맞추지 못했을 경우, 고급 정보를 얻어 다음 도전을 할 수도 있고, 안좋은 정보를 얻어 다음 도전에 도움이 덜 될 수도 있다. 즉, 우리가 맞추어야 할 수가 하나라면, 위와 같은 요행에 기대어 도전하는 것도 나쁘지 않은 선택이라고 할 수 있다. 예를들어, 2의 배수 순으로 조회하는 것이다.\n\n하지만, 우리가 해당 게임을 여러 번 진행할 것이고, 범위가 넓어질 경우 질이 안좋은 정보를 얻었을 경우의 Risk가 너무 클 수 있다. 따라서, 우리는 어떤 숫자가 들어오더라도 **확정적으로 연산 횟수를 줄이기를 기대할 것**이다. 그 방법이 항상 범위의 중앙값을 선택하는 것이다. 그렇다면, 어떤 수가 목표이더라도 우리는 선택지를 매번 반으로 나눌 수 있다. 결론상 중앙값 선택을 k 번했을 때, 사실상 $2^{n-1} + 2^{n-2} + ... + 2^{n-k}$ = $2^{n}(1-{1\\over{2^k}})$ = $\\text{전체} \\times (1 - {1 \\over {2^k}})$개를 조회한 것과 같은 효과를 보는 것이다. 이 효과를 본 결과 우리가 K번 시도 후에 정답일 가능성이 있는 수를 나열해보라고 한다면, 해당 수는 $\\lfloor{\\text{전체} \\over {2^k}}\\rfloor$ 개만 남아있게 된다. 결과적으로 우리는 $\\lfloor{\\text{전체} \\over {2^k}}\\rfloor = 0$이 되는 k번만 수행하면, 어떤 수가 들어오더라도 목표값을 확정적으로 구할 수 있다.\n\n이진 탐색을 하기 위해서는 **결국 중앙값을 빠르게 찾는 것이 중요하다.** 따라서, 정렬이 중요한 것이다. 정렬을 하게 되면, 중앙값을 단순히 전체 크기의 반에 위치한 값으로 찾을 수 있기 때문에 이 연산이 매우 간단해진다.\n\n이를 구현하면 다음과 같다.\n\n```python\ndef binary_search(arr, target):\n  start = 0\n  end = len(arr)\n  # end는 이미 봤거나 배열범위의 밖이다.\n  while end \u003e start:\n    mid = (start + end) // 2\n    if arr[mid] \u003e target:\n      end = mid\n    elif arr[mid] \u003c target:\n      start = mid + 1\n    else:\n      return mid\n  return len(arr)\n\nA = [1,2,3,4,5,6,7,8]\nB = [1,3,5,7,10,15,50]\nC = [1,3,-7,-4,-1,-5]\n\nbinary_search(A, 3) # 2 \nbinary_search(B, 5) # 2\nbinary_search(B, 14) # 못찾아서, 배열의 크기(7)을 return\nbinary_search(C, 3) # 못찾고, 배열의 크기(6)를 return\nbinary_search(sorted(C), 3) # 5\n```\n\n다른 언어에서는 -1을 return하는 경우도 있지만, python에서는 -1을 index로 찾을려고 해도 compile 오류가 안나기 때문에 배열의 크기를 return하여 compile 에러를 만드는게 낫다.\n\n## Lower Bound / Upper Bound\n\n이분탐색의 응용으로 나오는 것이 하한선(Lower Bound)과 상한선(Upper Bound)이다. Lower Bound는 특정 수 이상의 값이 처음 나오는 index를 의미하고, Upper Bound는 특정 수를 초과하는 값이 처음 나오는 index를 의미한다.\n\n이들을 찾는 과정이 이분 탐색과 매우 유사하다.\n\n```python\ndef lower_bound(arr, target):\n  start = 0\n  end = len(arr)\n  while end \u003e start:\n    mid = (start+end) // 2\n    if arr[mid] \u003c target:\n      start = mid + 1\n    else:\n      end = mid\n  return end\n\ndef upper_bound(arr, target):\n  start = 0\n  end = len(arr)\n  while end \u003e start:\n    mid = (start + end) // 2\n    if arr[mid] \u003c= target:\n      start = mid + 1\n    else:\n      end = mid\n  return end\n```\n\n## 중복수의 갯수\n\n우리가 중복수를 셀 때 어떻게 해야할까? \n\n1. 앞에서 부터 찾아나간다. $O(N)$\n2. 특정 수를 찾고, 좌우 값을 찾는다. $O(N)$\n3. 해당 수 이상이 처음 나오는 위치를 찾고, 해당 수를 초과한 값이 처음 나오는 위치를 찾는다. $(O(\\log{N}))$\n\n극단적인 예시로 0이 연속으로 1조개 이상 있는 list에서 0의 중복 횟수를 셀려면 100억번의 연산이 필요하다. 하지만, 3번 방법을 사용하면, $2^{40} \\ge \\text{1조}$이므로 총 80회 정도의 연산으로 성공적인 연산이 가능하다.\n\n하지만, 유의할 것은 lower_bound가 해당 값을 실제로 찾았는가이다. 따라서, lower_bound를 통해서 얻은 index가 실제로 해당 목표값이 맞는지를 반드시 확인하자.\n(왜냐하면, return값이 0인 경우, 찾았을 수도 있고, 못찾았을 수도 있다.)\n\n```python\ndef get_dup_cnt(arr, target):\n  lb = lower_bound(arr, target)\n  if lb \u003c len(arr) and arr[lb] == target:\n    return lb - upper_bound(arr, target)\n  return 0\n```\n","slug":"binary-search","title":"Binary Search","category":"Algorithm","tags":["Binary Search","Upper Bound","Lower Bound","중복 수의 갯수"],"date":"2022년 5월 2일 15:34","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"우리가 알고리즘을 생각할 때, 가장 먼저 떠올릴 수 있는 방법 중에 하나입니다. 가장 기본적인 알고리즘이기 때문에, 굳이 설명을 하지 않아도 자연스럽게 채득하는 경우가 대부분이지만, 사고의 틀을 정하여 더 빠르게 답을 찾을 수 있습니다.\n\nBrute Force를 직접적으로 번역하면, 이는 \"무차별  대입\"정도로 생각할 수 있습니다. 이는 여러 가지의 경우의 수에서 최적의 답이 한 개 이상 존재할 때, 모든 경우의 수를 하나하나 대입해보면서, 정답이 맞는지를 확인하는 방식입니다. 즉, 가능한 모든 경우를 만들고, 그 후에 이것이 정답인지를 계속해서 확인하는 과정이 알고리즘의 핵심입니다.\n\n가장 흔한 예시가 해커들이 특정 유저의 password를 알아내기 위해서 모든 경우의 수를 대입하여 확인하는 것이 있습니다.\n\n## **해결 방법**\n\n이 알고리즘의 구현 순서는 다음과 같습니다.\n\n1.  모든 경우의 수를 헤아린다.\n2.  하나의 경우의 수를 갖고 하는 연산의 횟수를 헤아린다.\n3.  해당 알고리즘이 시간 내에 작동할 수 있는지 확인한다.  \n    대게, 1초동안 할 수 있는 연산은 대략 1억회라고 가정하면 쉽습니다.\n4.  알고리즘을 직접 구현한다.\n\n## **대표 예시**\n\n모든 경우의 수를 확인하는 문제가 굉장히 많기 때문에, 순열/조합/부분집합 문제가 굉장히 많습니다. 고등학교 시절 C, P로 경우의 수를 푸는 문제를 굉장히 많이 풀었다면, 아마 쉽게 할 수 있을 것입니다.\n\n일단 순열 조합을 가장 효율적으로 구현하는 방법에 대해서, 일단 정리를 해보겠습니다.\n\n### **1\\. 순열(Permutation)**\n\n```python\ndef permutation_helper(k, arr=[], prev=[]):\n    if len(prev) == k:\n        return [prev]\n    ss = []\n    for idx in range(len(arr)):\n        ss += permutation_helper(k, arr[:idx] + arr[idx+1:], prev + [arr[idx]])\n    return ss\n\n\ndef permutation(n, k):\n    arr = [i for i in range(1, n+1)]\n    return permutation_helper(k, arr, [])\n    \nprint(permutation(5, 2))\nprint(permutation_helper(2, [1,2,3,4,5], []))\n```\n\n### **2\\. 조합(Combination)**\n\n```python\ndef combination_helper(k, arr=[], prev=[]):\n    if len(prev) == k:\n        return [prev]\n    ss = []\n    for idx in range(len(arr)):\n        ss += combination_helper(k, arr[idx+1:], prev + [arr[idx]])\n    return ss\n\n\ndef combination(n, k):\n    arr = [i for i in range(1, n+1)]\n    return combination_helper(k, arr, [])\n\nprint(combination(5, 2))\nprint(combination_helper(2, [1,2,3,4,5], []))\n```\n\n### **3\\. 부분집합(Subset)**\n\n```python\ndef subset_helper(k, arr=[], prev=[]):\n    if len(prev) == k:\n        return []\n    ss = []\n    for idx in range(len(arr)):\n        ss.append(prev + [arr[idx]])\n        ss += subset_helper(k, arr[idx+1:], prev + [arr[idx]])\n    return ss\n\n\ndef subset(n, k):\n    arr = [i for i in range(1, n+1)]\n    return subset_helper(k, arr, [])\n\nprint(subset(5, 2))\nprint(subset_helper(2, [1,2,3,4,5], []))\n```","slug":"brute-force","title":"Brute Force","category":"Algorithm","tags":["BruteForce","순열","조합","부분 집합"],"date":"2022년 4월 14일 13:51","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"## DFS(Depth First Search)\nGraph의 탐색에서 가장 기본이 되는 방법입니다. 한 점에서 연결된 다른 점으로 이동을 하면서, 모든 연결된 점을 순화하는 것을 목표로 가진다고 가정해봅시다. 이때, 정점을 고르는 방식에 따라서, DFS, BFS로 나눕니다. DFS에서는 자신과 연결된 정점 중에서 하나를 선택하고 이동한 뒤에 해당 점에서 다시 연결된 지점을 찾아서 이동합니다. 즉, 바로 지금 뽑은 점에 인접해있는 지점이 이전에 인접해있던 지점보다 가중치가 높다는 것입니다. 이를 모두 진행하고도 답을 찾을 수 없다면, 이제 이전 시점으로 돌아와서 다시 작업을 재개하는 방식입니다.\n\n이를 구현하기 위해서는 `Stack`이 가장 중요합니다. 이전의 연결되었던 점보다 현재 연결된 점이 더 중요하기 때문에, 현재가 우선순위가 높지만, 후에 이를 다시 찾아와야 하기 때문에, 이를 저장하기 위한 자료구조가 필요한데 이것이 `Stack`이 되는 것입니다.\n\n따라서, 이를 직접 구현해보면 다음과 같습니다.\n```python\nadj = [\n  [2,3],\n  [3],\n  [0,3],\n  [0,1,2]\n]\n\nvisited = [False] * 4\nstack = [(0, visited)]\nwhile len(stack) \u003e 0:\n  cur, visited = stack.pop(-1)\n  visited[cur] = True\n  for next in adj[cur]:\n    if visited[next] === False:\n      stack.append((next, visited))\n```\n또는, Recursive Call(함수의 재귀 호출)을 통해서 구현할 수 있습니다. 재귀 호출을 통한 구현이 더 일반적이며, 이해하기 쉬운 구조이기 때문에 많이 사용됩니다. 왜냐하면, 함수는 기본적으로 `stack` 형식으로 호출한 함수들을 쌓아두기 때문에, 더 원활한 구현이 가능합니다. \n```python\nadj = [\n  [2,3],\n  [3],\n  [0,3],\n  [0,1,2]\n]\n\ndef dfs(cur, visited):\n  visited[cur] = True\n  for next in adj[cur]:\n    if visited[next] === False:\n      dfs(next, visited)\n\ndfs(0, [-1] * 4)\n```\n\n추가적으로 만약 순회해야 하는 그래프가 확실하게 모두 연결된 그래프가 아니라면(중간에 간선이 끊겨 연결이 되지 않는 정점이 존재하는 경우), 우리는 모든 정점에서 `dfs`를 수행하도록 설정을 해주어야 합니다. 그래야만 전체 점을 순환할 수 있습니다.\n\n```python\nadj = [\n  [2,3],\n  [3],\n  [0,3],\n  [0,1,2]\n\n]\n\ndef dfs(cur):\n  visited[cur] = True\n  for next in adj[cur]:\n    if visited[next] === False:\n      dfs(next)\n\ndef dfsAll():\n  visited = [False] * len(adj)\n  for v in range(len(adj)):\n    if not visited[v]:\n      dfs(v)\n  \n```\n\n### 시간복잡도\n\n일반적으로 모든 노드를 순환하는 것이 목표라면, \n- 인접 리스트 : $O(|V| + |E|)$\n- 인접 행렬 : $O(V^2)$ \n\n\n# Example\n\n\u003e **연결된 부분집합 갯수**\n\ndisjoint set을 통해서 구현할 수 있는 문제이지만, DFS를 통해서 쉽게 구현할 수 있습니다. 바로, 앞 서 보았던 `dfsAll`에서 `dfs`의 호출 횟수를 counting하면 값을 구할 수 있습니다.\n\n```python\n# adj = [[...], [...], ...]\n# visited = [False, False, ..]\n\ndef dfs(cur):\n  visited[cur] = True\n  for next in adj[cur]:\n    if not visited[next]:\n      dfs(next)\n\ndef dfsAll():\n  visited = [False] * len(adj)\n  cnt = 0\n  for v in range(len(adj)):\n    if not visited[v]:\n      cnt += 1\n      dfs(v)\n  return cnt\n```\n\n---\n\n\u003e **위상정렬**\n\n위상 정렬이란 directed edge(유향 간선)로 이루어진 그래프를 규칙을 깨지 않으면서 정렬하는 방식입니다. 간선이 없는 경우에는 순서가 상관없지만, 간선이 있는 경우에는 순위가 있는 형태입니다. (우선순위 : 출발점 \u003c 도착점)\n언뜻 보기에는 어려워 보이지만, DFS를 통해서 쉽게 해결할 수 있습니다. DFS를 실행하면서 끝에 지점에서 부터 배열에 저장하고 이를 역순으로 정렬하면 위상정렬이 되는 것을 볼 수 있습니다.\n\n```python\n# adj = [[...], [...], ...]\n# visited = [False, False, ..]\n\norder = []\n\ndef dfs(cur):\n  visited[cur] = True\n  for next in adj[cur]:\n    if not visited[next]:\n      dfs(next)\n  order.append(cur)\n\ndef dfsAll():\n  visited = [False] * len(adj)\n  order = []\n  for v in range(len(adj)):\n    if not visited[v]:\n      dfs(v)\n\nprint(order[::-1])\n```\n\n\u003e **오일러 서킷(한 붓 그리기)**\n\n시작 점과 끝 점이 동일할 때, 모든 경로를 지나는 길찾기입니다.\n이를 해결할 때에는 우선 다음 조건을 먼저 확인해야 합니다.\n\n- 두 개 이상의 Component로 분리된 경우 만들 수 없습니다.\n- 어느 한 점이라도 차수가 홀수이면, 만들 수 없습니다.\n\n해결책은 간단합니다. 반복적으로 Circuit(순환)을 찾아서, 최종 구조로 완성하면 됩니다.\n\n다음이 기본적인 프로세스입니다.\n1. 먼저 자신으로 시작해서 자신으로 돌아오는 순환을 먼저 찾는다.\n2. 위의 과정을 진행하고도, 아직 지나지 않은 간선을 포함한 정점이 있다면, 이를 시작점으로 하여 다시 순환을 찾을 수 있다. 이러한 정점이 없을 때까지 이를 반복해서 시행한다.\n3. 이를 최초의 순환에 붙여나가면서, 최종으로 오일러 서킷을 완성한다.\n\n1번과 2번 과정에서 만약, 순환을 찾을 수 없다면 오일러 서킷이 불가능하다는 결론을 내리고 process를 종료합니다.\n\n```python\n# adj = [[...],[...],...] (인접행렬) - 동일 간선이 여러 개 있을 수도 있음\ndef eulerCircuit(cur, circuit):\n  for next in range(len(adj)):\n    if adj[cur][next] \u003e 0:\n      adj[cur][next] -= 1\n      adj[next][cur] -= 1\n      eulerCircuit(next, circuit)\n  circuit.push_back(cur)   \n```\n\n**만약,** 시작점과 끝점이 다른 EulerTrail일 경우에는 임의로 시작점과 끝점을 잇고, Euler Circuit을 찾은 뒤에 삭제하면 됩니다.\n","slug":"dfs1","title":"DFS(1)-기본","category":"Algorithm","tags":["DFS","Graph","Tree"],"date":"2022년 2월 3일 00:00","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"\n이전에는 DFS의 기본이 되는 요소에 대해서 알아보았지만, 이제는 좀 더 심화적인 부분을 배워보고자 한다.   \nDFS가 그래프를 순회하면서 만드는 DFS Spanning Tree에 대한 내용이다.\n\n우리는 총 4가지로 간선을 분류할 수 있습니다. \n1. **Tree Edge(트리 간선)**- DFS Spanning Tree에 포함된 간선\n2. **Forward Edge(순방향 간선)** - 해당 간선이 가르키는 정점이 DFS Spanning Tree에서 자신의 descendant(후손)에 속하는 경우\n3. **Backward Edge(역방향 간선)** - 해당 간선이 가르키는 정점이 DFS Spanning Tree에서 자신의 ancestor(조상)에 속하는 경우\n4. **Cross Edge(교차 간선)** - 해당 간선이 가르키는 정점이 후손도 조상도 아닌 sibiling(형제 또는 그들의 자손)에 속하는 경우\n\n![\u003cimg src=\"/images/dfs-spanning-tree.png\" width=\"190\" /\u003e](/images/dfs-spanning-tree.png)\n\n이를 구현하기 위해서는 총 두 개의 추가적인 자료구조가 필요하다.   \n1. order[1...N] = 해당 노드의 발견 순서\n2. finished[1...N] = 모든 간선의 사용 여부\n\n```python\nadj = [\n  [1,3],\n  [2],\n  [1],\n  [1,2]\n]\nN = len(adj)\n\norder = [-1] * N\nfinished = [False] * N\ncnt = [0]\ndef dfs(curr):\n  order[curr] = cnt[0]\n  cnt[0] += 1\n  for next in adj[curr]:\n    prefix = curr + \"에서 \" + next + \"까지는\"\n    # 아직 방문하지 않았다면, 트리 간선이다.\n    if order[next] == -1:\n      print(prefix + \"트리 간선이다.\")\n      dfs(next)\n    # 만약 다음 정점의 order가 더 낮다면, 순방향 간선이다.\n    elif order[next] \u003e order[curr]:\n      print(prefix + \"순방향 간선이다.\")\n    # 만약, 다음 정점이 아직 거쳐야 하는 정점이 있다면, 역방향 간선이다.\n    elif not finished[next]:\n      print(prefix + \"역방향 간선이다.\")\n    # 그 외에는 교차 간선이다.\n    else:\n      print(prefix + \"교차 간선이다.\")\n  finished[curr] = True\n\ndef dfsAll():\n  for i in N:\n    if order[i] == -1:\n      dfs(i)\n```\n\n위와 같이 구현하게 되면, 적절하게 간선을 구분할 수 있다. 위에는 방향이 존재하는 그래프였지만, 만약 방향이 존재하지 않는 무향 그래프라면 위의 과정을 좀 더 단순화할 수 있다.\n먼저 간선은 다음과 같이 줄어든다.\n\n1. **트리 간선** = DFS Spanning Tree에 포함된 간선\n2. **중첩 간선** = DFS Spanning Tree에 포함되지 않은 간선\n\n다음과 같이 총 2개로 줄어드는 것을 볼 수 있다. 교차 간선과 역방향 간선은 기본적으로 이후에 방문하는 정점에서 이미 방문한 정점으로 이동하는 것인데 이런 일은 무향 그래프에서는 발생하지 않기 때문에 존재할 수 없다.\n그러면, 구현은 다음과 같이 진행됩니다.\n\n```python\nadj = [\n  [1,2,3],\n  [0,2,3],\n  [0,1,3],\n  [0,1,2]\n]\nN = len(adj)\n\norder = [-1] * N\n# finish는 필요하지 않다.\ncnt = [0]\ndef dfs(curr):\n  order[curr] = cnt[0]\n  cnt[0] += 1\n  for next in adj[curr]:\n    prefix = curr + \"에서 \" + next + \"까지는\"\n    # 아직 방문하지 않았다면, 트리 간선이다.\n    if order[next] == -1:\n      print(prefix + \"트리 간선이다.\")\n      dfs(next)\n    # 만약 다음 정점의 order가 더 낮다면, 중첩 간선이다.\n    # 여기서 유의해야 할 점은 바로 중첩 간선은 두 번 호출된다는 점이다.\n    # 중첩 간선이기 때문에 서로 한 번씩 호출히기 때문이다.\n    # 이를 구분하기 위해서 order를 사용할 수 있다.\n    elif order[next] \u003c order[curr]:\n      print(prefix + \"order가 높은 곳에서 낮은 곳으로 가는 중첩 간선이다.\")\n    else:\n      print(prefix + \"order가 낮은 곳에서 높은 곳으로 가는 중첩 간선이다.\")\n\ndef dfsAll():\n  for i in N:\n    if order[i] == -1:\n      dfs(i)\n```\n\n\n여기서 각 간선의 특징을 이해하면, 다른 문제를 풀기 쉽다.\n1. 역방향 또는 중첩 간선의 갯수 = circle의 갯수   \n    - 여기서 주의할 점은 바로 무향 그래프에서는 바로 직전의 방문한 정점으로 돌아가는 정점은 매번 존재하기 때문에 이는 제외해야 한다는 것을 주의하자.\n2. 무향 그래프에서 특정 정점에서 시작되는 Spanning Tree가 중첩 간선이 없다는 것은, 해당 정점을 기준으로 연결된 정점들은 실제 그래프에서도 트리 형태로 존재한다는 점(절단점)이다.\n3. 방향 그래프에서 역방향 간선과 교차 간선이 없다면, 똑같은 의미를 가진다.\n\n## 문제 풀이\nDFS 문제에서는 대게 다음과 같은 자료 구조가 많이 사용한다.   \n- visited : 방문 여부에 대한 checklist로, graph의 정점의 크기 만큼 존재한다. 초기 값은 False로 초기화한다.\n- order : 방문 순서에 대한 checklist로, graph의 정점의 크기 만큼 존재한다. 초기 값은 -1로 초기화하고, 방문 시마다 올려 주기 위해서, global variable로 cnt를 추가적으로 설정해주기도 한다.(그렇지 않으면, dfs parameter로 전달해주어야 한다.) 또한, 이를 통해서, visited 판단이 가능하기 때문에, 이를 사용할 시에는 visited의 사용을 하지 않아도 된다.\n- finished : 방향 그래프에서 해당 정점에 대한 탐색이 종료되었는지를 확인하기 위해서 사용되는 자료구조이며 graph의 정점의 크기 만큼 존재한다. 초기 값은 False로 초기화하고, dfs의 모든 정점을 방문하는 것이 끝난 경우에 이를 True로 세팅하자.\n- parent : 이는 대게 DFS를 재구조화할 때, 이 역시 graph의 정점의 크기 만큼 존재한다. 대게 경로를 다시 그려야 하는 경우에 많이 사용한다. 만약 visited도 같이 표현하고 싶으면, -2로 초기화하는 것이 좋다. 하지만, visited를 따로 사용할 것이라면, -1로 초기화해도 된다. 왜냐하면, parent -1은 dfs spanning tree의 root라는 의미를 가지는 값으로 쓰는 경우가 대부분이기 때문이다.\n\n\n### Circle 찾기\n위에서 나온 대로 Circle을 찾아나가면 됩니다. \n\n\u003e 백준 16929   \n\nhttps://www.acmicpc.net/problem/16929\n\n가장 기본적인 문제로 대놓고, Circle을 찾으라고 합니다. 유의할 점은 직전에 그쳐간 지점으로 돌아가는 것은 막아야 한다. 따라서, prev 값을 들고 가는 것을 추천한다.\n\n\u003e 백준 12946\n\nhttps://www.acmicpc.net/problem/12946\n\n응용 문제입니다. 처음에는 circle 찾기라는 것을 이해하기 어렵다. 하지만, 최대 색은 3이고, circle을 이루는 원소가 홀수인지 짝수인지를 찾는 문제로 받아들이면, 굉장히 쉽게 풀 수 있다.\n\n\u003e 백준 16947\n\nhttps://www.acmicpc.net/problem/16947\n\n가장 많이 응용되어지는 응용 예시입니다. DFS + BFS 기술을 사용해야 한다. 먼저, DFS를 통해서 Circle에 속하는 원소를 찾아내고, 해당 Circle에 속하는 원소들을 queue에 넣은 후에 거기서부터 bfs로 방문하지 않은 점을 찾아나가면 된다.\n","slug":"dfs2","title":"DFS(2)-DFS Spanning Tree","category":"Algorithm","tags":["DFS","Graph","Tree","Cycle 찾기"],"date":"2022년 4월 23일 10:30","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"## **정의**\n\n우리말로 동적 계획법이라고 번역되어지는 말입니다. 우선 명칭에 대해서 좀 어색할 수 있다. 이는 해당 어원이 오래되었기 때문입니다. 당시에 programming이란 문제 풀이를 위한 planning(계획) 정도로 생각했습니다. 따라서, **Dynamic Programming이 의미하는 바는 다단계 처리에 대한 최적화된 계획법 정도로 해석**할 수 있습니다.\n\nDynamic Programming을 사용하기 위해서는 해당 문제가 다음과 같은 조건을 만족할 때입니다.\n\n1.  **Optimal Substructure**\n2.  **Overlapping Subproblem**\n\n**Optimal Substructure**란 문제의 최적해가 이것의 하위 문제(subproblem)의 최적해에 의해서 정의되어질 수 있어야 한다는 것입니다. 쉽게 말해서 수열의 경우 점화식을 작성할 수 있어야 한다는 의미입니다. 가장 일반적인 예시가 fibonacci 수열을 예로 들 수 있습니다.\n\n$$ fibo(n) = fibo(n-1) + fibo(n-2) $$\n\n**Overlapping Subproblem**이란 문제의 하위 문제(subproblem)들이 중첩해서 사용되는 경우를 말합니다. 위의 fibonacci 수열만 보아도 fibo(100)은 fibo(101), fibo(102)를 계산하기 위해서 쓰이기 때문에 중복이 발생하며, 더 나아가 fibo(101), fibo(102)를 사용하는 경우에는 fibo(100)을 다시 계산해야 합니다. 이것은 굉장한 비용을 초례합니다.\n\n이러한 문제들에 대한 해결책으로써 Dynamic Programming에서는 점화식을 이용해서 문제를 해결하지만, 이때, 한 번 계산한 값을 두 번 계산하지 않도록 하는 것입니다. **이를 가능하게 하는 것이 Memoization(함수의 실행 결과를 저장)입니다.** 즉, 이전에 호출한 함수의 결과값을 별도의 저장 공간(array, list, map, file 등)에 저장해두는 것입니다. 이를 통해서 우리는 problem의 subproblem이 이미 계산된 적이 있다면, 하위 문제를 다시 풀 필요없이 바로 solution(점화식)을 계산할 수 있는 것입니다. 이를 통해서, **계산 시간을 획기적으로 줄일 수 있습니다. 하지만, 추가적인 memory를 사용한다는 점을 반드시 기억해야 합니다.**\n\n여기서 계속해서 반복 및 교체되어 사용되는 단어가 점화식, solution, optimal substructure, function, 함수입니다. 이는 모두 같은 뜻을 가지는데, 여기서도 특히 함수는 **referential transparency**를 보장하는 함수만을 지칭합니다. 수학에서는 아주 당연한 얘기이지만, input값이 동일할 때 항상 같은 output을 내놓아야 한다는 것입니다. programming에서의 함수는 대게 side effect가 존재할 수 있고, 외부 변수를 사용하기도 하므로, 같은 input이라도 상황(context)에 따라 다른 output이 발생할 수도 있는데 이러한 것이 해당 함수에서는 발생해서는 안된다는 것입니다.\n\n---\n\n## **구현**\n\n기본적으로 Dynamic Programming을 적용하기 위해서는 반드시 위에서 언급한 두 조건을 만족하는지를 확인해야 합니다. 따라서, 먼저 점화식을 찾아내고, 이것이 반복 사용되는지를 반드시 확인한 후에 적용하는 것이 기본입니다.\n\nDynamic Programming의 기본적인 구현 방식은 두 가지가 존재합니다. 둘 다 장단점이 있기 때문에 이것에 유의하여 사용해야 합니다.\n\n따라서, 아래에서는 가장 기본적인 예시로 combination을 구하는 방식을 두 가지 방식으로 구현하겠습니다. 일단 Combination은 다음과 같은 점화식을 만족합니다.\n\n$$ {{}_{n}C_{k}} = {{}_{n-1}C_{k-1}} + {{}_{n-1}C_{k}}$$\n\n따라서, 이를 Dynamic Programming을 통해서 구현할 수 있습니다.\n\n### **1\\. Top Down(=Recursive)**\n\n 먼저 input으로 들어올 데이터의 크기를 고려하여, cache list의 크기를 지정합니다. 그 후에 점화식을 함수 내에서 나타내고, 해당 함수값을 return해주면 됩니다. 이때 중요한 것이 이미 함수값을 계산한 적이 있는지를 확인하고 있다면, 바로 return해버리는 점입니다.\n\n```python\nsize = 100\n# 1차원 배열\ncache = [-1] * size\n\n# 2차원 배열\ncache = [[-1 for _ in range(size)] for _ in range(size)]\n\n# 기저값 세팅\ncache[0][0] = 1\ncache[1][0] = 1\ncache[1][1] = 1\n\n# 함수 지정\ndef recursive_call(a, b):\n    # 이미 저장된 값이 있는 경우 return\n    if cache[a][b] != -1:\n        return cache[a][b]\n    # 없다면, 연산 및 저장 후 return\n    cache[a][b] = cache[a-1][b-1] + cache[a-1][b]\n    return cache[a][b]\n    \nprint(recursive_call(10, 2))\n```\n\n해당 방식의 가장 큰 장점은 이해하기 쉽다는 것입니다. 점화식이 분명하게 들어나며, 값을 찾아가는 과정을 상상하는 것이 쉽습니다. 또한, 모든 경우의 수를 탐색하지 않을 수 있다는 점이 있습니다. 왜냐하면, 연관된 데이터만 찾기 때문에 관련 없는 데이터는 찾지 않을 수도 있습니다. **하지만,** recursive call인 만큼 함수 호출의 최대 횟수가 정해져있어, 모든 경우에 올바른 답을 찾지는 못합니다. 이를 해결하기 위해서 끊어서 실행 시켜두는 방법도 있습니다. 예를들어 200을 구하는 문제면, 50, 100, 150을 미리 호출해둡니다. 하지만, 이 또한, 매번 적용할 수 있는 방법은 아니기에 대다수의 경우에는 Bottom Up으로 구현하는 것을 추천합니다.\n\n### **2\\. Bottom Up(with Loop)**\n\n위와 똑같은 원리를 이용해서 구현한 Combination입니다. for문을 이용해서 처음부터 끝까지 구하면서 올라가는 방식입니다. 이렇게 하게 되면, 빈틈없이 아래부터 계산하는지를 체크하면서 구현해야합니다. 중간에 빈값이 발생하는 경우가 없도록 하는 것이 중요합니다.\n\n```python\nsize = 100\n# 1차원 배열\ncache = [-1] * size\n\n# 2차원 배열\ncache = [[-1 for _ in range(size)] for _ in range(size)]\n\n# 기저값 세팅\ncache[0][0] = 1\ncache[1][0] = 1\ncache[1][1] = 1\n\n# 함수 지정\nfor i in range(2, size):\n\tfor j in range(0, i+1):\n    \tcache[i][j] = cache[i-1][j-1] + cache[i-1][j]\n    \nprint(cache[10][2])\n```\n\n---\n\n## **문제 풀이**\n\n모든 Dynamic Programming 문제를 풀기 위해서 거쳐야 하는 단계는 총 3단계입니다.\n\n1.  **문제를** **정의**한다.\n2.  **점화식**을 찾는다.\n3.  **시간 복잡도**를 만족하는지 확인한다.\n4.  **공간 복잡도**를 만족하는지 확인한다.\n\n문제를 정의하고, 점화식을 찾을 때에 나타나는 대략 4가지 유형을 나누어 보았습니다. 제가 만든 분류기준이니 공식적이지는 않습니다.\n\n#### **1\\. 자신의 Subproblem으로만 표현되는 유형**\n\n**A = operate(sub A, sub A)와** 같은 형태로 나타나는 경우를 말한다. 이 경우에는 문제의 재정의가 필요없이 바로 점화식을 작성하면 됩니다. 이런 유형의 문제가 위에서 살펴보았던 combination, fibonacci가 대표적입니다. 가장 기본적인 예시를 풀어봅시다.\n\n\u003e **백준 11726**  \n\n\\*문제를 읽고 오시기 바랍니다.\n\n[11726번: 2×n 타일링](https://www.acmicpc.net/problem/11726)\n\n먼저 이 문제는 2xN 평면에 타일을 채울 수 있는 경우의 수를 찾는 것이 목표입니다.\n\n따라서, $cache[n] = \\text{2xN을 채울 수 있는 경우의 수}$라고 정의하겠습니다.\n\n또한, 규칙을 찾아보면 해당 값은 다음과 같은 pattern을 가진다는 것을 알 수 있습니다. \n\n\n![\u003cimg src=\"/images/tile_2_1.jpeg\" width=\"190\" /\u003e](/images/tile_2_1.jpeg)\n\nf(n)의 처음 시작을 세로 block으로 시작하면, 다음 block들의 경우의 수는 모두 이전에 구한 경우의 수와 같고, 처음 block을 가로 block으로 설정하면, 위에 block을 놓으면 아래도 가로로 놓는 것이 강제됩니다. 따라서, 가로로 위 아래를 두는 수 밖에 없고, 이렇게 두면 이전전에 두었던 것과 동일한 형태로 놓는 경우의 수만큼의 경우를 갖게 됩니다. 따라서, 결론상 현재의 block의 경우의 수는 이렇게 두 개의 경우의 수의 합으로 정의할 수 있는 것입니다.\n\n\u003e 관련 유형 : 1463, 11727, 11052, 16194, 15988, 1699, 2193\n\n#### **2\\. 문제의 재정의가 필요한 유형**\n\n**A = operate(B), A' = operate(sub B, sub B)와** 같은 형태로 나타나는 경우를 말한다. 이와 같은 유형은 기존에 제시된 문제에 특정 조건을 추가하여, 최종값을 구한 후에 이를 이용해서 답을 구하는 방식입니다. 이 경우에는 문제를 다시 정의해야 하기 때문에 다소 어려울 수 있습니다. 쉬운 예제부터 풀어보겠습니다.\n\n\u003e **백준 1912**\n\n[1912번: 연속합](https://www.acmicpc.net/problem/1912)\n\n이 문제는 점화식으로 나타기가 어렵습니다. 따라서, 약간 문제를 바꾸어서 나타내야 합니다. 수열을 A라 하고, 수열의 i번째 원소를 A[i]라고 할 때, A[i]를 마지막 연속 합의 값으로 했을 때, 최댓값을 S[i]라고 합시다. 이 경우에 이전의 연속합이 음수인 경우는 오히려 값이 낮아지기 때문에 이때는 A[i]를 반환하고, 그렇지 않은 경우에는 S[i-1]에 A[i]를 더해서 연속합을 구하면 됩니다. 따라서 다음과 같은 형태가 됩니다.\n\n$$ \n\\begin{align} \n  S[i] \u0026= S[i-1] + A[i] (\\text{if } S[i-1] \u003e 0) \\\\\n  \u0026= A[i] \n\\end{align} \n$$\n\n와 같은 형태로 나타낼 수 있습니다. 이를 이용해서, S 중에서 가장 큰 값을 찾으면, 그것이 답이 됩니다. 여기서 S가 cache와 같은 역할입니다.\n\n\u003e 관련 유형 : 11053, 2225\n\n#### **3\\. Problem의 Subproblem과 다른 Subproblem이 연계되는 유형**\n\n**A= operate(sub A, sub B), B = operate(sub A, sub B)와** 같은 형태로 나타나는 경우를 말합니다. 이와 같은 유형은 두 개 이상의 subproblem이 서로 연계되기 때문에 이들을 동시에 연산하면서, 진행해야 합니다. 일반적으로는 이중 배열을 이용해서 수행하는 것이 일반적입니다. 이런 내용들을 대게 문제에서 제약사항이 있는 문제에 많이 사용됩니다. 예제를 보면 쉽게 이해가 됩니다.\n\n\u003e **백준 2133**\n\n [2133번: 타일 채우기](https://www.acmicpc.net/problem/2133)\n\n앞 서 풀었던 2xn 타일 문제와 똑같지만, 3xn으로 바뀌었을 뿐이다. 이번에도, 앞에서 부터 한 번씩 경우의 수를 따져보는 것이 중요하다. 먼저 세로를 넣은 경우에는 아래에 가로가 하나 강제되는 것을 볼 수 있다. 그리고, 가로로 넣은 경우에는 세로로 세우거나 가로로 세우는 것을 볼 수 있다. 따라서, 3가지의 경우의 수로 볼 수 있다. 하지만, 우리가 구하고자 하는 모양과는 다른 모양의 조각이 남는 것을 볼 수 있다. 따라서, 우리가 구하고자 하는 것(3xn을 채우는 경우의 수)을 cache[n][0]이라 하고, 그를 위해 부가적으로 해결해야 하는 문제(밑변이 n이고, 윗변은 n-1, 좌는 2, 우는 3인 도형을 채우는 경우의 수)를 cache[n][1]이라고 하자.\n\n그렇게 하면 아래와 같은 점화식을 얻을 수 있다.\n\n![\u003cimg src=\"/images/tile_3_1.jpeg\" width=\"190\" /\u003e](/images/tile_3_1.jpeg)\n\n하지만, 다른 부가적인 문제에 대한 점화식을 세우지 못했기 때문에, 이에 대한 점화식도 찾아주어야 한다. 왼쪽에 세로를 채우게 되는 경우와 가로를 바로 채우는 경우가 있을 것이다. 해당하는 경우는 각 각 다음과 같이 묘사되고, 점화식도 동일하게 얻을 수 있다.\n\n![\u003cimg src=\"/images/tile_3_2.jpeg\" width=\"190\" /\u003e](/images/tile_3_2.jpeg)\n\n이제 이를 반복해서 풀어나가면 쉽게 답을 구할 수 있다.\n\n이런 식으로 하나의 subproblem을 풀기 위해서 연계되는 subproblem이 생기는 유형도 존재한다.\n\n\u003e  관련 유형 : 11054, 13398, 1309, 2156, 1149\n\n#### **4\\. 동적계획법을 통해서 얻은 결과값을 추적하는 유형**\n\n해당 유형은 상당히 간단하게도 parent라는 별도의 list를 만들어서 구현할 수 있다. 즉, cache의 값을 갱신해줄 때 영향을 준 subproblem의 index를 저장해두는 것이다. 이를 통해서 해당 값이 어디서부터 유래되었는지를 후에 추적하는 것이 가능하다.\n\n\u003e **백준 14002**\n\n [14002번: 가장 긴 증가하는 부분 수열 4\n\n수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오. 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이\n\nwww.acmicpc.net](https://www.acmicpc.net/problem/14002)\n\n유형 2와 동일한 풀이로 풀 수 있는 문제이다. 만약, cache값을 수정하는 연산이 발생하면, parent를 변경하면 된다.\n\n---\n\n위에 언급한 모든 풀이는 해당 Github에 존재합니다.\n\n[GitHub - euidong/BOJ: 백준 알고리즘 문제 풀이](https://github.com/euidong/BOJ)","slug":"dynamic-programming","title":"Dynamic Programming","category":"Algorithm","tags":["Dynamic Programming","BOJ2133","BOJ11726","BOJ14002","BOJ1912","Memoization","Optimal Structural","Overlapping Subproblem","Referential Transparency"],"date":"2022년 4월 14일 13:51","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"여러 개의 Vertex(정점)와 그를 잇는 Edge(간선)로 이루어진 형태의 자료 구조를 의미한다. \n\n## 핵심 종류\n- 무향 그래프: 방향이 없이 선으로 이어진 그래프\n- 방향 그래프: 방향을 가진 그래프로 한 정점에서 다른 정점으로 가는 방향을 명시한 그래프\n- 가중치 그래프: 각 간선이 가중치를 가지는 형태를 그래프\n- 이분 그래프: 정점을 두 개의 그룹으로 나누었을 때, 각 그룹은 서로 연결되지 않은 점들로만 이루어지는 그래프\n- **방향 비순환 그래프(Directed Acyclic Graph(DAG))**: 어느 정점에서 시작해도 cycle(순환)이 존재하지 않는 형태의 그래프. 이 그래프 형태에 tree(트리)도 해당되며, 이것이 특별한 이유는 선형으로 정렬하는 것이 가능하기 때문이다. ([DFS_위상정렬 참고](/post/DFS))\n\n## Dense vs Sparse\n그래프 관련 문제를 해결할 때, 반드시 고려해야 할 점은 해당 그래프가 Dense(밀도가 높은, edge가 많은)한 경우와 Sparse(희귀한, edge가 적은)한 경우를 모두 고려해주어야 한다. 이에 따라서, 시간복잡도가 굉장히 천차만별하게 나타나기 때문이다.\n\n\n## 표현 방법\n1. adjacent list(인접 리스트)   \n  각 정점마다 해당 정점에서 나가는 간선의 목록을 저장해서 그래프를 표현하는 법\n  ```python\n  import sys\n  # N = 정점의 수, M = 간선의 수\n  N, M = [int(i) for i in sys.stdin.readline().split()]\n  adj = [[] for _ in range(N)]\n  for _ in range(M):\n    a, b = [int(i) for i in sys.stdin.readline().split()]\n    adj[a].append(b)\n    # 무향 그래프에서는 다음과 같이 반대 방향도 추가해주어야 한다.\n    adj[b].append(a)\n  ```\n2. adjacent matrix(인접 행렬)   \n  인접 리스트 방식의 단점은 특정 두 정점이 연결 되었는지를 알기 위해서는 해당 정점과 연결된 모든 정점을 확인해야 한다. 인접 행렬에서는 이를 해결할 수 있다. 연결 여부를 직접 2차원 $V \\times V$ 행렬로 나타내기 때문에 이를 바로 index 조회로 알 수 있다. **하지만,** 메모리를 더 잡아 먹을 수도 있고, 단순히 연결된 정점만 조회하는 연산일 경우에는 오히려 모든 정점을 조회해야 하기 때문에 비용이 증가할 수 있다. (Sparse한 graph일 수록 비용 증가가 크다.)\n  ```python\n  import sys\n  # N = 정점의 수, M = 간선의 수\n  N, M = [int(i) for i in sys.stdin.readline().split()]\n  adj = [[0 for _ in range(N)] for _ in range(N)]\n  for _ in range(M):\n    a, b = [int(i) for i in sys.stdin.readline().split()]\n    adj[a][b] += 1\n    # 무향 그래프에서는 다음과 같이 반대 방향도 추가해주어야 한다.\n    adj[b][a] += 1 \n  ```","slug":"graph","title":"Graph","category":"Algorithm","tags":["자료구조","Graph"],"date":"2022년 4월 20일 12:00","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"\nlist를 갖고 놀 수 있는 능력은 python으로 알고리즘을 풀기 위해서 굉장히 중요한 기술이다.\n여기서는 기본적인 방법에서부터 어떻게 배열을 제대로 갖고 놀 수 있는지를 알아볼 것이다. 여기서는 Python을 활용하지만, 알고리즘 풀이를 목표로 하기 때문에 numpy를 활용하지 않는 방법을 소개합니다. 물론 numpy를 이용하면, 훨씬 쉽게 구현할 수 있습니다.\n\n## 선언\n\npython에서는 list를 통해서 데이터를 모읍니다. 또한, list라는 type 자체가 예약어이기 때문에 아래부터는 arr를 통해서 `list`를 표현합니다.\n\n```python\n# 비어 있는 1차원 배열\narr = []\n\n# 꽉 찬 1차원 배열\nN = 100\narr = [0] * N\n\narr = [0 for _ in range(N)]\n\n# 비어 있는 2차원 배열\narr = [[]]\n\n# 꽉 찬 2차원 배열\nN = 100\nM = 100\n\narr = [[0 for _ in range(M)] for _ in range(N)]\n```\n\n여기서 유의해야할 점은 2차원 배열에서 꽉 찬 배열을 만들기 위해서 반드시 for 문을 통해서 생성해야 한다는 것이다. 1차원 배열을 생성할 때 사용했던 곱하기 연산을 통한 배열의 요소 복사는 불가능하다. (ex, `[[0] * M] * N`, `[[0] * M for _ in range(N)]`) 왜냐하면, **reference로** 복제되기 때문이다.\n\n## 순환\n\npython의 가장 기본적인 순환 방법은 `for element in arr` 구문을 이용하는 것이다. 이를 기본적으로 사용하면서, 사용하기에 유용한 순환 방법은 다음과 같은 것들이 있다.\n\n```python\n# (1)\nfor element in arr:\n  print(element)\n\nfor idx in range(len(arr)):\n  print(arr[idx])\n\n# (2)\nwhile len(arr) \u003e 0:\n  element = arr.pop(0)\n  print(element)\n\n# (3)\nlist(map(lambda x: x**2, arr))\n\nfrom functools import reduce\nreduce(lambda acc, cur: acc + cur, arr, 0)\n\nlist(filter(lambda x: x == 1, arr))\n\n# (4)\narr = []\n\ndef call(idx):\n  if len(arr) \u003c= idx:\n    print(arr[idx])\n    return\n  call(idx+1)\n  print(arr[idx])\n```\n\n1. 가장 기본적인 순환 방식이다. 일반적으로 foreach라고 부른다.   \n  이 방식은 대게의 경우 효율적이다. 하지만, 사용에 유의해야할 때가 있다. 바로, 내부 element의 추가,삭제가 발생하는 경우이다. 따라서, 반드시 내부에서는 순환 중인 배열에 대한 추가 및 삭제 연산을 수행하지 않도록 하자.\n2. 대게, queue를 순환하는 경우에 많이 사용되게 되는 형태이다.   \n  이 경우는 추가, 삭제가 발생할 때에도 안정적으로 동작하도록 할 수 있다.\n3. 이는 위에서 보았던 foreach 형태에서 내부 변수의 변경을 강제로 막을 수 있는 방식이다.   \n  이런 식으로 구현하는 것도 에러를 줄이는데에 좋다. 주의해야할 것은 기존 arr와 새로 생기는 arr의 크기가 동일하기 때문에 이에 유의해야 한다.    \n  reduce는 반드시 import가 필요하기 때문에 번거롭지만, 배열의 크기를 바꿀 수도 있고, 누적을 수행하는 경우 유용하다.    \n  filter를 통해서, 특정 데이터를 filtering 할 때 사용할 수 있다.\n4. 재귀함수의 특징인 call stack을 활용해서 순환하는 방식이다. 이런 식으로 그래프를 순환한다면, 그것이 DFS이다.\n\n\n## 자르기\n\npython의 장점 중 하나가 자르기(slicing)가 매우 쉽다는 것이다.\n배열 내부에 `:`을 통해서 시작점(start index), 끝점(end index), 그리고 순서(order)를 명시하는 방식으로 배열을 쉽게 변환하는 방법을 제공한다.\n또한, 이 방식을 사용해도, 기존의 list는 변형되지 않고, 잘라진 list를 반환한다는 것을 기억하자.\n\n### 1차원 자르기\n```python\narr = [1,2,3,4,5]\n\narr[1:3:1] # [2,3]\narr[1:3] # [2,3] \u003c-- 생략 시 순서는 기본적으로 1\n\narr[1:5] # [2,3,4,5]\narr[1:] # [2,3,4,5] \u003c-- 생략 시 끝점은 기본적으로 가장 끝점\n\narr[0:] # [1,2,3,4,5]\narr[:] # [1,2,3,4,5] \u003c-- 생략 시 시작점은 기본적은 가장 첫점\n```\n\n### 2차원 자르기\n2차원 배열을 자르는 것은 numpy를 사용하지 않는다면, 어쩔 수 없이 for문을 작성해서 잘라주어야 한다.\n\n```python\narr = [\n  [1,2,3,4],\n  [5,6,7,8],\n  [9,10,11,12],\n  [13,14,15,16]\n]\n\n# arr의 a[0~2][0~2]를 가져오고 싶다고 하자.\nsliced_arr = [line[:2] for line in arr[:2]]\n```\n\n물론 `arr[:2][:2]` 이런식으로 쓰고 싶겠지만, 이를 수행하면, arr을 [:2] slicing한 결과물 `[[1, 2, 3, 4], [5, 6, 7, 8]]`을 다시 slicing하여 동일하게 `[[1, 2, 3, 4], [5, 6, 7, 8]]`가 나오게 된다. 따라서, 위와 같이 for문을 이용하는 형식으로 바꿔주는 것이 일반적이다.\n\n\n## 복제\n기본적으로 복제는 두 가지 종류가 존재한다. 하나는 대상 자체를 모두 복사하는 것이고, 하나는 사실상 해당 배열에 또 다른 이름을 붙여주는 것이다.\n기본적으로 우리가 다음과 같이 하면 변수가 복제되기 때문에 배열도 똑같이 복사될 것이라고 생각하지만 실상은 그렇지 않다.\n```python\n# (1)\na = 3\nb = a\n\n# (2)\narr = [1,2,3,4,5]\ncopy = arr\n```\n일반 변수에 `=` 연산을 사용한다면, 값을 복사하여 target에게 대입해주는 것이 맞다. 하지만, 배열에서는 변수가 가르키는 것은 배열이 존재하는 주소를 가르킨다. 즉, `arr`이라는 구역에 변수가 있는 것이 아니라 변수가 있는 주소를 가지고 있는 것이다. 따라서, 우리가 `=` 을 통해서 `copy`에게 대입해주면, `copy`는 단지 `arr`과 똑같은 주소지를 가르키고 있는 것일 뿐이다. 물론 이렇게 되어도 크게 문제가 되지 않는 경우가 있다. `copy`와 `arr` 모두 절대 변경되지 않을 것이라는 확신하거나 해당 행위 자체를 의도한 경우이다. 하지만, 대게의 경우에는 원본이 회손되기를 원하지 않기 때문에 우리는 별개의 list를 생성하는 방법을 알고 있어야 한다. python에서는 이를 위해 slicing을 이용하는 것이 일반적이다.\n```python\n# 1차원 배열\narr = [1,2,3,4,5]\ncopy = arr[:] \n\n# 2차원 배열\narr = [\n  [1,2,3,4],\n  [5,6,7,8],\n  [9,10,11,12],\n  [13,14,15,16]\n]\ncopy = [line[:] for line in arr]\n```\n2차원을 복사할 때에도 `arr[:]`을 쓰고 싶겠지만, 이렇게 하게 되면, 내부에 있는 배열은 모두 주소를 복사하는 것이기 때문에 똑같은 별명을 붙여주는 것과 똑같이 동작한다.\n\n## modulo\n\nlist에서는 modulo 연산이 중요하다. 애초에 배열의 index가 0에서 시작하는데, 이것은 modulo 공간에서의 가장 큰 특징이기도 하다. 만약, 우리가 특정 배열을 반복해서 시계방향, 반시계방향 처럼 순환할 일이 생긴다면, modulo 연산을 반드시 기억해야 한다.\n```python\narr = [1,2,3,4,5]\nidx = 0\nwhile True:\n  print(arr[(idx) % len(arr)])\n  idx+=1\n```\n\n## 반전\n\n이전에 보았던 slicing의 응용을 통해서 쉽게 반전이 가능하다.\n```python\n# 1차원 배열\narr = [1,2,3,4,5]\nreversed_arr = arr[::-1]\n\n# 2차원 배열\narr = [\n  [1,2,3,4],\n  [5,6,7,8],\n  [9,10,11,12],\n  [13,14,15,16]\n]\n\n# 좌우 반전\nreversed_arr = [line[::-1] for line in arr]\n# 상하 반전\nreversed_arr = [line[:] for line in arr[::-1]]\n```\n\n## 회전\n회전은 2차원 배열에서만 의미있으므로, 해당 연산만 다룹니다.\n회전은 총 두 가지 종류가 있을 수 있다. \n\u003e **1. 시계 또는 반시계 방향으로 1칸 이동하는 연산**   \n\n```python\narr = [\n  [1,2,3,4], \n  [5,6,7,8], \n  [9,10,11,12], \n  [13,14,15,16],\n  [17,18,19,20],\n  [21,22,23,24]\n]\nN = len(arr)\nM = len(arr[0])\n\n# 시계 방향\n# 시계 방향 이동 시의 이동 정도\ndy = [0, 1, 0, -1]\ndx = [1, 0, -1, 0]\n\nrotated_arr = [[-1 for _ in range(M)] for _ in range(N)]\nfor i in range(min([N, M]) // 2):\n  cursor = (i, i+1)\n  prev = (i, i)\n  rotated_arr[i][i] = arr[i+1][i]\n  d = 0\n  while True:\n    y = cursor[0] + dy[d]\n    x = cursor[1] + dx[d]\n    if -1 + i \u003c y \u003c N - i and -1 + i \u003c x \u003c M - i:\n      rotated_arr[cursor[0]][cursor[1]] = arr[prev[0]][prev[1]]\n      prev = (cursor[0], cursor[1])\n      cursor = (y, x)\n    else:\n      d += 1\n      if d == 4:\n        break\n\n# 반시계 방향\n# 반시계 방향 이동 시의 이동 정도\ndy = [1, 0, -1, 0]\ndx = [1, 0, 0, -1]\n\nrotated_arr = [[-1 for _ in range(M)] for _ in range(N)]\nfor i in range(min([N, M]) // 2):\n  cursor = (i+1, i)\n  prev = (i, i)\n  rotated_arr[i][i] = arr[i][i+1]\n  d = 0\n  while True:\n    y = cursor[0] + dy[d]\n    x = cursor[1] + dx[d]\n    if -1 + i \u003c y \u003c N - i and -1 + i \u003c x \u003c M - i:\n      rotated_arr[cursor[0]][cursor[1]] = arr[prev[0]][prev[1]]\n      prev = (cursor[0], cursor[1])\n      cursor = (y, x)\n    else:\n      d += 1\n      if d == 4:\n        break\n```\n\n예제 - [백준 16926](https://www.acmicpc.net/problem/16926)   \n\n\n\u003e**2. $90^{\\circ}$, $180^{\\circ}$, $270^{\\circ}$ 회전 연산**      \n\n해당 연산의 keypoint는 연산이 점화식 형태로 표현된다는 점이다. (A=After, B=Before, size=(NxM))\n- $90^{\\circ}$ : `A[i][j] = B[j][N-1-i]`\n- $270^{\\circ}$ : `A[i][j] = B[M-1-j][i]`\n- $180^{\\circ}$ : `A[i][j] = B[N-1-i][M-1-j]`\n\n```python\narr = [\n  [1,2,3,4], \n  [5,6,7,8], \n  [9,10,11,12], \n  [13,14,15,16],\n  [17,18,19,20],\n  [21,22,23,24]\n]\nN = len(arr)\nM = len(arr[0])\n\n# 90도\nrotated_arr = [[-1 for _ in range(N)] for _ in range(M)]\nfor i in range(M):\n  for j in range(N):\n    rotated_arr[i][j] = arr[N-1-j][i]\n\n# 270도\nrotated_arr = [[-1 for _ in range(N)] for _ in range(M)]\nfor i in range(M):\n  for j in range(N):\n    rotated_arr[i][j] = arr[j][M-1-i]\n\n# 180도\nrotated_arr = [[-1 for _ in range(M)] for _ in range(N)]\nfor i in range(N):\n  for j in range(M):\n    rotated_arr[i][j] = arr[N-1-i][M-1-j]\n```\n\n예제 - [백준 20327](https://www.acmicpc.net/problem/20327)","slug":"list","title":"List 갖고 놀기","category":"Algorithm","tags":["List","Python","순환","복사","자르기","반전","회전"],"date":"2022년 4월 26일 21:10","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"\n우리가 자료를 저장하기 위해서는 여러가지 방법이 필요하다. 그 중에서도 연관성을 가지는 데이터를 정리하는 경우에는 선형적인 list만으로는 너무나 부족할 수도 있다. 하지만, Graph를 이용하기에도 데이터의 양이 방대해지고, 규칙이 없기 때문에 원하는 데이터를 찾는 연산에서 많은 시간을 소모하게 된다.\n\n따라서, 보다 규칙적인 형태를 가지면서, 각 지점간의 관계를 가지고, 더 안정적인 구조를 찾기 위해서 고안된 것이 트리이다.\n\n트리(tree)란 그래프의 일종으로, 하나의 정점(root) 자체를 의미하거나 또 다른 독립된 (sub)트리를 directed edge(방향 간선)를 이용해서 연결한 자료구조를 말한다.\n\n![Tree's Recursive form](/images/tree1.jpeg)\n\n\n언뜻 보기에 굉장히 추상적인 표현일 수 있지만, 위와 같은 **재귀적 정의**를 기억하는 것도 많은 도움이 된다.\n\n이를 좀 더 쉽게 설명하자면, 기본적으로 트리는 방향을 가진 간선으로 이루어진 그래프에서 다음과 같은 요소를 가지고 있을 경우를 트리라고 말한다.\n1. 루트(root)라는 다른 정점을 가진다.\n2. 루트를 제외한 모든 정점은 해당 정점으로 가는 간선(edge)이 단 하나이다.\n3. 그렇기에 루트에서 모든 정점으로 연결되는 간선들의 경우의 수도 단 하나이다.\n\n![Tree's Normal form](/images/tree2.jpeg)\n\n이를 이해했다면, 앞 서 살펴보았던 재귀적 정의도 이해가 되었는지 다시 한 번 확인하고 가자.\n\n**위와 같이 트리에서 루트에 연결된 서브 트리는 마치 하나의 독립적인 바구니라고 볼 수도 있다.** 트리에서는 연결된 subtree가 서로 독립적이기 때문에, 독립적인 바구니에 담는 규칙을 마음대로 정하여 독립적인 특징이 있는 데이터를 **분류**하기에 적절한 구조를 가지고 있다.\n\n## 용어\n\n- 깊이(depth) : 트리의 최대 높이를 의미한다. 대게 루트의 높이를 0으로 보기 때문에 노드가 2개라면, 깊이가 1인 걸로 본다. 하지만, 이는 구현자의 마음에 따라 다르게 구현할 수 있다.\n- 부모(parent) : 특정 정점을 기준으로 자신을 가르키는 간선을 가진 정점을 말한다. 즉, 트리의 구조에서 상위에 있는 노드라고 할 수 있다.\n- 자식(child) : 특정 정점을 기준으로 자신에서 출발하는 간선에 연결된 정점을 말한다. 즉, 트리의 구조에서 하위에 있는 노드라고 할 수 있다.\n- 조상(ancestor) : 특정 정점을 기준으로 자신으로 오는 경로가 존재하는 정점을 말한다. 즉, 트리의 구조에서 부모에서 부터 루트까지에 경로의 모든 노드가 이에 포함된다.\n- 루트(root) : 부모가 없는 최상단의 정점을 의미한다.\n- 리프(leaf) : 자식이 없는 최하단의 정점들을 의미한다.\n- 서브트리(subtree) : 트리의 각 정점은 해당 정점을 루트로 하는 트리라고 볼 수 있다. 이러한 본래 트리에 존재하는 내부 트리를 서브트리라고 한다.\n\n\n## Binary Tree\n  \n모든 정점의 자식의 크기가 2 이하로 정해진 트리를 이진 트리(Binary Tree)라고 한다.\n- Skewed Binary Tree    \n  이진 트리에서 같은 depth에 있는 정점이 단 하나 밖에 없는 경우를 말한다. 마치 Linked List와 같은 형태이다. 이는 트리의 목적 중 하나인 분류라는 기능을 적절히 수행하지 못하는 형태이기 때문에 대게 좋지 않은 형태로 본다.\n\n![skewed tree](/images/skewed-tree.png)\n\n- Balanced Binary Tree   \n  균형 잡힌 이진 트리로 좌우의 depth가 최대 1까지만 차이가 나는 경우를 의미한다.\n\n![balanced tree](/images/balanced-tree.png)\n\n- Full Binary Tree   \n  정점이 가질 수 있는 자식의 수가 0 아니면 2로 제한되는 형태의 이진 트리를 의미한다. 그렇기에 기본적으로 균형 잡힌 형태의 트리가 생길 수 밖에 없다.\n\n![full tree](/images/full-tree.png)\n\n- Complete Binary Tree   \n  균형잡힌 트리이면서 정점이 반드시 왼쪽부터 채워지는 트리를 말한다. 해당 트리의 가장 큰 특징은 이를 Array로 표현하기에 최적화되어있다는 점이다. 이는 후에 있을 **구현법** 파트에서 더 자세히 알아본다. 따라서, Complete Tree를 기억하고 가자.\n\n![complete tree](/images/complete-tree.png)\n\n- Perfect Binary Tree   \n  Complete Tree와 가장 혼돈되는 개념이다. 이는 모든 이진 트리가 빈틈없이 꽉 채워진 경우를 말한다. 즉, leaf 노드의 자식의 갯수가 모두 0일 때이다.\n\n![perfect tree](/images/perfect-tree.png)\n\n## 속성\n\n해당 속성은 정의에 의해서 파생되는 내용이다. 직접 상상해서 왜 안되는지를 생각해보자.\n\n- 루트에 연결된 subtree 간에는 간선이 존재하지 않는다.\n- Cycle이 존재하지 않기 때문에, Graph의 종류 중 하나인 DAG에 속한다.\n- 정점과 정점 사이의 경로가 있다면, 해당 경로는 유일한 경로이다.\n- 형제 노드로 이동할 수 있는 방법은 존재하지 않는다.\n\n## 구현법\n\n트리는 표현하기 위해서 대표적으로 두 가지를 사용한다. 리스트를 이용한 구현 방법과 구조체(or Class)를 이용한 구현이다.\n\n### 1. 구조체\n\n일반적으로 가장 널리 사용하는 방법이다. 먼저 Tree라는 구조체(or Class)를 정의한다.\n```python\nclass Tree:\n  def __init__(self, value, subtrees):\n    self.root = value\n    self.subtrees = subtrees\n    # 필요에 따라서, 부모의 정보가 필요한 경우에는 parent를 저장할 수도 있다.\n```\n\n이진 트리에 경우에는 단 두 개의 subtree로 정해져있기 때문에 아래와 같은 형태를 빈번히 사용한다.\n\n```python\nclass Tree:\n  def __init__(self, value, left, right):\n    self.root = value\n    self.left = left\n    self.right = right\n```\n\n이를 통해서 각 Tree type의 변수는 모두 루트 값과 subtree들을 포함하게 된다.\n\n### 2. 리스트\n\n트리의 각 정점의 유일한 특징을 이용하여 표현한다. depth와 왼쪽에서부터 몇 번째 인지를 나타내는 index를 같이 사용하면, 정점의 위치를 특정하여 표현할 수 있다. \n따라서, 다음과 같은 식으로 Tree의 정점을 표현하는 것이다.\n\n만약, 이진 트리와 같은 경우에는 아래와 같은 식으로 해당 노드가 어느 곳에 존재하는지를 찾을 수 있다.\n\n1. $\\text{tree}[2^{i} + j] = $ depth가 i이고, 왼쪽에서 j만큼 떨어진 정점이 지닌 값\n2. $\\text{tree}[i]$의 자식은 $\\text{tree}[i \\times 2]$ 또는 $\\text{tree}[i \\times 2 + 1]$이다.\n\n![tree-to-list](/images/tree-to-list.jpeg)\n\n이때 반드시 주의할 점은 시작 점은 0이 아니라 1이 되도록 해야한다는 점입니다. \n\n이는 트리의 노드의 수가 제한되어 있는 경우에만 사용할 수 있으며, 효율적으로 사용하기 위해서는 최대한 Complete Tree형태를 갖추어야 한다. 왜냐하면, 왼쪽에서부터 데이터를 채우기 때문에 Complete Tree 형태의 구조여야지만 최대 효율을 낼 수 있는 것이다.\n\n## Binary Search Tree\n \n검색 트리(Search Tree)란 트리를 이용해서 검색을 쉽게하기 위해서 **일정한 규칙**에 따라서 데이터를 저장한다. 이 방식은 해당 자료를 조회하는 과정이 굉장히 단순화 될 수 있다는 장점을 가진다. 그 중에서도 Binary Search Tree는 일정한 규칙을 `데이터의 삽입 시에 현재 위치에 정점보다 데이터가 크다면 오른쪽, 작다면 왼쪽에 배치시킨다.`로 정의한 경우를 말한다. 이렇게 데이터를 저장하게 되면, 마치 이진 검색을 통해서 데이터를 찾는 것과 같은 효과를 가질 수 있다. 왜냐하면, 후에 내가 데이터를 찾을 때 현재 위치의 값을 확인하고 해당 값보다 찾고자 하는 값이 크다면 반드시 오른쪽에 있을 것이라는 확신을 가질 수 있기 때문이다. 이를 통해서, 검색 범위를 줄일 수 있기 때문에 우리가 마치 이진 검색을 하는 것처럼 데이터의 범위를 한정할 수 있다. 이게 앞에서 설명했던 트리가 가지는 분류의 기능이다. 기존의 리스트에서는 정렬을 통해서 index 번호가 순서라는 정보를 담고 있었다면, Binary Search Tree에서는 좌우 subtree가 대소 비교라는 정보를 갖고 있는 것이다.\n\n하지만, 위에서 살펴보았다시피 유의할 점은 데이터가 좌우로 골고루 퍼져 있어야 한다는 점이다. 만약, 데이터가 좌축에만 쏠려있다면(skewed), 결국에는 분류로 얻는 이득이 없어진다. 따라서, 검색 시에는 시간 복잡도가 $O(N~\\log{N})$ 이다.\n\n### Skew 해결책\n\n여기서는 Skew에 대한 자세한 해결책을 제시하지 않는다. 아래 키워드를 제시하였으니 이를 검색하여 찾아보길 권장한다. (후에 정리할 시간이 있다면, 정리하겠다.)\n\n- 각 정점에 우선순위를 랜덤 값으로 지정하고, 각 subtree의 root는 해당 subtree에서의 랜덤 값의 총합을 우선순위로 가지게 하여 특정 트리가 데이터의 순서에 의해서 skew되는 현상을 막기 우히나 방법이 있다.(Treap)\n- Tree의 Skew가 발생할 시에 rotation이라는 방법을 통해서 Skew를 해결 시키는 방법도 있다. (AVL Tree)\n- 빨강과 검정이라는 이진 정보를 추가 활용하여 해결하는 방법도 있다. (Red Black Tree)\n\n\n## Advanced Topic\n\n아래 설명된 Tree에 대한 정보는 앞으로 차근차근 포스팅할 계획이다.\n\n- DFS Tree\n- Segment Tree\n- Fenwick Tree\n- Heap","slug":"tree","title":"Tree","category":"Algorithm","tags":["자료구조","Graph"],"date":"2022년 4월 30일 17:58","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"해당 Posting에서는 Modulo연산의 정의와 특징을 이해하고, 이를 이용한 알고리즘을 소개합니다.\n\n사칙연산과 같은 연산자입니다. 하지만, modulo 연산은 기존 사칙연산과는 다른 다양한 특징을 가지기 때문에, 이를 정리하고 이해하는 것은 중요합니다.\n\n우선 modulo 연산이란 무엇인지부터 알아야 합니다.\n\n$$a = bq + r$$\n\n$$r = a \\mod b = a \\mod q$$\n\nex.\n\n1.  $100 \\mod 3 = 1$\n2.  $12 \\mod 32 = 12$\n3.  $123 \\mod 11 = 2$\n4.  $1 \\mod 1 = 0$\n\n로 정의할 수 있습니다.\n\n쉽게 말해서, a와 b에 대해서, 나눗셈한 나머지를 반환하는 연산자입니다.\n\n이는 여러 programming language에서는 % 표기로 나타내는 경우가 많습니다. 따라서, 아래에서 부터는 %로 표기합니다.\n\n이 연산자는 기타 여러 알고리즘에서 유용하게 사용되기 때문에 특징을 알아두는 것이 좋습니다.\n\n## **특징**\n\n1.  연산 결과는 0보다 크거나 같고 연산을 수행하는 값($b$)보다는 작습니다.\n2.  만약, modulo 연산을 했을 때, 결과가 같다면, 두 정수는 **합동**이라고 합니다. 이에 따라, 합동인 정수는 무한히 많습니다.\n\n## **연산 특징**\n\n1.  **덧셈의 항등원(0)이 존재합니다.**  \n    $(A + 0) \\% C = A \\% C$\n2.  **덧셈의 역원(-A = C-A)이 존재합니다.**  \n    $-A \\% C = (C - A) \\% C$  \n    ex) $-105 \\% 100 = -5 \\% 100 = 95$\n3.  $(A+B) \\% C = \\{(A\\%C) + (B\\%C)\\} \\% C$  \n    ex) $54 \\% 17 = \\{(29\\%17) + (25\\%17)\\} \\% 17 = (12+8) \\%17 = 3 $\n4.  $(A-B) \\% C = \\{(A\\%C) - (B\\%C)\\} \\% C$  \n    ex) $54 \\% 17 = \\{(70\\%17) - (16\\%17)\\} \\% 17 = (2-16) \\%17 = -14 \\% 17 = 3 $  \n    \n5.  $(A \\times B) \\% C = \\{(A\\%C) \\times (B\\%C)\\} \\% C$  \n    ex) $960 \\% 17 = \\{(20\\%17) \\times (18\\%17)\\} \\% 17 = (3 \\times 1) \\%17 = 3 $\n6.  **정수 k, p에 대하여, p가 k의 약수라면,**  \n    $A^k \\% C = (A^{k \\over p}\\%C)^p \\% C$  \n    ex) $2^{10}(=1024) \\% 29 = (2^5(=32) \\% 29)^2 \\%29 = 3^2 \\% 29 = 9$\n7.  **곱셈의 항등원(1)이 존재합니다. ($ C \\ge 2$)**  \n    $A \\times 1 \\% C = A \\% C$\n8.  **곱셈의 역원(A^{-1})가 존재합니다.**  \n    $A \\times A^{-1} \\% C = 1 $  \n    하지만, 이를 구하는 것은 직접 해보는 수밖에 없습니다.\n9.  **곱셈의 역원을 통해서 나눗셈을 정의할 수 있습니다.**  \n    $ ({B \\over{A}} ) \\% C = B \\times A^{-1} \\% C$\n\n위와 같은 특징들 때문에, 수의 범위를 제한하는 문제를 푼다고할 때, 굉장히 유용하게 이를 이용할 수 있습니다. 왜냐하면, modulo 합동끼리는 사칙연산의 여러 특징들을 모두 사용할 수 있기 때문입니다.\n\n교환 법칙, 결합법칙, 역원, 항등원이 모두 존재합니다. \n\n또한, 만약, **나누는 수가 만약 소수라면**, 나눗셈을 더 쉽게 정의할 수 있습니다.\n\n바로 **Fermat's little theorem**(페르마의 소정리)를 활용하는 것입니다.\n\n이에 따르면, $A^{n-1} \\% C = 1$이라는 것입니다.\n\n이를 통해서, 우리는 아래를 증명할 수 있으며,\n\n$$ A \\times A^{-1} \\% C = 1  % C $$\n\n$$ A \\times A^{-1} \\% C = A^{n-1} \\% C $$\n\n$$ A^{-1} \\% C = A^{n-2} \\% C $$\n\n결론상 다음과 같이 나눗셈을 변형할 수 있습니다.\n\n$$ {A\\over B} \\% C = A\\times B^{n-2} \\% C$$\n\n## **유클리드 호제법**\n\n최대공약수(GCD), 최소공배수(LCM)를 구하는 문제에서 가장 단골로 사용되는 알고리즘입니다.\n\n해당 알고리즘의 동작순서는 다음과 같습니다.\n\n1.  큰 수(p)로 작은 수(q)를 modulo 연산하여, 결과값(r)을 얻습니다.\n2.  r이 0이라면, q는 최대공약수입니다.\n3.  그렇지 않다면, q와 r을 갖고, 1로 돌아가서 다시 시행합니다.\n\n이 결과를 통해서, 최대공약수(GCD)를 구할 수 있고, 모두가 알다시피, 최소공배수는 ${p \\times q}\\over {gcd}$이므로, 쉽게 유도가 가능합니다.","slug":"modulo","title":"modulo","category":"Algorithm","tags":["Modulo","나머지"],"date":"2022년 4월 1일 00:00","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"\n구간 누적합을 구하는 경우가 많이 발생한다. 하지만, 이를 저장하기 위해서 너무 많은 공간을 쓸 수는 없다. 예를 들어서 크기가 10,000인 집합에서 누적합으로 만들 수 있는 특정 수의 경우의 수를 구하고자 한다고 가정하자.\n\n이 경우에 우리는 모든 누적합을 저장하기에는 공간이 너무 크다는 것을 알 수 있고, 이를 그렇다고 Brute Force하게 수행하기에도 시간이 충분하지 않을 수도 있다.\n\n따라서, 우리는 효율적으로 누적합 정보를 저장할 수 있는 자료구조를 만들었다.\n그것이 Segment Tree와 Fenwick Tree이다. 이들을 하나씩 살펴보도록 하자.\n\n## Segment Tree\n\n이전에 tree posting에서 Tree를 표현하는 방법으로 List를 소개하였다. 여기서도 그 방식을 이용해야 하니 잘 알지 못하겠다면, 한 번 보고 오도록 하자. 👉 [posting](/posts/tree)\n\n우선 Segment Tree는 누적합을 표현하기 위한 이진 트리 형태의 자료구조이다. 이전에 트리는 데이터를 분류하기 위해 자주 사용한다고 하였는데, 이곳에서도 동일하다. \n\n이는 트리의 leaf node가 원래 누적합을 배우고자 하는 리스트의 원소가 된다. 그리고 그 부모는 해당 원소들의 합으로 표현된다. 이렇게 하여 root는 전체 리스트의 총합이 되는 형태로 구현하는 것이다.\n\n이러한 자료 구조를 가지게 되면 우리는 두 가지의 장점을 가질 수 있다.\n\n1. 특정 구간에서의 누적합을 굉장히 빠르게 구할 수 있다. ($\\log{N}$)\n2. 업데이트 시에도 깨지지 않고, 이를 빠르게 적용할 수 있다. ($\\log{N}$)\n\n### 누적합 구하기\n\n우선 해당 트리가 이미 만들어졌다는 가정하에서 어떻게 $\\log{N}$ 만에 **누적합을 찾을 수 있는지**를 확인해보자.\n\n이는 1번째 index b에서부터 6번째 index g까지의 합을 구하는 연산이다.\n\n![segment tree find](/images/segment-tree-find.jpeg)\n\n위에서 부터 탐색을 하기 위해서 다음과 같은 동작을 수행한다. \n\n1. 내가 조회하고자 하는 범위가 해당 지점이 표현하는 범위의 밖이라면, 해당 지점은 의미없으므로, 탐색을 중지한다.\n2. 조회 범위가 해당 지점을 완전 포함한다면, 해당값을 반환한다. (가장 큰 범위를 포함하는 지점에서부터 탐색하기 때문에 조회 범위에 엉뚱한 것이 섞이지 않는다.)\n3. 만약, 그렇지 않다면 해당 지점에 포함된 영역을 더 추출해야 하기 때문에 하위 지점으로 이동한다.\n\n노드 방문 횟수가 대략 $\\log{N}$ 까지 감소하는 것을 볼 수 있다.\n\n### 누적합 갱신\n\n이제 실제로 **update를** 수행해보자.\n\n5번째 index f에 1을 더하는 연산을 수행하는 그림이다.\n\n![segment tree update](/images/segment-tree-update.jpeg)\n\n위에서 부터 변동사항을 적용하기 위해서 다음과 같은 동작을 수행한다. \n\n1. 내가 추가하고자 하는 위치가 해당 지점이 표현하는 범위의 밖이라면, 해당 지점은 의미없으므로, 탐색을 중지한다.\n2. 추가하고자 하는 값을 해당 지점에 추가한다.\n3. 해당 지점이 leaf 인지 확인하고, 맞다면 종료한다.\n4. 그렇지 않다면, 하위 지점을 더 탐색한다.\n\n### 구현\n\n업데이트 시에도 복잡한 연산이 없이 바로 내려가면서, 덧셈이 필요한 구역에 더해주는 것으로 쉽게 구현이 가능하다.\n\n```python\nS = [1,2,3,4,5,6,7]\n# tree의 크기는 원래 원래의 배열의 크기보다 큰 2의 제곱수 * 2 - 1이다.\n# 하지만, 이를 더 쉽게 만드는 방법은 간단하게 곱하기 4하는 것이다.\ntree = [0] * (len(S) * 4)\n\n# 트리를 구성하는 함수이다.\n# 루트에서부터 호출하지만, 결과는 밑에서 부터 구하면서 올라온다.\ndef make_seg(start=0, end=len(S) - 1, cursor=1):\n  if start == end:\n    tree[cursor] = S[start]\n    return tree[cursor]\n  mid = (start + end) // 2\n  tree[cursor] = make_seg(start, mid, 2 * cursor) + \\\n                  make_seg(mid + 1, end, 2 * cursor + 1)\n  return tree[cursor]\n\n# 위에서 보았던 누적합을 조회하는 연산이다.\ndef find(left, right, cursor=1, start=0, end=len(S)-1):\n  if left \u003e end or right \u003c start:\n    return 0\n  if left \u003e= start and right \u003c= end:\n    return tree[cursor]\n  mid = (start + end) // 2\n  return find(left, right, cursor * 2, start, mid) \\\n    + find(left, right, cursor * 2 + 1, mid + 1, end)\n\n# 위에서 보았던 누적합을 업데이트 하는 연산이다.\ndef update(idx, diff, cursor=1, start=0, end=len(S) - 1):\n  if idx \u003e end or idx \u003c start:\n    return\n  tree[cursor] += diff\n  if start == end:\n    return\n  mid = (start + end) // 2\n  update(idx, diff, start, mid)\n  update(idx, diff, mid + 1, end)\n\nmake_seg() \nprint(find(1, 6)) # 28\nupdate(3, 5)\nprint(find(1, 6)) # 33\n```\n\n## Fenwick Tree\n\nsegment tree와 동일하게 fenwick tree도 list를 통해서 tree를 표현한다.\n또한, segment tree에서는 기존 배열의 시작점을 어디로 하던 상관없었지만, 구현 상의 편의를 위해서 기존 배열을 왼쪽에서 한 칸 밀어주는 것을 추천한다.\n\n기본적으로 Fenwick Tree는 이진수의 특징을 활용한 연산을 통해서 합을 빠르게 찾을 수 있다. 먼저 Fenwick tree는 다음과 같은 형태로 구조화된다.\n\n![fenwick-tree](/images/fenwick-tree.jpeg)\n\n즉, 해당 수의 약수 중 가장 큰 2의 제곱 수만큼 자신을 포함한 하위 수의 누적합을 포함하는 방식이다. 따라서, 홀수의 경우는 자신만을 누적합으로 가지는 것을 볼 수 있다.\n이렇게 구조화된 데이터는 LSB(Least Significant Bit, 이진수에서 가장 오른쪽에 있는 bit를 의미한다.)라는 특징을 이용해서 누적합과 해당 원소를 포함한 대상들을 찾기에 유용하다.\n\n### 누적합 구하기\n\n우선 Fenwick Tree는 구간합을 반드시 맨 처음부터 특정 위치까지 구하는 연산만 수행가능하다. 따라서 구간이 처음부터가 아니라면, Fenwick Tree의 조회 연산을 두 번 수행하여 두 값을 빼서 구한다.\n\n\u003e 예시   \n\n1. h라는 값을 조회하는 경우\n\n$$ \n\\begin{align} \n    \u0026= origin[8] \\notag \\\\\n    \u0026= sum(8) - sum(7) \\notag \\\\\n    \u0026= fenwick[8] - (fenwick[4 to 7]) \\notag\n\\end{align} \n$$\n\n2. e + f + g의 구간합이 필요한 경우   \n\n$$ \n\\begin{align} \n    \u0026= origin[5to7] \\notag \\\\\n    \u0026= sum(7) - sum(4) \\notag \\\\\n    \u0026= (fenwick[4 to 7]) - fenwick[4] \\notag\n\\end{align} \n$$\n\n여기서 `sum`을 구현하기 위해서 parameter로 들어온 값의 LSB에서 부터 1을 삭제하면서 진행하면 된다.\n즉, 7이 들어왔다면, 이는 이진수로 $111_{(2)}$이고, 오른쪽에서부터 1을 발견할 때마다 해당 값을 누적합에 축적하고, 삭제하면 된다.\n\n1. 누적합 acc를 0으로 초기화한다.\n2. $111_{(2)}$는 LSB가 1이다. 따라서, 누적합에 fenwick[$111_{(2)} = 7$]를 더한다.\n3. $111_{(2)}$에서 마지막 1을 지운다. (결과값은 $110_{(2)}$)\n4. $110_{(2)}$는 LSB의 다음이 1이다. 따라서, 누적합에 fenwick[$110_{(2)} = 6$]를 더한다.\n5. $110_{(2)}$에서 마지막 1을 지운다. (결과값은 $100_{(2)}$)\n6. $100_{(2)}$는 LSB의 다다음이 1이다. 따라서, 누적합에 fenwick[$100_{(2)} = 6$]를 더한다.\n7. $100_{(2)}$에서 마지막 1을 지운다. (결과값은 $000_{(2)}$)\n8. 결과값이 0이므로 탐색을 종료한다.\n\n![fenwick-tree-add](/images/fenwick-sum.jpeg)\n\n### 누적합 갱신\n\n특정 값에 누적합을 갱신하는 것 역시 간단하게 구현이 가능하다. LSB에서 가장 가까운 1에 1을 더해주는 연산을 더해가면서 업데이트를 수행해주면 된다.\n\n\n1. $11_{(2)}$는 LSB가 1이다. 따라서, fenwick[$11_{(2)} = 3$]에 값을 더한다.\n2. $11_{(2)}$에서 가장 오른쪽의 1을 더한다. (결과값은 $100_{(2)}$)\n3. $100_{(2)}$는 LSB의 다디음이 1이다. 따라서, fenwick[$100_{(2)} = 4$]에 값을 더한다.\n4. $100_{(2)}$에서 마지막 1을 더한다. (결과값은 $1000_{(2)}$)\n5. $1000_{(2)}$는 LSB의 다다다음이 1이다. 따라서, 누적합에 fenwick[$1000_{(2)} = 8$]에 값을 더한다.\n6. 더이상 더하는 것은 범위 밖이므로 종료한다.\n\n![fenwick-tree-update](/images/fenwick-update.jpeg)\n\n### 구현\n\n```python\norigin = [None, 1,2,3,4,5,6,7,8,9]\nfenwick = [0] * len(origin)\n\ndef update(idx, val):\n  while idx \u003c len(fenwick):\n    fenwick[idx] += val\n    idx += (idx \u0026 -idx)\n\ndef sum(idx):\n  acc = 0\n  while idx \u003e 0:\n    acc += fenwick[idx]\n    idx -= (idx \u0026 -idx)\n  return acc\n\ndef make_fen(origin):\n  for idx in range(1, len(origin)):\n    update(idx, origin[idx])\n\nmake_fen(origin)\nprint(sum(7) - sum(4)) # 18\nupdate(5, 5)\nprint(sum(7) - sum(4)) # 23\n```\n\n## Versus\n\n둘 다 구간합을 구하기에 적합한 구조이지만 다음과 같은 차이점을 가지고 있다는 점을 명시하자. 상대적으로 활용성이 높은 Segment Tree를 사용하는 것이 대다수 좋을 수 있지만, Fenwick Tree가 가지는 크기의 장점과 코드의 구현이 쉽다는 점은 굉장한 이점이다.\n\n|                    | Segment Tree                                      | Fenwick Tree                  |\n| :----------------- | :------------------------------------------------ | :---------------------------- |\n| find 시간복잡도    | $O(\\log{N})$                                      | $O(\\log{N})$                  |\n| update 시간복잡도  | $O(\\log{N})$                                      | $O(\\log{N})$                  |\n| 공간복잡도(사이즈) | $2^{k + 1}$($2^{k} \\ge$ len(origin))              | len(origin)                   |\n| 활용성             | 구간 내 합 뿐만 아니라 최대, 최소값으로 응용 가능 | **오직 구간 합에만 사용가능** |\n| 구현 코드 길이     | 상대적으로 김                                     | 상대적으로 짧음               |\n\n","slug":"accumerated-number","title":"누적합","category":"Algorithm","tags":["자료구조","Segment Tree","Fenwick Tree"],"date":"2022년 4월 30일 14:09","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"\n소수찾기는 굉장히 많은 프로그래밍 책에서 for문 입문 시에 사용하는 예제로 많이 사용된다.\n여기서는 소수를 찾기 위한 알고리즘으로 에라토스테네스의 체를 제시한다.\n\n만약 이를 사용하지 않고, 소수를 찾기 위해서는 다음과 같은 식으로 작성하는 것이 일반적이다.\n\n```python\nprimes = [2]\n\nmax_num = 100_000\nfor num in range(3, max_num+1):\n  is_prime = True\n  max_prime = inr(num ** 0.5)\n  for prime in primes:\n    if num % prime == 0:\n      is_prime = False\n      break\n    if prime \u003e max_prime:\n      break\n  if is_prime:\n    primes.append(num)\n```\n\n이는 아래의 수부터 소수를 찾으면서 진행하고, 소수가 있다면 다음에 수를 찾을 때, 이를 이용해서 소수 여부를 확인하는 방식이다.\n(여기서 sqrt를 이용한 이유는 소수가 아니라면 약수는 두 수의 곱으로 나타낼 수 있어야 하므로, 제곱수까지만 확인해도 충분하다.)\n하지만, 이 방식은 소수를 매 반복문마다 반복해서 사용하는 것을 볼 수 있다. 따라서, 이러한 불필요한 동작을 최소화하기 위해서 범위가 정해져 있는 소수를 찾을 경우에는 에라토스테네서의 체를 이용할 수 있다.\n\n에라토스테네스의 체는 배열의 index를 수의 값으로 하고, value를 소수 여부로 나타내는 비트마스크 형태이다. (*비트 마스크 : 0과 1로 이루어진 체로, index를 통해서 무언가를 검색할 때, O(1)로 연산할 수 있는 자료구조)\n\n여기서, 소수를 찾을 때마다 이를 약수로 갖는 모든 수들을 소수가 아니라고 마킹하여 쉽게 O($N^{1\\over{2}}$)만에 해당 범위안의 모든 소수를 판별할 수 있는 알고리즘이다.\n\n```python\nN = 100_000\nis_primes = [True] * (N+1)\n\nfor num in range(2, int(N ** 0.5) +1):\n    if not is_primes[num]:\n        continue\n    for j in range(2 * num, N+1, num):\n        is_primes[j] = False\n\nprimes = [i for i in range(2, n) if is_primes[i] == True]\n```\n\n","slug":"find-prime","title":"소수찾기","category":"Algorithm","tags":["소수찾기","에라토스테네스의 체"],"date":"2022년 5월 1일 14:23","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"}],"Computer Architecture":[{"content":"\n해당 내용은 컴퓨터 구조를 더 잘 이해하기 위해서 논리회로의 내용을 축약하여 정리한 포스팅이다.\n\n---\n\n컴퓨터 회로에서는 모든 연산이 이진수로 이루어진다. 그 이유는 높은 전압이 흐를 때를 1, 그렇지 않을 때를 0으로 정의를 하여 이를 통해서 값을 구분하기 때문이며, 이것이 우리가 이진수 체계에서 컴퓨터 연산을 표현하는 이유이다.\n\n만약, 이를 삼진수 이상으로 표현할 수 있다면, 더 획기전 연산이 가능하겠지만, 비용적인 측면과 물리적인 측면에서 아직은 한계가 있다. (양자 컴퓨터 역시 이와 유사한 원리이다.)\n\n해당 분야에서는 0-\u003e1로 바뀌는 것을 active(활성화)시켰다고 한다.   \n또한, 0인 상태를 deasserted signal, 1인 상태를 asserted signal이라고 한다.   \n\n### Truth Table(진리표)\n이진수로 표현되는 값의 input과 이를 통한 output을 나타내기 위해서 우리는 진리표를 활요한다. 여기서는 A,B가 input, C가 output이 된다. C는 A와 B를 OR 연산한 결과이다.\n\n| A    | B    | C    |\n| :--- | :--- | :--- |\n| 0    | 0    | 0    |\n| 0    | 1    | 1    |\n| 1    | 0    | 1    |\n| 1    | 1    | 1    |\n\n---\n\n### Gate\n\n그림은 위에서 부터 AND, OR, NOR, NAND, 그리고 input을 뒤집는 inversion Gate를 나타낸 것이다.\n\n![AND Gate](/images/and.png)\n\n![OR Gate](/images/or.png)\n\n![NOR Gate](/images/nor.png)\n\n![NAND Gate](/images/nand.png)\n\n![Inversion Gate](/images/inversion.png)\n\n각 Gate는 다음과 같은 연산을 출력한다.\n\n**1. AND**   \n   2 inputs / 1 output\n   | A    | B    | C    |\n   | :--- | :--- | :--- |\n   | 0    | 0    | 0    |\n   | 0    | 1    | 0    |\n   | 1    | 0    | 0    |\n   | 1    | 1    | 1    |\n\n$0 \\cdot0 = 0 \\\\\n0 \\cdot1 = 0 \\\\\n1 \\cdot0 = 0 \\\\\n1 \\cdot1 = 1$\n\n**2. OR**    \n   2 inputs / 1 output\n   | A    | B    | C    |\n   | :--- | :--- | :--- |\n   | 0    | 0    | 0    |\n   | 0    | 1    | 1    |\n   | 1    | 0    | 1    |\n   | 1    | 1    | 1    |\n\n$0 + 0 = 0 \\\\\n0 + 1 = 1 \\\\\n1 + 0 = 1 \\\\\n1 + 1 = 1$\n\n**3. NOR**   \n   2 inputs / 1 output\n   | A    | B    | C    |\n   | :--- | :--- | :--- |\n   | 0    | 0    | 1    |\n   | 0    | 1    | 0    |\n   | 1    | 0    | 0    |\n   | 1    | 1    | 0    |\n\n$\\overline{(0 + 0)} = 1 \\\\\n\\overline{(0 + 1)} = 0 \\\\\n\\overline{(1 + 0)} = 0 \\\\\n\\overline{(1 + 1)} = 0$\n\n**4. NAND**   \n   2 inputs / 1 output\n   | A    | B    | C    |\n   | :--- | :--- | :--- |\n   | 0    | 0    | 1    |\n   | 0    | 1    | 1    |\n   | 1    | 0    | 1    |\n   | 1    | 1    | 0    |\n\n$\\overline{(0 \\cdot0)} = 1 \\\\\n\\overline{(0 \\cdot1)} = 1 \\\\\n\\overline{(1 \\cdot0)} = 1 \\\\\n\\overline{(1 \\cdot1)} = 0$\n\n**5. Inversion(=NOT)**   \n   1 inputs / 1 output\n   | A    | C    |\n   | :--- | :--- |\n   | 0    | 1    |\n   | 1    | 0    |\n\n$\\overline{1} = 0 \\\\\n\\overline{0} = 1$\n\n여기서 하나 특별한 개념이 나온다. 바로 Functional Complete이다. 특정 Gate만 가지고, 위에서 제시된 모든 연산을 표현할 수 있으면, 이를 Functional Complete라고 한다. 여기서 우리는 가장 보편적으로 생각할 수 있는 {AND, OR, NOT}는 모두 표현할 수 있다는 것을 알 수 있다. 그런데, 여기서 {NAND} 하나만 가지고 이를 표현할 수 있는데, 아래가 이에 대한 예시이다.\n\n![NAND complete](/images/complete-1.png)\n\n그리고, {NOR}만 가지고도 똑같이 표현가능하다. \n\n![NOR complete](/images/complete-2.png)\n\n동일한 값을 NAND, NOR하면 역수가 나온다는 특징과 [드 모르간의 법칙](https://ko.wikipedia.org/wiki/%EB%93%9C_%EB%AA%A8%EB%A5%B4%EA%B0%84%EC%9D%98_%EB%B2%95%EC%B9%99)에 의해서 이것이 정의된다고 할 수 있다.\n\n---\n\n### Decoder\n\nn bit로 표현할 수 있는 $2^{n}$개의 값을 회선을 통해서 표현하기 위해서 $2^{n}$개의 회선 중에서 단 하나의 값만 active한다.\n\n| input1 | input2 | input3 |\n| :----: | :----: | :----: |\n|   0    |   0    |   0    |\n|   0    |   0    |   1    |\n|   0    |   1    |   0    |\n|   0    |   1    |   1    |\n|   1    |   0    |   0    |\n|   1    |   0    |   1    |\n|   1    |   1    |   0    |\n|   1    |   1    |   1    |\n\n| output1 | output2 | output3 | output4 | output5 | output6 | output7 | output8 |\n| :------ | :------ | :------ | :------ | :------ | :------ | :------ | :------ |\n| 1       | 0       | 0       | 0       | 0       | 0       | 0       | 0       |\n| 0       | 1       | 0       | 0       | 0       | 0       | 0       | 0       |\n| 0       | 0       | 1       | 0       | 0       | 0       | 0       | 0       |\n| 0       | 0       | 0       | 1       | 0       | 0       | 0       | 0       |\n| 0       | 0       | 0       | 0       | 1       | 0       | 0       | 0       |\n| 0       | 0       | 0       | 0       | 0       | 1       | 0       | 0       |\n| 0       | 0       | 0       | 0       | 0       | 0       | 1       | 0       |\n| 0       | 0       | 0       | 0       | 0       | 0       | 0       | 1       |\n\n![Decoder](/images/decoder.png)\n\n---\n\n### Multiplexor(=Selector)\nControl에 의해서 선택되어진 Input을 Output으로 내보낸다. 이를 위해서 Input 여러 개와 이 중에 무엇을 선택할지를 의미하는 Selector(=Control) Value을 입력한다.\n형태는 input의 갯수만큼의 AND Gate와 Output Gate, 그리고 Decoder로 이루어진다.\n\n1. Decoder를 통해서 Signal Bit를 나눈다.\n2. 각 Input의 크기만큼 Decoder의 각 Input의 크기를 확장하여 AND 연산을 취한다.\n3. 나온 모든 결과를 OR로 연산한다.\n\n\n| Input1 | Input2 | Signal | Output |\n| :----- | :----- | :----- | :----- |\n| x      | y      | 0      | x      |\n| x      | y      | 1      | y      |\n\n![Mux](/images/mux.png)\n\n---\n\n### Clock\n\nClock이란 고정된 Cycle time을 주기로 하여 발생하는 신호를 의미한다. 여기서 고정된 Cycle Time은 Clock이 높은 시점과 낮은 시점으로 구분할 수 있다. 우리의 모든 연산은 Clock이 감소하거나 증가하는 그 시점에 동작한다. 이를 `Edge Triggered Clocking`이라고 부른다. 따라서, 우리는 정확히 상태값이 변하는 `edge`에서를 active 상태라고 부르는데 이를 오르는 `edge`로 할지 내려가는 `edge`로 할지는 설계자의 몫이다. \n\n하나의 Clock이 의미하는 것은 특정 상태에서 연산이 이루어져서 다음 단계로 넘어간다는 의미이다. 따라서, Clock Period가 짧을 수록, 다음 상태로 빠르게 넘어갈 수 있다. 하지만, 이를 무한정으로 올리는 것은 불가능하며, 열이 너무 증가하여 회로 전체에 악영향을 줄 수도 있다.\n\n![clock](/images/clock-1.png)\n\n![clock](/images/clock-2.png)\n\n---\n\n### Latches\n걸쇠를 의미하며, 값을 저장해놓는다는 의미를 가진다. 이를 이용해서 Memory와 같은 저장장치를 만들 때 사용한다. 두 가지 형태가 존재하니 하나씩 알아보자. (물론 자세히 알면 좋겠지만 필자는 이정도 개념이 있다는 정도로만 기억한다.)\n\n\u003e **S-R Latch(Set Reset Latch)**\n\nS와 R이 모두 0이면 값이 변하지 않고, Cross되는 위치에 데이터가 저장되게 된다.   \nR(Reset)만 1로 하면, 데이터 값이 0으로 초기화된다.   \nS(Set)만 1로 하면, 데이터 값이 1로 세팅된다.   \nR과 S를 모두 1로 하면 해당 값은 저장이라는 의미를 갖지 못한다.   \n\n| S    | R    | Q    |\n| :--- | :--- | :--- |\n| 0    | 0    | keep |\n| 0    | 1    | 0    |\n| 1    | 0    | 1    |\n| 1    | 1    | x    |\n\n![sr-latch](/images/sr-latch.png)\n\n\u003e **D Latch**\n\nClock단위로 데이터를 저장하기 위해서 이와 같은 장치를 이용한다. 하지만, 이는 Clock이 asserted된 상태(1)인 상태에 언제든지 변환된다는 특징을 갖고 있다. Output은 저장되어있는 값과 등일하다.\n\n![d-latch](/images/d-latch.png)\n\n---\n\n## Flip-Flop\nClock단위로 데이터를 저장하기 위해서 이와 같은 장치를 이용한다. 하지만, 이는 Clock이 변화하는 edge에서만 상태가 변한다는 특징을 갖고 있다. Output은 저장되어있는 값과 동일하다. 아래는 대표적인 D Flip-Flop이다.\n\n![flip-flop](/images/flip-flop.png)\n\n---\n\n실제로는 Latch보다 Flip Flop을 이용하는 것이 일반적인데, 왜 그렇게 하는 것일까? 이는 우리가 입력을 받을 때, 이를 처리하기 위한 최소하의 시간이 필요하기 때문이다.\n\n이 최소한의 시간은 다음과 같이 정의된다.\n\n$t_\\text{prop} + t_\\text{combinational} + t_\\text{setup} + t_\\text{skew}$\n\n1. $t_\\text{prop}$  : flip-flop 내에서 신호가 처리되는데 까지 걸리는 시간을 의미한다.\n2. $t_\\text{combinational}$ : 실제 연산이 수행되는 부분이다.\n3. $t_\\text{setup}$  : 전기적 신호가 바로 low에서 high로 이동하는 것이 아니기 때문에 이를 setup하는데 걸리는 시간을 의미한다.\n4. $t_\\text{skew}$ : 공정과정에서 완벽하게 만들더라도 각 소자마다 어느정도 차이가 발생하게 되는데 이를 의미한다.\n\n이처럼 이 시간동안 우리는 다른 처리를 수행할 수 없다. 따라서, 이것을 처리하는 동안의 시간을 확보하기 위해서 우리는 Edge에서만 수행하는 방식을 사용하고 있다. 또한, Clock Cycle Time 또한 이보다는 크게 setting하는 것이 일반적이다.\n\n","slug":"digital-logic-circuit","title":"0. 논리회로 요약","category":"Computer Architecture","tags":["논리회로"],"date":"2022년 4월 27일 23:28","thumbnailSrc":"https://euidong.github.io/images/default.jpg"},{"content":"\n## **Reference**\n\n![\u003cimg src=\"/images/default.jpg\" width=\"190\" /\u003e](/images/default.jpg)\n\nDavid A. Patterson, John L. Hennessy, Computer Organization and Design\n\n본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 \"-다\"로 표현합니다.\n\n---\n\n## **1\\. 8 Greate Ideas**\n\n컴퓨터 구조를 설계하는 과정에서 중요하게 여겨지는 8가지 핵심 아이디어들이다. 뿐만 아니라 이는 전체적인 컴퓨터 과학에서 중요하다고 볼 수 있는 아이디어들이다. 따라서, 앞으로의 Posting에서 Why라는 의문이 든다면, 아래 8가지 이유 중의 하나로 설명할 수 있다.\n\n1.  **Moore's Law**  \n    18 ~ 24 개월마다 컴퓨터 성능의 지대한 영향을 미치는 IC 칩의 성능이 2배씩 성장한다는 Moore의 주장에서 유래하였다. 즉, **컴퓨터의 성능은 지수적으로 빠르게 성장을 하고 있음을 의미한다.** 이로 인해 구조를 설계하는 과정에서도 현재의 IC 칩의 성능에 맞추는 것이 아닌 이보다 더 큰 성능을 타겟으로 설정을 한다.\n2.  **Abstraction**  \n    우리 말로 추상화라고 표현하며, 복잡한 하위 내용을 모두 기술하지 않고, 간단하게 표현하여 이를 쉽게 사용할 수 있도록 하는 방식이다. 이를 통해서, **설계 과정에서의 복잡도를 줄일 수 있다.**\n3.  **Common Case Fast**  \n    **드물게 일어나는 case보다는 일반적인 case를 빠르게 만듬으로써 성능을 향상시킬 수 있다.** 드물게 일어나는 case는 매우 복잡하고, 해결하기도 난해할 수 있다. 하지만, 대게의 경우 일반적인 case는 간단하다. 이를 최적화하는 것이 전체적인 시스템 성능 향상에 큰 도움이 되는 것은 당연하며 해결도 매우 쉽다.\n4.  **Performance via Parallelism**  \n    성능 향상을 위한 방법은 크게 두 가지이다. 하나는 하나의 장치의 성능을 올리는 것이고 또 하나가 바로 **하나의 작업을 여러 명이 동시에 수행하는 방식이다.**\n5.  **Performance via Pipelining**  \n    성능 향상을 위한 병렬처리 방식 중에서 가장 유명한 방식이 pipelining이다. 쉽게 생각하면, 분업이라고 할 수 있다. **여러 명이서 하나의 목적을 위해 일을 할 때, 효율적으로 작업하기 위해서 업무를 분담하여 동시에 작업**하는 방식이다.\n6.  **Performance via Prediction**  \n    우리는 무슨 작업을 할 때, 아직 결정되지 않은 사항 때문에 기다리는 경우가 있는데, 이것이 어떻게 될지를 **예측하여 기다리지 않고, 미리 진행하자**는 발상에서 나온 것이다. 만약, 이 예측의 적중률이 높다면, 성능 향상에 굉장한 도움을 줄 수 있다.\n7.  **Hierarchy of Memories**  \n    컴퓨터의 사용자가 원하는 메모리는 빠르고, 크고, 싸야 한다. 하지만, 빠르기 위해서는 비싸야하고, 크기 위해서도 비싸야 한다. 그래서 생각해낸 방법이 계층화이다. **빠르고, 작은 memory를 위로 쌓고, 느리고, 큰 memory를 아래로 쌓음으로써 비용을 절감**하자는 것이다.\n8.  **Dependability via Redundancy**  \n    컴퓨터는 빠르기만 해서 되는 것은 아니다. **신뢰**할 수 있는 시스템을 구축해야 한다. 실패하지 않는 시스템을 구축하는 것은 매우 힘든 일이기 때문에, 우리는 **여분 장치**를 두어 이를 통해서 실패 시에 이를 떠맡을 수 있도록 하는 설계를 해야 한다.\n\n## **2\\. Below Your Program**\n\nprogram 밑에는 무엇이 있는가?\n\n우리의 program은 모두 application software이고, 이는 hardware 바로 위에 존재하는 것이 아닌 system software위에서 동작하게 된다.\n\n![\u003cimg src=\"/images/kernel.png\" width=\"190\" /\u003e](/images/kernel.png)\n\n**System Software**는 Hardware를 직접적으로 제어하거나 computer가 작동하기 위해 필수적이며 기본적인 softwre를 말한다. 그 중에서 가장 대표적인 것이 OS이고 **OS**는 사실상 우리가 보는 Software와 Hardware 간의 interface역할을 한다. 예를 들어, memory 관리, process 관리 등(이는 OS 에서 자세히 배웁시다.)을 수행한다. 반면, **Application** **Software**는 직접적으로 hardware를 관리하거나 필수적인 요소는 아니지만 computer를 통해서 가치있는 작업을 수행하도록 한다. 대표적인 예시가 웹브라우저, word, game 등이 여기에 포함된다.\n\n  그렇다면, 우리가 만든 코드(Application Software)가 어떻게 실행되어질 수 있을까? 이 또한, System Software인 compiler, assembler, linker, loader의 도움을 통해서 실행되어진다. **compiler**는 우리가 고 수준의 언어(C++, Java, 등)로 만든 software code를 Assembly 언어로 변경한다. 그러면, 이를 **Assembler**가 0과 1로 이루어진 기계어로 번역해준다. 해당 작업이 끝나면, **Linker**가 나타나 여러 개로 나뉘어져있던 이 파일과 기존 라이브러리를 하나의 파일로 묶어주는 역할을 한다. 이 작업을 마치고 만들어진 최종 파일을 실행하고자할 때, **Loader**는 이를 memory에 올리는 역할을 한다. 이렇게 실행된 program은 여기서 그치지 않고, memory의 아예 다른 영역에 위치하는 library도 불러와서 사용하는 것이 가능하다. 이것을 **Dynamic Linked Library**(DLL)라고 한다.\n\n![\u003cimg src=\"/images/run-process.png\" width=\"190\" /\u003e](/images/run-process.png)\n\n이렇게 하나의 코드를 작성하면, 실제로 실행되기까지 여러 작업들을 거쳐야만 한다. 그럼에도 assembly 언어나 기계어를 사용하여 코딩을 하지 않는 이유는 아래 세 가지 이유가 주요하다.\n\n1.  사람이 이해하기 쉽다.\n2.  생산성을 높일 수 있다.\n3.  Compiler와 assembly를 통해서 어디서든 돌아가는 프로그램을 제작할 수 있다.\n\n## **3\\. Under the Covers**\n\n우리의 컴퓨터는 어떻게 이루어지는가를 크고 얇게 한 번 알아볼 것이다.\n\n-   **Input Device** : 우리의 입력을 받는 부분이다. 마우스, 키보드, 터치스크린 등이 있다.\n-   **Output Device** : 우리가 출력을 받는 부분이다. 모니터, 프린터 등이 있다.\n-   **IC(Integrated Circuits, Chip)** : 집적 회로로 번역되어지며, 통상 우리가 chip이라고 부르는 녀석들이다. 이들은 적게는 수십개 많게는 억 단위 이상에 이르는 양의 transister를 가지고 있고, 이를 통해서 데이터를 저장하거나 처리하는 역할을 할 수 있다. 즉, IC를 통해서 CPU, Memory를 만들 수 있다.\n    -   trasistor: 쉽게 말해서 전기를 통해서 on/off를 수행할 수 있는 switch라고 볼 수 있다. 이를 통해서, 데이터를 연산하거나 저장하는 것이 가능하다.\n-   **CPU (Central Processor Unit, Processor, MicroProcessor)** : 중앙 처리 장치라는 의미로, 각종 연산과 I/O Device 처리 등의 중심 역학을 수행한다. CPU는 크게 두 개의 요소로 이루어진다.\n    -   DataPath : 수학적인 연산을 수행한다.\n    -   Control : program의 instruction이 무엇을 요구하는지를 입출력 장치, memory 또는 datapath에 전달합니다.\n-   **Memory(RAM(Random Access Memory), main memory, primary memory)** : 실행되고 있는 프로그램이 위치하는 곳이다. 실행되는 프로그램에 대한 정보와 같은 내용을 포함한다고 할 수 있다. 이는 DRAM으로 이루어진다. 또한, Random Access Memory라고 불리는 이유는 어느 위치에 데이터를 저장하고 있어도 해당 데이터를 찾는데 걸리는 시간이 동일하기 때문이다.\n    -   DRAM(Dynamic Random Access Memory) : IC chip을 통해서 만들어진다. 여기서 Random Access란 접근할 때, 앞에서부터 차례로 접근하는 것이 아닌 한 번에 바로 짚을 수 있음을 의미한다.\n-   **Cache Memory** : 대게 Cache라고도 부르며, Processor 내부에 존재하는 memory라고 볼 수 있다. 즉, 실제 Memory의 buffer 기능을 한다. 여기서는 SRAM을 사용한다.\n\n-   SRAM(Static Random Aceess Memory) : DRAM보다는 빠르지만, 집적도가 낮고 더 비싸기 때문에 많이 사용할 수는 없는 chip이다. 하지만, 성능 향상을 위해서 processor 바로 앞에 buffer로써 사용한다.\n-   buffer : 자료구조의 queue를 이용한 것으로, 처리를 요청한 대상과 처리를 수행하는 대상 사이에서 데이터를 잠깐 보관하기 위한 장소로 사용된다.\n\n-   **Secondary Memory** : main memory는 휘발성이라는 특징을 갖고 있기 때문에 시스템이 종료되어 전기가 더 이상 공급되지 않으면, 모든 데이터는 날라간다. 이를 막기 위해서 그리고 부족한 main memory의 저장공간을 보조하기 위해서 보조 기억 장치를 사용한다. 이것에 사용되는 것은 크게 두 가지 이다.\n    -   magnatic disk : 자기 disk를 이용해서 정보를 저장하는 방식이다. 전기가 공급되지 않음에도 정보를 저장하고 있을 수 있다.\n    -   flash memory : 반도체를 이용하여 데이터를 저장하며, DRAM보다는 느리지만, 더 싸고 휘발성이 없다.\n-   **Instruction Set Architecture(ISA, architecture)** : 0과 1로 이루어진 기계어가 들어왔을 때, 이것이 무슨 의미인지를 나타내는 instruction \bSet에 따라 CPU가 알맞은 연산을 수행하는 architecture이다.\n    -   Instruction \bSet : hardware에게 동작을 요청하는 하나의 명령어를 Instruction이라고 한다. 이들이 무슨 역할을 하는지를 정리해놓은 것이 Instruction Set이다. 이를 통해서, Operating System은 hardware에 접근하여 특정 동작을 수행시킬 수 있다.\n    -   ABI(Application Binary Interface) : application 단에 programmer가 hardware 작업 등을 수행하기 위하여 호출할 수 있다. 이를 통해서, binary한 동작도 application programmer가 조작할 수 있다. 일반적인 API와 역할이 동일하지만, programming language가 아닌 machine language를 사용하여 구현되기 때문에 hardware 접근 등에 제한이 없다.\n\n## **4\\. Performance**\n\n우리가 Computer의 성능을 측정하는 것은 중요하다. 왜냐하면, 이를 지표로 계속해서 computer의 성능을 향상시켜야 하기 때문이다.\n\n그래서 우리는 다음과 같이 표현하는 것이 일반적이다.\n\n$$\\text{Excution Time} = \\text{Clock Cycle Time} \\times {\\text{Number of Instruction}} \\times {CPI}$$\n\n즉, **총 실행 시간**(Execution Time)은 **한 번 Clock이 회전하는데 걸리는 시간**(Clock Cycle Time)에 해당 **program의 instruction 수**(Number of Instruction) 그리고 **하나의 instruction을 처리하는데 걸리는 clock cycle의 횟수**(CPI)라고 볼 수 있다.\n\n즉, 우리가 특정 프로그램을 빠르게 돌리고 싶다면, 다음과 같은 식으로 생각할 수 있다.\n\n1.  한 번 회전하는데 걸리는 시간을 줄이기 위해 클락 frequency를 높인다. **하지만, 회전열로 인해 현재는 frequency를 올리는 것은 포기하고 있다.**\n2.  프로그램을 잘 짜거나 Compiler를 더욱 더 최적화하여 instruction의 수를 줄인다.\n3.  하드웨어를 잘 설계해서 명령 하나를 처리하는데 걸리는 시간(CPI)을 줄인다.\n4.  동시에 여러 CPU를 실행시켜서, 실행을 하는 unit 자체를 더 만드는 방법도 있다.\n\n따라서, 앞으로 우리가 Performance를 올리기 위해서, Compiler를 어떻게 최적화할지를 계략적으로 배우며, 하드웨어를 어떻게 잘 설계할지를 자세히 알아볼 것이다. 또한, Parallelism을 통해서 작업을 더 빠르게 수행하는 방법 또한 다룰 것이다.\n\n---\n\n## **\\+ Amdahl's Law**\n\n작업의 성능을 개선시켰을 때 이전과 비교하여 얼마나 효율이 증가했는지를 보여주는 지표이다.\n\n$$1\\over{(1-P) + {P\\over{S}}}$$\n\n여기서 개선된 작업이 전체에서 차지하는 비율을 P라고 하고, 해당 작업의 향상된 작업 효율을 S라고 한다.\n\n만약, 전체에 10%를 차지하는 작업을 2배 빠르게 진행한다면,\n\n$${1\\over{(1-0.1) + {0.1\\over{2}}}} = {1\\over{0.95}} \\approx 1.05$$\n\n따라서, 단기간의 성능향상을 하고 싶다면, 비율이 큰 작업의 성능향상을 꾀하는 것이 좋다는 것을 알 수 있다.","slug":"architecture-base","title":"1. Base","category":"Computer Architecture","tags":["Computer Organization And Design","ISA"],"date":"2022년 4월 12일 00:00","thumbnailSrc":"https://euidong.github.io/images/default.jpg"},{"content":"\n## **Reference**\n\n![\u003cimg src=\"/images/default.jpg\" width=\"190\" /\u003e](/images/default.jpg)\n\nDavid A. Patterson, John L. Hennessy, Computer Organization and Design\n\n본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 \"-다\"로 표현합니다.\n\n---\n\n컴퓨터가 알아들을 수 있는 명령을 우리는 Instruction이라고 한다. 그렇다면, 이들을 모아놓은 단어장(Vocabulary)는 **Instruction set**이 되는 것이다. 이런 의미에서 현대의 computer는 이를 기반으로 동작하도록 설계되었기 때문에, 이를 **Instruction set architecture**라고 부른다. 해당 책에서는 MIPS를 기준으로 하기 때문에 똑같이 MIPS를 기준으로 설명합니다. 이는 다른 processor들과 매우 유사하니 이를 배우면 쉽게 다른 것도 이해할 수 있을 것이다.\n\n그렇다면, Instruction이란 무엇일까? 이는 기계어(0과 1로 이루어진 이진수 체계)의 형태로 표현된다. 따라서, 이를 Assembly Instruction이라고도 한다. 이는 hardware에게 특정 동작을 수행하도록 하는 명령어라고 할 수 있다. 그렇기에 우리가 실행하거나 작성하는 모든 program들은 사실 Instruction들의 집합이라고 볼 수 있다. 실제로 Computer에서 Program이 동작할 때, 이는 Computer는 memory에 program의 내용과 program에서 사용할 data들을 위한 공간을 배정해준다. 그런 후에 실제로 실행될 때에는 program의 Instruction을 차례차례 읽어가면서 실행하는 것이다.\n\n---\n\n## **Assembly Instruction의 구성요소**\n\n기본적으로 MIPS는 32bit(=4Bytes) 시스템을 사용한다. 따라서, 하나의 Instruction은 4 Bytes로 표현된다. 이를 하나의 가장 단위라고 여겨서 word라고도 부른다. 따라서, 64bit(=8Bytes) CPU에서는 1 word가 8 Bytes가 될 수도 있다. 결국 모든 Instruction이 0과 1로 이루어진다. 하지만, 이는 너무 읽기 어렵기 때문에 우선 Assembly(기계어보다는 사람의 언어에 가깝지만 아주 원초적인 형태의 언어) Instruction을 알아볼 것이다. 이를 기계어로 바꾸는 것은 해당 포스팅의 밑에서 다룬다. \n\n#### **1\\. Operand**\n\n연산을 위해서 필요한 것은 연산자와 피연산자이다. 보통의 programming 언어에서는 이를 변수라고 한다.\n\nMIPS에서는 총 두 가지의 변수 type이 존재한다.\n\n1.  **Constant**  \n    하나의 상수로써 동작하는 변수이다. 주어진 범위 내에서 자유롭게 상수로 사용가능하다.\n2.  **Register No**  \n    하드웨어 상의 register들과 programming에서의 변수와 차이점이 있다면, 바로 갯수의 제한이 있다는 것이다. 보통은 갯수를 32개로 제한한다. 그렇게 하는 것이 효율적이라고 찾아냈다고 한다. 더 많이 써도 Clock Cycle이 더 소모될 뿐이고, 적다면 표현력이 부족해지 수도 있다. 또한, 하나의 register의 크기 또한 우리는 대게 32bit(1 word)로 제한한다. 이를 표현할 때에는 보통 \\$ 표시를 활용하고, register는 특정 목적을 위해서 지정되어 있다. (밑에 표를 참고)  \n    Instruction에서는 Register를 가르키기 위해서 5bit를 사용한다. $2^5$이면 모든 Register를 구분할 수 있기 때문이다.\n3.  **Memory Address**  \n    해당 공간에는 기본적으로 register에 담기진 못한 모든 정보가 저장된다. 왜냐하면, register 가 하나의 변수를 표현할 수 있는데 만약, 변수가 32개를 넘어간다면, 이를 처리하는 것이 매우 버거워진다. 따라서, 이를 임시로 저장해두어야 한다. 따라서, 이를 memory에 잠깐 저장하는데 이를 **spilling register**라고 부른다.  \n    좀 더 복잡한 데이터 구조를 가지는 경우에도 이를 모두 register에 담는 것은 불가능하다. 따라서, 우리는 Memory라는 것을 활용한다. Memory는 8bit 단위로 한 칸으로 나누어 4개의 칸을 합친 것을 하나의 단위로 봅니다. (왜냐하면 이것이 4x8bit = 32bit = 1word가 되기 때문이다.) 따라서, 우리가 특정 값에 접근할 때에는 4의 배수로 접근하는 것이 올바른 접근이다. 또한, 하나의 데이터가 4개의 칸으로 쪼개지기 때문에 저장 방법에 차이가 있을 수 있다. 어떤 사람들은 앞 자리부터 차곡차곡 넣을 수도 있지만, 누구는 역순으로도 넣을 수 있기 때문에 이를 유의해야 한다. MIPS에서는 앞에서붙터 차곡차곡 넣는 Big Endian 방식을 사용한다. (즉, 4개 중 가장 낮은 주소값에 높은 값을 의미하는 값(MSB)이 쓰인다.)  \n    하나의 Memory address를 가르키기 위해서는 32bit가 필요하다. 이렇게 하여 $2^{32}$ = 4GB 이하까지의 Memory는 가르킬 수 있는 것이다. Instruction 자체가 32bit인데, 이를 Instruction에 바로 넣을 수는 없기 때문에 특정 Memory address를 가르키기 위해서 별도의 register에 해당 Memory의 address를 저장해두고 해당 지점부터 offset을 constant로 전달하는 식으로 표기한다.(여기서 4의 배수로 memory가 표현되므로, 2bit를 뺀다고 해도 30bit로 여전히 많다.)\n\n다음은 MIPS의 Register와 Memory를 나타낸 것이다.\n\n![\u003cimg src=\"/images/registers.png\" width=\"190\" /\u003e](/images/registers.png)\n\n상식적으로 알아두고 갈 부분은 reigster는 직접적으로 연산이 이루어지는 곳이기 때문에, register에 접근하는 비용이 memory에 접근하는 부분보다 확연하게 비용이 싸다.(시간이 짧게 걸린다.) 따라서, 이를 효율적으로 다루어주는 것이 효율 향상에 도움이 된다.\n\n#### **2\\. Operation**\n\n모든 computer는 기본적인 연산을 수행할 수 있어야 한다. MIPS에서는 다음과 같은 표기법을 사용한다.\n\n```\n1. \u003c명령어(operation)\u003e \u003c연산자(operand) 1\u003e \u003c연산자(operand) 2\u003e \u003c연산자(operand) 3\u003e\n\n2. \u003c명령어(operation)\u003e \u003c연산자(operand) 1\u003e \u003c연산자(operand) 2\u003e\n\n3. \u003c명령어(operation)\u003e \u003c연산자(operand)\u003e\n```\n\n마치 우리가 영어를 처음 배울 때, 1형식, 2형식 배우는 형태랑 유사하다. 그리고 여기서는 모든 문장이 명령형으로 구성된다는 점을 유의하자. 이에 따라서, 다음 MIPS의 피연산자(operand)와 주요 Operation을 살펴보자.\n\n\u003e **Add / Substract**\n\n`add [연산자1] [연산자2] [연산자3]`\n\n모든 연산의 기본으로 위의 형태 중에서 첫번째에 해당한다. 이를 수학 기호로 나타내면 다음과 같다.\n\n`[연산자1] = [연산자2] + [연산자3]`\n\nSubstraction 연산도 이와 동일하게 동작한다.\n\n\u003e **Load / Save**\n\n우리가 Register에 특정 데이터를 저장하기를 원한다면, $zero register 에 저장하기를 원하는 값 또는 register를 add해서 해당 register에 저장하면 된다.\n\n`add [저장을 원하는 register No] [$zero] [1234]`\n\n하지만, Memory에 데이터를 저장하기 위해서는 별도의 명령어가 필요하다. 그것이 save 명령어 입니다. 앞 서 말한 것과 같이 memory address를 직접적으로 Instruction에 표현할 수는 없기 때문에 특정 register에 주소값을 저장하고, 해당 주소를 base로 해서 offset을 더해서 주소를 찾는 형태로 수행한다.\n\n`sw [불러올 register No] [Memory의 Base Address를 가진 register No] offset`\n\n이와 반대로 Memory에서 데이터를 register로 불러올 때에도 별도의 명령어가 필요하다.\n\n`lw [불러올 register No] [Memory의 Base Address를 가진 register No] offset`\n\n\u003e **Jump**\n\nInstruction 역시 Memory에 상주하고 있는데, 만약 필요에 따라 이전 Instruction으로 돌아가거나 Instruction을 뛰어넘어야 한다면, 그때 사용할 수 있는 Instruction이다.\n\n`j [이동할 instruction offset]`\n\n\u003e **Branch**\n\nBranch(분기)는 특정 조건의 부합 여부를 확인하고, Jump를 수행하는 Instruction이다. 이를 위한 operator가 beq, bne가 있다.\n\n`beq [비교할 register1] [비교할 register2] [이동할 instruction offset]`\n\nregister1과 2가 서로 동일하다면, 해당 instruction offset으로 이동하라는 의미이다. bne는 반대로 두 register가 다를 때에 이동할 수 있다.\n\n\u003e **기타 주요 명령어**\n\n![\u003cimg src=\"/images/instruction.png\" width=\"190\" /\u003e](/images/instruction.png)\n\n\\* PC : Program Counter의 줄임말로 현재 실행하고 있는 Program에서 어느 위치의 Instruction을 실행시키고 있는지를 나타낸다. 이를 이용해서 CPU는 다음 Instruction을 불러온다.\n\n\\* offset : offset은 대게 instruction 단위로 나타내기 때문에 1 offset은 4Bytes를 의미한다. 따라서, offset을 실제 주소에 더할 때에는 곱하기 4(실제로는 shift left 2)를 해야한다. 이로 인해서, 현재 Instruction의 다음 Instruction의 주소를 PC+4 라고 한다.\n\n---\n\n## **Instruction를 이용한 \bProgramming 언어 기본 요소 구현**\n\n#### **1\\. 조건문 (if / else)**\n\n```\nif (i == j) \n\tf = g + h;\nelse\n\tf = g - h;\n```\n\n다음과 같은 c의 조건문 코드를 아래와 같은 Instruction들로 변환이 가능하다. \n\n```\nbne $s3, $s4, Else # go to Else if i != j\nadd $s0, $s1, $s2 # f = g + h (skipped if i != j)\nj Exit # go to Exit\n\nElse: \nsub $s0, $s1, $s2 # f = g - h (skipped if i = j)\n\nExit:\n```\n\n여기서 Else는 임의의 offset을 나타낸다. 따라서, \"Else:\"라고 표시된 부분에 해당하는 offset이라고 생각하면 된다.\n\nSwitch/Case 문 같은 경우는 if/else로 변환해서 나타내기도 하고, 아니면 Switching 위치를 적어놓은 Table을 만들어서 해당 위치로 바로 이동하는 식으로 구현하기도 한다.\n\n#### **2\\. 반복문 (while)**\n\n```\nwhile(save[i] == k)\n\ti += 1;\n```\n\n다음과 같은 c의 반복문을 아래와 같은 Instruction들로 변환이 가능하다.\n\n```\n# $t1 : save[i] address pointer\n# $t0 : save[i] value\n# $s3 : i\n# $s6 : save의 base address (save[0] address pointer)\n# $s5 : k\n\n# sll shift left \"\u003c\u003c\" 를 의미합니다. \n# 즉, 아래에서는 두 번하므로, *2^2를 의미합니다.\nLoop: \nsll $t1, $s3, 2 # temp reg $t1 = i * 4\nadd $t1, $t1, $s6 # $t1 = address of save[i]\nlw $t0, 0($t1) # temp reg $t0 = save[i]\nbne $t0, $s5, Exit # go to Exit if save[i] != k\naddi $s3, $s3, 1 # i = i + 1\nj Loop # go to Loop\n\nExit:\n```\n\n#### **3\\. 함수 (function)**\n\nprocedure는 대게 function(함수)이라고도 불린다. 함수를 우리는 하나의 예시를 통해서 설명할 수 있다.\n\nprocedure를 비밀 작전을 맡고 떠난 spy라고 하자. 작전은 자원을 습득하여, 특정 작업을 수행하고, 흔적을 감춘 뒤에, 바람직한 결과를 들고 돌아오는 것을 의미한다. 즉, spy는 작업을 마치고, 원하는 결과를 갖고 왔지만, 해당 결과 외에는 아무것도 바뀌지 않기를 기대한다. (누군가한테 의심받지 않아야하기 때문에)\n\n이러한 과정이 똑같이 함수의 호출마다 발생한다. 아래는 이를 다소 축약한 형태입니다.\n\n1.  parameter를 procedure가 접근할 수 있는 곳에 위치시킵니다.\n2.  control을 procedure(callee)로 옮깁니다.\n3.  procedure는 해당하는 자원(parameter)을 습득합니다.\n4.  목표한 바를 수행합니다.\n5.  결과값을 자신을 호출한 program(caller)이 접근할 수 있는 곳에 위치시킵니다.\n6.  control을 호출한 곳(caller)으로 넘깁니다.\n\n\\* 여기서 control이 이동했다는 것은 \bPC값이 PC+4가 아닌 함수의 주소로 이동했다는 것을 의미합니다.\n\n이를 구현하기 위해서 우리는 다음과 같은 별도의 register를 사용합니다.\n\n```\n$a0 - $a3 : 4 argument(=parameter) registers.\n$v0 - $v1 : 2 return value registers.\n$ra : 1 return address register. 원래 위치를 기억하기 위한 register.\n```\n\n\\$a와 \\$v는 사실 함수 사용에서 필수적이기 때문에 쉽게 받아들일 수 있지만, \\$ra가 의아할 수 있을 것이다. 이는 procedure를 호출했던 시점으로 다시 돌아오기 위해서 호출한 시점의 주소(실제로는 호출한 시점에서 다음 Instruction의 주소)를 저장하고 있는 것이다. 이러한 과정 즉, \\$ra에 저장과 jump를 동시에 해주는 것이 jal instruction이다. 이는 바로 다음 instruction을 가르키도록 하여 PC+4로 저장하고, 특정 지점으로 이동한다. 그리고 돌아올 때에는 jr instruction을 이용해서 \\$ra로 돌아올 수 있다.\n\n만약, 더 많은 변수를 return value, argument로 쓰고 싶다면 우리는 이를 memory로 옮기는 과정을 수행해야 한다. 이때, computer 에서는 stack이라는 구조를 사용한다. (실제로 구현하는 것은 아니고, 마치 stack 처럼 사용하기에 이렇게 부른다.) Stack pointer라는 register(\\$sp)를 이용하여 현재 사용하고자 하는 data가 stack의 어디를 가르키고 있는지를 저장한다.\n\n\u003e **실제 예제**   \n\n```\nint leaf_example (int g, int h, int i, int j) {\n\tint f;\n\t\n\tf = (g + h) - (i + j);\n\treturn f;\n}\n```\n\n```\nleaf_example:\naddi $sp, $sp, –12 # adjust stack to make room for 3 items\nsw $t1, 8($sp) # save register $t1 for use afterwards\nsw $t0, 4($sp) # save register $t0 for use afterwards\nsw $s0, 0($sp) # save register $s0 for use afterwards\n\nadd $t0,$a0,$a1 # register $t0 contains g + h\nadd $t1,$a2,$a3 # register $t1 contains i + j\nsub $s0,$t0,$t1 # f = $t0 – $t1, which is (g + h)–(i + j)\n\nadd $v0,$s0,$zero # returns f ($v0 = $s0 + 0)\n\nlw $s0, 0($sp)  # restore register $s0 for caller\nlw $t0, 4($sp)  # restore register $t0 for caller\nlw $t1, 8($sp)  # restore register $t1 for caller\naddi $sp,$sp,12 # adjust stack to delete 3 items\n\njr $ra # jump back to calling routine\n```\n\n해당 방식을 통해서, 만약 우리가 argument를 각 argument register 채워주고, \"jal leaf\\_example\"를 수행하게 되면, 해당 함수를 실행하는 것과 같은 동작을 하게 되는 것이다.\n\n하지만, 더 고민해야 하는 경우가 있다. 바로 함수 안에서 또 함수를 호출하는 경우이다.\n\n\u003e **Nested Function call(Function 내부에서 Function의 호출)**   \n\nprocedure가 또 procedure를 호출하는 경우에는 어떻게 해야할까? 이 때에는 간단한게 stack의 retuern address를 저장해놓고, \\$ra를 덮어씌우는 식으로 작동한다. 아래는 recursive call을 수행한 경우를 담은 내용이다.\n\n```\nint fact (int n) {\n\tif (n \u003c 1) \n\t\treturn 1;\n\telse\n\t\treturn n * fact(n-1); \n}\n```\n\n```\nfact:\naddi  $sp, $sp, –8    # adjust stack for 2 items\nsw    $ra, 4($sp)     # save the return address\nsw    $a0, 0($sp)     # save the argument n\n# slti 는 $a0의 값이 상수보다 작다면, 0 크다면 1이 저장됩니다.\nslti  $t0, $a0, 1     # test for n \u003c 1\nbeq   $t0, $zero, L1  # if n \u003e= 1, go to L1\n\naddi  $sp, $sp, 8     # pop 2 items off stack\n\naddi  $v0, $zero, 1   # return 1\njr    $ra             # return to caller\n\nL1: addi $a0,$a0,–1   # n \u003e= 1: argument gets (n – 1)\njal fact              # call fact with (n –1)\n\nlw $a0, 0($sp)        # return from jal: restore argument n \nlw $ra, 4($sp)        # restore the return address\naddi $sp, $sp, 8      # adjust stack pointer to pop 2 items\n\nmul $v0,$a0,$v0       # return n * fact (n – 1)\njr   $ra              # return to the caller\n```\n\n이제 끝일 거 같지만, 마지막으로 생각해야 할 게 있다. 바로 내부에서 또 local variable을 선언한 경우이다. 이 경우에도 memory에 공간에 저장해야 하는데 이때에도 stack pointer를 이동 시켜서 구현하는 것은 후에 동작에 혼란을 야기할 수 있다. 따라서, frame pointer라는 것을 추가로 할당하였다. 이는 함수의 진입 시점에 stack pointer의 초기 위치를 가르킨다. 따라서, 쉽게 후에 돌아올 지점을 알 수 있기에 stack pointer를 더 유동적으로 움직일 수 있다.\n\n---\n\n## **여러 변수 형태 표현법**\n\n#### **Signed Numbers**\n\n일반적으로 unsigned number라고 하면, 0과 양수를 포함하는 범위이다. 하지만, signed number는 음수까지 포함한다. 그렇다면, 컴퓨터에서는 음수를 어떻게 표현할 수 있을까?\n\n사람의 머리로 가장 쉽게 생각할 수 있는 방법은 부호를 나타내기 위한 별도의 표시 bit를 하나 넣어주면 될 거 같다는 생각을 할 것이다. 이것이 정확하다. 바로 오른쪽 끝에 있는 bit가 1이면 음수 0이면 양수로 보는 방식이다. 1이 맨 앞에 올 때는 0이 원래 1의 역할을 대신한다. 그리고 0이 앞에 올 때는 원래 계산하던대로 수행하면 된다. 그러면 놀랍게도 우리가 생각하는 것처럼 덧셈 뺄셈 연산이 동작한다. 그리고 오른쪽 끝에 있는 수를 우리는 MST 라고 하고, 이를 sign bit라고 부른다.\n\n```\n0000 0000 0000 0000 0000 0000 0000 0000(two) = 0(ten) \n0000 0000 0000 0000 0000 0000 0000 0001(two) = 1(ten)\n0000 0000 0000 0000 0000 0000 0000 0010(two) = 2(ten)\n...\n0111 1111 1111 1111 1111 1111 1111 1101(two) = 2,147,483,645(ten)\n0111 1111 1111 1111 1111 1111 1111 1110(two) = 2,147,483,646(ten)\n0111 1111 1111 1111 1111 1111 1111 1111(two) = 2,147,483,647(ten)\n1000 0000 0000 0000 0000 0000 0000 0000(two) = –2,147,483,648(ten)\n1000 0000 0000 0000 0000 0000 0000 0001(two) = –2,147,483,647(ten)\n1000 0000 0000 0000 0000 0000 0000 0010(two) = –2,147,483,646(ten)\n...\n1111 1111 1111 1111 1111 1111 1111 1101(two) = –3(ten)\n1111 1111 1111 1111 1111 1111 1111 1110(two) = –2(ten)\n1111 1111 1111 1111 1111 1111 1111 1111(two) = –1(ten) \n```\n\n\u003e **Proof  \n\u003e **\n\n```\n# 덧셈\n  1111 1111 1111 1110 (-2)\n+                   1 (+1)\n----------------------\n  1111 1111 1111 1111 (-1)\n\n\n                   11  (+3)\n+ 1111 1111 1111 1000  (-8)\n----------------------\n  1111 1111 1111 1011  (-5)\n\n\n# 뺄셈 1\n  1111 1111 1111 1110 (-2)\n-                   1 (+1)\n----------------------\n  1111 1111 1111 1101 (-3)\n\n\n# 뺄셈 2\n                   11  (+3)\n- 1111 1111 1111 1000  (-8)\n----------------------\n                   11  (+3)\n+ 0000 0000 0000 1000  (+8)\n----------------------\n  0000 0000 0000 1011  (+11)\n```\n\n연산을 하다보면, 당연히 너무 큰 양수를 더하게 되면 overflow가 발생할 수 있는데 이 경우 운영체제마다 compiler마다 처리 방식이 상이하다. C에서는 overflow가 되면 그대로 값을 내놓기 때문에, 대게 굉장히 큰 음수가 나오게 된다.\n\n#### **Character**\n\ncomputer에서 수가 아닌 값을 어떻게 표현할 수 있는가는 ASCII code 표가 답해줄 수 있을 것이다. 하나의 문자를 우리는 character라고 부르고, ASCII code 표와 같은 방식을 통해서 수를 글자로 변환하여 표현한다. 또한, 하나의 문자가 아닌 단어, 문장에 이르게 되면 이를 우리는 string이라고 하며, 이는 이 데이터의 길이를 표기하기 위해서 다음 3가지 중 하나를 선택하게 된다.\n\n1.  string의 가장 앞에 길이를 나타내는 값을 넣어준다.\n2.  string을 구조체로 만들어서 길이를 나타내는 값을 따로 넣는다.\n3.  string의 가장 끝 문자를 구분자로 채워서 구분할 수 있도록 한다. ⇒ C에서는 \\\\0 을 사용하여 구분한다.\n\n---\n\n## **Representing Instruction with Machine Language**\n\n위에 나온 MIPS Assembly code를 이제 MIPS의 기계어로 변환하는 과정을 수행할 것이다.\n\n다시 한 번 설명하자면, 우리의 program들은 사실상 instruction의 집합이라고 볼 수 있다. 또한, 현대의 컴퓨터는 이러한 instruction들을 memory에 마치 데이터처럼 쌓아서 실행시킨다. 그래서 우리는 이러한 프로그램 실행 방식을 **stored program** 이라고 부른다. 우리는 위에서 memory에 데이터를 저장하기 위해서 하나의 word 즉 32bit를 사용했다. 따라서, 우리의 instruction도 하나의 word 단위로 표현한다.\n\n아래 그림은 32bit의 각 각 부분이 무엇을 의미하는지를 표현한 것이다. 위의 연산을 표시하기 위해서 다음과 같이 word를 구분한다. 이때 주의할 점은 큰 값을 처리할 때에는 I-Type을 사용하기 때문에 형태가 기본형인 R-Type과는 다소 다른 것을 볼 수 있다.\n\n\u003e **R-Type**\n\n![\u003cimg src=\"/images/r-type.png\" width=\"190\" /\u003e](/images/r-type.png)\n\n-   op : opcode라고 불리며, instruction의 동작이 무엇인지를 정의한다. (ex. add, jump, ...)\n-   rs : first source register\n-   rt : second source register\n-   rd : destination register. 연산의 결과값이 저장되는 위치를 의미한다.\n-   shamt : shift amount라는 의미로 shift 연산을 사용할 때 이용된다.\n-   funct : op field에서 구체적인 동작을 정의할 때 사용한다.\n\n\u003e **I-Type**\n\n![\u003cimg src=\"/images/i-type.png\" width=\"190\" /\u003e](/images/i-type.png)\n\n-   op : opcode라고 불리며, instruction의 동작이 무엇인지를 정의한다. (ex. addi, jump, ...)\n-   rs : first source register\n-   rt : second source register\n-   constraint or address : 긴 값이 필요한 연산에서는 다음과 같은 형태로 표현한다.\n\n## **Addressing**\n\nMIPS는 여러가지 instruction을 가지고 있기 때문에, 주소를 targeting하는 방식도 여러가지이다. 또한, 따른 instruction set architecture에서도 다양한 방법을 통해서 memory의 주소를 가르킨다.\n\n1.  Immediate addressing : 상수를 통해 직접 address를 지정하는 방식이다.\n2.  Register addressing : register로 address를 지정하는 방식이다.\n3.  Base addressing : 상수에 특정 register값을 더해서 구하는 방식이다.(MIPS → Load Word, Save Word)\n4.  PC-relative addressing : PC 값에 상수 값을 더해서 구하는 방식이다. (MIPS → Branch)\n5.  Psedodirect addressing : PC의 맨앞 내자리를 가져와서 쓰는 방식이다. (MIPS → Jump)","slug":"architecture-instruction","title":"2. Instruction","category":"Computer Architecture","tags":["Computer Organization And Design","Instruction","ISA"],"date":"2022년 4월 14일 00:00","thumbnailSrc":"https://euidong.github.io/images/default.jpg"},{"content":"## **Reference**\n\n![\u003cimg src=\"/images/default.jpg\" width=\"190\" /\u003e](/images/default.jpg)\n\nDavid A. Patterson, John L. Hennessy, Computer Organization and Design\n\n본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 \"-다\"로 표현합니다.\n\n- Full Adder 이미지는 WIKIPEDIA full adder의 발췌이다. (https://upload.wikimedia.org/wikipedia/commons/5/57/Fulladder.gif)\n\n---\n\n여기서는 기본이 되는 **사칙연산**과 **소수점**의 표현방식(**Floating Point**)을 다룹니다.\n\n## Overflow\n\n시작하기에 앞서서 Overflow라는 개념을 알고가야한다. Overflow란 특정 변수의 표현범위를 벗어나는 경우에 발생하게 되는 에러 상황을 의미한다. 일반적인 사람의 생각에는 수의 범위가 있는 것은 이상할 수 있지만, 컴퓨터에서는 이것이 매우 당연하다. 무한대를 표현하는 것은 사실상 컴퓨터로는 불가능하다. 대신 매우 큰 수를 통해서 표현하는 것이 컴퓨터에게는 일반적이다. 예를 들어 우리가 빈번하게 사용하는 integer 변수 type은 그 값의 범위가 정해져있다. 이는 대게 하나의 변수를 표현하기 위해서 4bytes를 사용하는데 이는 32bits이기 때문에, 최대 $2^{32}$까지가 표현의 범위가 되는 것이다. 여기에 음수를 표현하게 되는 경우에는 범위가 $-2^{31}$ ~ $2^{31}$로 제한된다. 따라서, 이렇게 범위를 벗어나는 경우에 대해서는 programming language 마다 처리가 달라지지만, 대게 에러를 발생시키는 것이 일반적이다. (python에서는 알아서 범위를 추가한다.)\n\n## 덧셈 / 뺄셈\n덧셈은 각 자릿수의 합과 이전 자릿수에서 올림된 수(Carry)의 합이라고 다시 해석할 수 있다. \n이진수에서는 결국 올림된 수와 두 수가 만들어 낼 수 있는 경우의 수는 00 ~ 11이다.\n\n| A    | B    | Carry | Result |\n| :--- | :--- | :---- | :----- |\n| 0    | 0    | 0     | 00     |\n| 0    | 0    | 1     | 01     |\n| 0    | 1    | 0     | 01     |\n| 0    | 1    | 1     | 10     |\n| 1    | 0    | 0     | 01     |\n| 1    | 0    | 1     | 10     |\n| 1    | 1    | 0     | 10     |\n| 1    | 1    | 1     | 11     |\n\n이를 수행하기 위해서 우리는 XOR 2개와 AND 2개 그리고 OR 1개로 만들 수 있다.(C'와 S가 결과값이다.)\n\n| A    | B    | Carry(C) | A XOR B(D) | A AND B(E) | C AND D(F) | E OR F(C') | C XOR D(S) |\n| :--- | :--- | :------- | :--------- | :--------- | :--------- | :--------- | :--------- |\n| 0    | 0    | 0        | 0          | 0          | 0          | 0          | 0          |\n| 0    | 0    | 1        | 0          | 0          | 0          | 0          | 1          |\n| 0    | 1    | 0        | 1          | 0          | 0          | 0          | 1          |\n| 0    | 1    | 1        | 1          | 0          | 1          | 1          | 0          |\n| 1    | 0    | 0        | 1          | 0          | 0          | 0          | 1          |\n| 1    | 0    | 1        | 1          | 0          | 1          | 1          | 0          |\n| 1    | 1    | 0        | 0          | 1          | 0          | 1          | 0          |\n| 1    | 1    | 1        | 0          | 1          | 0          | 1          | 1          |\n\n![fullAdder](https://upload.wikimedia.org/wikipedia/commons/5/57/Fulladder.gif)\n\n### 음수\n\n음수는 기본적으로 2의 보수라는 방식을 활용한다. 만약 특정 수를 음수로 변환하고 싶다면 전체 수를 반전 시킨 후 `+1`을 수행하는 방식이다. 이를 통해서, 우리는 쉽게 음수를 생성할 수 있다. 그리고 놀랍게도 특정 수를 음수로 변환하고 덧셈을 하게 되면, 이것이 바로 뺄셈이 된다.\n\n## 곱셈   \n먼저 이진수의 곱셈은 아래와 같이 십진수에서의 곱셈 연산과 방법은 같다.   \n\n곱해지는 수(multiplicand), 곱하는 수(multipler), 곱해진 결과(product)이다.\n\n![곱셈 예제](/images/multiplication.png)\n\n하지만, 여기서 하나의 특징을 발견할 수 있다. 각 자릿수의 결과값은 곱하는 수에 의해서 결정된다는 점이다. 곱하는 수가 1이면, 곱해지는 수의 해당 자릿수가 결과값이 되고, 0이면 무조건 0이라는 결과가 나온다는 것을 알 수 있다. 따라서, 다음과 같은 알고리즘에 따라서 연산이 수행된다는 것을 알 수 있다.\n\n![곱셈 알고리즘](/images/multiplication-flow.png)\n\n만약, 음수의 곱셈의 경우에는 간단하게 해당 값을 양수로 변환하고, 연산을 수행한 뒤에 다시 음수로 변환하는 방식을 수행한다.\n\n## 나눗셈\n나눗셈은 역시 동일하다.   \n\n나누어지는 수(Dividend), 나누는 수(Divisor), 몫(Quotient), 나머지(Remainder) 이다.\n\n![나눗셈 예제](/images/division.png)\n\n이때는 역으로 나누는 수를 오른쪽으로 32번 shift하여 매우 큰 수로 만들고, 나머지를 나누어지는 수로 초기화하여 차근차근 빼보면서 양수이면 빼고, 음수이면 되돌리기를 반복하면서 몫과 나머지를 계산할 수 있다.\n\n\n![나눗셈 알고리즘](/images/division-flow.png)\n\n## 실수 연산\n\n위에서는 여태까지 정수의 연산을 다루었지만, 소수점을 포함하는 실수 연산을 수행할 때에는 달라지는 사항이 꽤나있다.    \n\n먼저, 실수를 표기하기 위한 방법을 먼저 보자.\n\n$$31231.4_{(10)} = 3.12314_{(10)} \\times 10^{4_{(10)}}$$   \n\n$$100101.1_{(2)}= 1.001011_{(2)} \\times 2^{101_{(2)}} $$   \n\n이를 일반적으로 normalization이라고 하며, 이진수 체계에서는 다음과 같은 형태를 갖게 된다.\n\n$$\\text{1.xxxxx} \\times 2^{yyyyy}$$\n\n따라서, 대게 실수를 표현할 때에는 x부분(fraction)과 y부분(exponent) 그리고 부호를 표현(sign)하는 부분으로 나누어서 저장한다. 이 또한, 4byte를 통해서 표현할 경우에는 x부분에 8bits, y부분에 23bits 그리고 부호에 1bit를 할당한다.\n\n따라서, 일반적으로 표현하면 다음과 같이 쓰는 것이 일반적인 실수의 표현이다.\n\n$$(-1)^s \\times(1+\\text{Fraction})\\times2^{(\\text{Exponent})}$$\n\n단, 모두 0이면 0으로 친다. floating point 연산은 후에 더 시간이 있으면 자세히 다루겠다.\n","slug":"architecture-arithmetic","title":"3. Arithmetic","category":"Computer Architecture","tags":["Computer Organization And Design","Arithmetic"],"date":"2022년 4월 27일 20:50","thumbnailSrc":"https://euidong.github.io/images/default.jpg"},{"content":"## **Reference**\n\n![\u003cimg src=\"/images/default.jpg\" width=\"190\" /\u003e](/images/default.jpg)\n\nDavid A. Patterson, John L. Hennessy, Computer Organization and Design\n\n본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 \"-다\"로 표현합니다.\n\n---\n\n해당 내용은 이전에 다루었던, [논리회로 리뷰 내용](/posts/digital-logic-circuit)을 보고 보는 것을 추천합니다.\n\n우리의 컴퓨터 시스템은 결국 Finite State Machine(유한상태장치)라고 할 수 있다. 즉, 순서에 따라 유한한 상태에서 다음 상태로 넘어가면서, Output을 계속해서 내보내는 장치라는 것이다. 이때 하나의 작업은 하나의 Clock 단위로 수행되며, 연속적은 작업 처리를 통해서 컴퓨터는 사용자가 요구한 명령을 수행하게 된다.\n\n\n## Processor\n\nprocessor와 program의 성능을 측정하기 위해서 우리는 다음과 같은 식을 활용하였다.\n\n$$\\text{instruction count} \\times \\text{Clock Cycle Time} \\times \\text{Clock Cycles per Instruction}$$\n\n[2. post](/posts/architecture-instruction)에서는 Instruction Count를 관리하고, 어떻게 계산되는지를 보았다면, **해당 포스팅에서는 Clock Cycle Time과 Clock Cycle per Instruction이 어떻게 구성되는지를 알아보며, 이들을 어떻게 줄일 수 있는지를 알아볼 것이다.**\n\n이를 위해서 우리는\n\n1. MIPS CPU의 가장 기본적인 구현\n2. pipeline된 MIPS\n3. Instruction 단계에서의 병렬화\n\n를 살펴볼 것이다.\n\n```\n 🤔 주의\n\n 해당 단계에서는 다음과 같은 사항은 배제한다.\n 1. multiply, shift, divide 연산\n 2. floating point 연산\n\n 결론적으로, 앞으로 구현할 MIPS에서는 다음과 같은 연산을 할 수 있다.\n 1. Memory에 접근하는 Load Word, Store Word\n 2. 기본 연산자 ADD, SUB, AND, OR, 등\n 3. Branch 구문 (BEQ, JUMP)\n```\n\n## 1. 기본적인 MIPS 구현(Single Cycle CPU)\n\n기본적인 processor에서 program이 동작은 다음과 같다.\n1. PC(Program Counter)를 Memory에 보내서 code를 포함한 부분을 특정하여 Instruction을 불러온다.(Instruction Fetch)\n2. 하나 또는 두 개의 register를 읽어서 Instruction을 수행한다.\n\n따라서, 이를 수행할 수 있는 논리 구조를 간략히 그려보면, 다음과 같은 형태를 가지게 됩니다.\n\n![Basic MIPS](/images/basic-mips.png)\n\n먼저, PC값의 형성 부분부터 보면 기본적으로 PC는 현재값에 4를 더하는 연산이기 때문에 상단에서 더한 값이 바로 다음 Clock에 적용된다고 할 수 있다. 그런데, 만약 Jump나 Branch 연산이 들어온다면, 해당 PC값에 특정값을 더한 결과로 이동하게 될 수 도 있다.\n\n그리고, 나머지 부분은 PC를 통해서 첫번째 박스에서 Instruction을 골라내고, Instruction의 특정 부분에서 OP와 register 등에 대한 정보를 토대로 Register와 상수 등을 이용하여 ALU 장치에서 OP 정보에 따라 연산을 수행한 뒤에 결과값을 특정 Register에 돌려주거나 Memory에 저장하도록 한다.\n\n물론 위에서는 **mux**(Multiplexor)에서 사용하는 데이터에 대한 내용은 빠져있지만, 아래 그림을 보면 더 정확하게 이해할 수 있을 것이다. 여러가지 경우의 수 중 상황의 따라서 output이 다른 경우에 mux를 사용하게 되는데, 여기서는 Instruction의 특정부분을 통해서 Control bits를 얻어내고, mux를 설치하여 적절하게 행동하도록 제어하고 있다. \n\n대표적인 예시로 아까 PC값을 선택하는 부분이 보다 명확하게 표시되는 것을 볼 수 있다. 현재 계산된 PC+4를 사용할 것인지 아니면, Branch 명령어에서 계산된 값을 사용할 것인지를 Control bit가 결정하는 것을 볼 수 있다.\n\n![Basic MIPS 2](/images/basic-mips2.png)\n\n이제부터는 각 단계별로 뜯어서 살펴본다.\n\n### 1) IF 단계 - Instruction Fetch\n\n해당 단계에서는 PC에 저장된 값에 따라서, Memory에서 Instruction을 추출하면서 PC에 4가 더해지는 것을 볼 수 있다. 그리고, Instruction의 특정 부분과 연산이 수행되는 것을 볼 수 있는데 이는 Branch 구문에 의한 이동을 위해서 주소를 저장해놓는 것이다.\n\n그리고, 이를 mux와 signal bit를 통해서, 최종적으로 다음 Program의 line을 가르킬 수 있다.\n\n![MIPS IF](/images/mips-if.png)\n\n### 2) ID 단계 - Instruction Decode and Register File Read\n\n해당 단계에서는 크게 두가지의 일을 한다.\n\n첫 번째는, Instruction에 포함된 정보를 기반으로 하여 Register를 선택하고, 해당 Register에 해당하는 정보를 내보내는 것이며,\n\n![MIPS ID](/images/mips-id1.png)\n\n두 번째는, Control bits를 생성하는 역할이다.\n\n![MIPS ID](/images/mips-id2.png)\n\n### 3) EX 단계 - Execution or Address Calculating\n\n다음 단계에서는 `R-Type`, `I-Type`에 따라서 두번째(2nd) Register를 사용할지 아니면, 상수로 받아들일지를 선택해야 한다. 이는 이전 단계(ID)에서 생성했던 Control bit를 mux에 통과시키는 식으로 구현한다. \n\n이후에는 control bit들을 통해서 연산의 종류를 선택한 후에, ALU 내부에서 연산을 수행하여 결과값을 내보낸다.\n\n결과값은 일반적인 결과를 내보내며, 추가적으로 beq 또는 여타 연산의 결과를 쉽게 알리기 위해서 zero라는 output으로 결과값이 0인지를 알려준다. 이는 다른 beq와 같은 연산에서 control bit로 사용한다.\n\n![MIPS EX](/images/mips-ex.png)\n\n### 4) MEM 단계 - Data Memory Access\n\nData Memory에 접근하는 동작으로 만약 Memory에 데이터를 update하는 동작을 한다면, MemWrite가 1로 설정되어있고, 이를 보고 명령어를 처리하게 된다.(read도 동일하게 MemRead를 활용한다.) 물리적으로 CPU와 떨어져있는 장비이기 때문에 접근하는데 많은 시간이 소요된다. 따라서, MIPS의 Instruction 실행의 모든 단계들 중에서 가장 오랜 시간이 필요한 연산이라고 할 수 있다.\n\n![MIPS MEM](/images/mips-mem.png)\n\n\n### 5) WB 단계 - Write Back\n\n실제로 Register의 값을 update해주는 부분으로 register의 update는 Data Memory에서 값을 불러오거나 연산 결과를 받을 때 사용하기 때문에 둘 중에 어떤 경우인지를 확인하여 데이터를 update한다.\n\n![MIPS WB](/images/mips-wb.png)\n\n위와 같이 하나의 Instruction을 수행하기 위한 일련의 작업이 한 Clock을 단위로 실행되는 경우를 Single Cycle CPU라고 한다.\n\n### 2. Pipelining\n\n가장 기본적인 구조를 살펴보았으니 위의 형태를 최적화하기 위한 가장 효과적이였고, 모든 CPU에서 사용되고 있는 설계 방법을 설명할 것이다. 위의 과정을 보고 있으면 우리는 비효율을 하나 발견하게 된다. **바로 특정 단계가 실행 중인 동안에 해당 단계에 포함되지 않은 장비들은 놀려지고 있다는 점이다.** 즉, 위에서 processor의 성능을 측정하는 지표인 Clock Cycle Time이 증가한다. 따라서, 모든 장비를 계속해서 실행시키기 위해서, 한 단계가 한 Clock이 되도록 하는 방법이 고안되었다.(Multi Cycle CPU) \n\n하나의 예를 살펴보자.\n\n세차장에 갔다고 하자. 우리는 당연히 일열로 서서 자신의 차례가 되기를 기다린다. 하나의 장비가 세차에 들어가기 전에 사람에 의해서 먼저 비누거품을 내는 단계가 있다면, 우리는 당연히 줄을 서있는 동안 세차장 아르바이트생이 비누칠을 해주기를 기다릴 것이다. 하지만, 해당 세차장에서는 만약 기다리는 동안 해주는 것이 아니라 세차 기계가 이전 차량에 대한 작업을 마치고 안정적으로 작업이 끝난 후에 비누칠을 해준다고 하자. 이것은 굉장한 짜증을 유발하는 요소가 될 것이다.\n\n따라서, Single Cycle CPU를 사용하는 것은 하드웨어 장비를 최적화하지 못한 사례라고 할 수 있다.\n\n위와 같이 단게를 나누어 여러 Cycle에 나누어 하나의 명령어를 처리하게 되면, 우리는 다음과 같은 효과를 얻게 된다.\n\n1. Clock Cycle Time이 줄어든다.\n2. 하나의 CPU가 동시에 여러 개의 명령어를 실행하게 할 수도 있다.(**Instruction Overlapping**)\n\n![Pipeline Example](/images/pipeline-example.png)\n\n이렇게 Instruction을 동시에(병렬적으로) 실행할 수 있다면, 1개의 Cycle 동안 Hardware 장치의 잉여 시간을 최소화할 수 있다.\n\n\n하지만, tradeoff 역시 존재한다.\n1. 각 단계의 연산이 끝난 후에 해당 값을 보관할 추가적인 하드웨어 장비(register)가 필요하다.\n2. Clock이 올라가고, 떨어지는 동안의 미세한 시간의 추가로 시간 비용이 증가한다.\n3. Clock Cycle Time은 반드시 하나의 상수로 정해져야 하기 때문에 가장 실행 시간이 긴 단계에 의존하게 된다. 즉, 실행시간이 더 짧은 단계라고 할지라도 다른 긴 단계가 있다면 기다려야 한다.\n4. 2와 3번을 이유로 결론상 하나의 Instruction을 수행하는데 걸리는 시간은 증가할 수 밖에 없다.    \n   그렇기에 결론상 단계를 생각없이 무조건 잘게 자른다고 좋은 것이 아니다. 바로 균등하게 많이 나눌 수 있는 만큼 나누는 것이 좋은 것이다.\n5. Instruction을 동시에 실행하는 것으로 인한 문제가 발생할 수 있다(Hazard). 이는 바로 다음 부분에서 다룬다.\n\n### Hazard\n\nHarzard는 아래와 같이 총 3가지의 종류가 있다.\n\n\u003e **1. Structural Hazard**   \n\nHardware가 구조적으로 동시에 특정 Instruction 조합을 처리하지 못할 경우를 의미한다. 즉, 서로 다른 pipeline stage에서 동일한 resource(Hardware)에 접근하고자 할 때 발생할 수 있다. 만약 Instruction Memory와 Data Memory의 분리가 되어 있지 않은 경우에는 이러한 문제가 IF, MEM 단계에서 발생할 수도 있지만, MIPS에서는 발생하지 않는다.\n\n\u003e **2. Data Hazard**   \n\n바로 Instruction이 서로 연관(의존)되어있을 때의 문제이다.\n\n다음과 같은 상황을 가정해보자. 우리가 memory에서 데이터를 불러와서 3을 더하는 연산을 한다고 하자. 그렇다면 명령어는 다음과 같다.\n```\nlw $v 0\naddi $v 3\n```\n이를 실행하면 불행하게도 load가 채 끝나기도 전에 채워지지 않은 \\$v에 3이 더해지는 것을 알 수 있다.\n\n이를 해결하기 위해서 3가지의 선택지가 있다.\n1. 의존성이 있는 명령어가 실행 중인 경우 끝날 때까지 대기 (**Stall**)    \n   가장 간단한 방법이지만, pipelining을 통한 성능 향상을 감소시킬 수 있다.\n2. Compiler 단에서 의존이 발생하는 Instruction 사이에 순서가 상관없는 Instruction을 끼워넣어서 resource가 낭비되지 않으면서 hazard가 발생하지 않도록 한다. (**Reordering**)   \n   Hazard를 해결하는 좋은 방법이지만, 항상 이것이 가능할 수는 없다.\n3. 추가적인 Hardware를 사용하여 결과값을 필요로 하는 resource에게는 단계를 생략하고 넘긴다. (**Forwarding**, **Bypassing**)    \n   현재까지는 가장 괜찮다고 받아들여지는 방법이다. 예를 들어서, EX 단계에서 ALU 연산이 끝나자마자 Write Back을 자체적으로 수행해주면 총 3번의 stall을 1번으로 줄일 수 있다.\n   \n\n\u003e **3. Control Hazard**   \n\nBranch Hazard라고도 불리며, 이전 Instruction의 결과에 따라서 실행시킬 Instruction이 변화할 때, 어느 Instruction을 실행시킬지 알 수 없기 때문에 발생하는 Hazard이다. (JUMP, BEQ)\n\n이 경우에도 총 3가지의 선택지를 가진다.\n1. 성공적으로 분기문이 실행될 때까지 대기한다.(**Stall**)\n2. 어느 곳으로 Branch가 될지를 예상하여, 미리 시행해둔다. (**Branch Prediction**)   \n   Resource를 최적화한다. 별도의 hardware를 설치하여 미리 JUMP 및 Branch address를 계산해 놓는다(**Hardware Optimization**)는 가정이 필요하다. 또한, 예측이 얼마나 적중하는가 역시 굉장히 중요한 요소로 작용한다.\n   대게 이러한 예측은 두 가지의 종류가 있다.\n   1. 정적 예측   \n      쉽게 생각할 수 있는 것은 반드시 실패한다고 생각하거나 성공한다고 생각해서 진행하는 방식이다. 좀 더 복잡한 방식은 loop문에 의한 branch인 경우 branch가 수행될 확률이 높다는 것을 기반으로 하여 성공 가능성이 크다고 예측할 수 있다.\n   2. 동적 예측   \n      이전 예측들을 기반으로 하여 현재 예측을 수행하는 방식이다. 이를 사용하면, 여러 번 반복되는 행위에 대한 예측율이 상당히 높아진다. 대게, 우리가 하는 분기문이 loop 등에 의한 경우가 많으므로 좋다고 할 수 있다. 또한, 최근에는 machine learning을 활용하여 예측을 수행하는 방식 또한 나오고 있다.\n3. Branch 여부에 상관없는 요청을 Control Hazard에 의해서 발생하는 구간에 넣는다. (**Delayed Decision**)\n\n\n## Parallelism via Instruction\n\nPipelining을 통해서, Instruction을 동시에 여러 개 실행시킬 수 있는 환경이 구축되었다. 그 와중에 resourece 자체를 하나 이상 두어서 Instruction을 동시에 수행할 수 있도록 하는 방식이 고안되었는데, 이를 Multiple Issue processor라고 한다.\n\n이를 대표하는 방식은 크게 두가지로 나눌 수 있다.\n\n### 1. Static Multiple Issue\n\n이는 compiler가 program을 기계어로 번역하는 과정에서 이루어지며, 대표적으로 다음과 같은 것들이 있다.\n\n1. VLIW(Very Long Instruction Word)    \n   의존성이 없는 여러 Instruction을 하나의 Instruction으로 뭉쳐서 실행시키는 방법이다. 이를 통해서 중첩되는 OPCODE 및 기타 처리 등을 최소화할 수 있다. Processor가 해당 기능을 지원하는 경우에만 사용가능하다.\n2. Loop Unrolling   \n   loop를 풀어서 여러 개의 Instruction으로 만들어서 branch로 인한 비용을 줄일 수 있다.\n\n### 2. Dynamic Multiple Issue\n\nprocessor에서 직접 Instruction이 실행되는 동안 이루어진다. 이는 여러 개의 pipeline을 CPU에 두어 이를 SuperScalar 방식이라고도 한다. 이를 효율적으로 수행하기 위해서는 앞 서 보았던 Compiler 단에서의 조율도 필요하며, 실행 중에 Instruction을 어떻게 나눌 것인가에 대한 Dynamic Scheduling 역시 매우 중요하다. 대표적인 예시가 OoO(Out of Order) Execution을 이용하는 것이다. Instruction의 Fetch를 순서대로가 아닌 의존성에 알맞게 실행되도록 조절하는 방식이다.","slug":"architecture-processor","title":"4. Processing","category":"Computer Architecture","tags":["Computer Organization And Design","Processing","MIPS Implementation","Pipeline","Branch Prediction","SuperScalar"],"date":"2022년 4월 28일 19:25","thumbnailSrc":"https://euidong.github.io/images/default.jpg"},{"content":"\n## **Reference**\n\n![\u003cimg src=\"/images/default.jpg\" width=\"190\" /\u003e](/images/default.jpg)\n\nDavid A. Patterson, John L. Hennessy, Computer Organization and Design\n\n본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 \"-다\"로 표현합니다.\n\n---\n\n컴퓨터를 사용할 때, 우리는 기본적으로 Memory가 무한한 크기를 가지고 있기를 바란다. 하지만, 이를 실제로 구현하는 것은 비용적으로도, 기술적으로도 불가능하다. 따라서, 이를 마치 존재하는 것처럼 느끼도록 하는 기술을 사용한다.\n\n이를 위한 핵심은 `Locality`를 활용하는 것이다. 동작에는 인과가 존재하고, 그렇기에 직전에 자신이 했던 행동 그리고 근처의 대상들이 했던 행동이 지금의 자신이 할 행동에 영향을 주는 것은 어찌보면 당연한 사실이다. 이러한 특징이 `Locality`이다. 이를 이용해서 우리는 Memory를 마치 무한인 것처럼 느낄 수 있게 할 수 있다.\n\n1. **Temporal Locality**   \n   하나의 Instruction 또는 data가 사용되었다면, 해당 내용은 곧 다시 사용될 확률이 매우 높다.(반복문일 경우에는 극명하게 드러날 것이다.)\n2. **Spatial Locality**   \n   하나의 Instruction 또는 data가 사용되었다면, 후에 이 근처에 있는 내용을 사용할 확률이 매우 높다. (일반적으로 연속적으로 동작하는 경우가 많기 때문에 근처의 명령어들을 같이 가져올 수 있다면, 가져오는 것은 합리적이다.)\n\n이를 활용하기 위해서, 우리는 **Memory Hierarcy**라는 방법을 사용한다. 즉, 메모리를 계층화하는 것이다. 모든 장치를 빠르고, 크고, 싸게 만들 수 있으면 좋겠지만, 실제로는 불가능하기에 빠르고, 작은 장치를 processor에 가까이에 두고, 그 보다는 덜 빠르고, 큰 장치를 좀 더 거리를 두고 위치시키는 방식이다. 이렇게 하면 이용자에게 싸면서, 빠른 시스템을 제공할 수 있다.\n\n이를 위해서, 우리는 더 멀리 있는 Memory에서 정보를 복사해서 더 상위의 Memory에 붙여넣기하는 것이다. 계층 구조이기 때문에 한 번에 수행되는 것이 아니라 여러 단계가 있다면, 차근차근 순서에 맞춰서 수행된다. 즉, 단계를 skip하여 이동하는 것은 불가능하다.\n\n만약, 상위 Memory 장치에서 원하는 정보(Block, Line)를 찾았다면 이를 `hit`라고 하고, 찾지 못했다면 이를 `miss`라고 한다. 또한, `hit time`은 상위 Memory가 해당 Block에 접근하는데 걸리는 시간을 의미한다. 반대로 `miss penalty`는 상위 Memory로 해당 Block을 위치시키는 시간과 Block을 processor에 전달하는 시간까지를 포함한다.\n\n---\n\n시작하기에 앞 서, 컴퓨터 공학을 공부하는 누구나 겪는 현상이라고 생각하는데 바로 Memory 파트는 언어가 매우 자기 멋대로 나오는 경향이 있다. 즉, 깔끔한 정리가 되지는 않았다. Memory가 어떨 때는 Main Memory를 의미하다가 전체 모든 저장 장치를 의미하기도 한다. 따라서, 이 아래부터는 다음과 같이 엄격하게 분리하여 설명한다.\n\n1. Memory : 모든 저장 장치들을 의미한다. 즉, cache, secondary storage, main memory 등을 모두 포함한 개념이다.\n2. Cache : Processor에 붙어서 바로 동작하는 Memory 장치\n3. Main Memory : 우리가 주로 RAM이라고 부르는 장치\n4. Secondary Storage : 주로 HDD, SSD로 이루어지는 보조 기억 장치\n\n\n## Memory Components\n\n시작하기에 앞서 실제로 메모리를 이루는 구성요소들을 먼저 살펴보고 간다.\n\n1. **DRAM**(**Dynamic Random Access Memory**)   \n   Main Memory에 주로 사용되는 장치로 SRAM보다는 느리지만, 확실히 많은 데이터를 저장할 수 있다. 하나의 bit를 저장하기 위해서 1개의 transistor를 사용하는데, 이 transistor에서 전력이 새어 나가기 때문에 정보를 잃는 것을 막기 위해서 주기적으로 refresh를 해주어야 한다.   \n   Random Access라는 의미는 순차적으로 앞에서부터 탐색하는 방식이 아니고, 찾고자하는 데이터를 바로 찾을 수 있다는 의미이다. 따라서, 앞에서부터 찾는 방식보다 더 빠를 수 밖에 없다.   \n   휘발성 저장 장치이기 때문에 전력이 공급되지 않으면 정보를 모두 잃는다.\n2. **SRAM**(**Static Random Access Memory**)   \n   Cache에 주로 사용되는 장치로 매우 빠른 연산이 가능하지만, 크기를 크게 만들기 위해서는 비용이 너무 비싸진다는 단점이 있다. 하나의 bit를 처리하기 위해서 6개의 transistor를 사용한다. 이 덕분에 전력을 다시 공급해주는 refresh 과정이 필요없다.   \n   과거에는 processor 밖에서 chip 형태로 존재하였지만, 점점 회로가 집적이 되며, processor에 통합되었다.   \n   휘발성 저장 장치이기 때문에 전력이 공급되지 않으면 정보를 모두 잃는다.\n3. **Flash Memory**   \n   Electrically Erasable Programmable Read-Only Memory(EEPROM)의 한 종류이다. 다른 장치들과는 달리 write가 flash memory를 닳게 만들 수 있다. 따라서, 대부분의 flash memory는 한 bit를 쓰기가 집중되는 현상을 막기 위해서, 이를 분산시키는 방식을 사용한다. (wear leveling, 쓰기 횟수에 제한이 존재한다.) 이는 대게 모바일 장치들의 저장 장치로 많이 사용되며, PC에서 사용하는 SSD와 매우 유사하다.\n4. **Magnetic Disk**   \n   일명 자기 테이프 방식으로, 다른 장치들과는 다르게 자기력을 이용하여 정보를 저장하는 방식이다. 실제로 물리적으로 존재하는 Disk로 하여 Hard Disk라고도 부른다.이를 읽고 쓰기 위해서는 arm(팔)이라는 개체가 disk의 정보가 스여진 위치로 이동해야 읽을 수 있다. 따라서, 이것이 물리적으로 움직이는 시간이 소요되기 때문에 여타 Random Access 장비보다 느릴 수 밖에 없다. 하지만, 이를 통해서 저장할 수 있는 정보의 양은 매우 많다.\n\n## Cache\n\nMain Memory와 Processor 사이에서 memory hierarchy를 수행하는 장치라고 한다. 하지만, 현대에는 이러한 구조에 영감을 받아서 cache를 여러 곳에서 사용하기 때문에, 많은 분야에서 이를 **locality의 장점을 활용하기 위한 일종의 저장소**라는 의미로 많이 사용한다.\n\n### Cache의 역할\n\nCache가 수행하는 역할은 저장 장치이기 때문에 읽기와 쓰기가 가능해야 한다.\n\n\u003e **Read**\n\n읽기를 수행하기 위해서 Cache에서는 다음과 같은 동작을 수행할 수 있어야 한다.\n\n1. **Main Memory의 데이터를 일부 저장할 수 있어야 한다.**   \n   Cache는 Main Memory보다 크기가 작기 때문에 Main Memory의 모든 데이터를 저장하지 못한다. 따라서, 일부분을 저장하는데 이를 저장할 때, 기존의 Main Memory에서의 데이터의 address를 cache의 크기만큼 나누어 cache의 범위에 들어오도록 하는 것이 Directed Mapping이다. 따라서, 다음과 같은 식이 성립한다.(여기서의 Block이란 한 번에 cache로 가져올 데이터의 단위를 의미한다.)   \n   $\\text{Cache에서 Block의 주소} =$ $\\text{(Main Memory에서 Block의 주소)} \\%$ $\\text{(Cache의 용량)}$ \n2. **특정 word가 cache에 존재하는지 확인할 수 있어야 한다.**   \n   이를 위해서 우리는 tag를 이용한다. cache 공간으로 address가 변환되어서 생략된 address를 포함하고 있다. 즉, cache의 index로 쓰이지 않은 Main Memory Address의 상위값을 가지고 있다. 쉽게 생각해서 위에서 만들어진 Cache의 Block 주소가 나머지라면, tag는 몫이라고 볼 수 있다. 따라서, tag는 담기는 데이터에 따라서, 계속해서 변하여 저장되는 값이다.\n3. **해당 데이터가 타당한지 확인할 수 있어야 한다.**   \n   만약, system을 막 booting시켰다면, cache에는 모두 이상한 값이 들어갈 것이다. 따라서, 잘못된 값을 참조할 수도 있다. 따라서, 우리는 **valid bit**(1 bit)를 이용하여, 해당 값이 적절하게 할당한 값인지를 표기한다.\n4. **덮어 씌우기가 가능해야 한다.**   \n   이 경우는 간단히 덮어 씌어버린다. 이는 앞 서 설명한 **temporal locality**와 일맥상통한다. 최근에 쓴 데이터가 다시 호출할 확률이 높기 때문이다.\n\n\u003e **Example**   \n\n왼쪽이 Cache고, 오른쪽이 Main Memory이다.\n\n1. 초기 상태\n\n![directed-mapping-1](/images/directed-mapping-1.png)\n\n2. 001011 요청\n\n![directed-mapping-2](/images/directed-mapping-2.png)\n\n3. 001011 재요청\n\n![directed-mapping-3](/images/directed-mapping-3.png)\n\n4. 110011 요청\n\n![directed-mapping-4](/images/directed-mapping-4.png)\n\nBlock 단위를 4Bytes로 했다면, 하나의 word 단위가 Block의 단위가 될 것이다. 그렇지 않고 더 큰 단위로 Block을 저장할 수도 있다. 일반적으로는 이 Block의 단위를 늘리면 miss rate를 낮출 수 있다. 근처의 데이터를 한 번에 여러 개 가지므로, **spatial locality**를 활용할 수 있다. 하지만, 과도하게 늘리게 되면, 오히려 이로 인해서 index가 표현할 수 있는 범위가 점점 작아진다. (한 마디로 cache의 전체 크기(용량)은 고정이기 때문에, 가로를 의미하는 block의 사이즈가 늘어나면, 세로를 의미하는 index의 범위가 줄어들 수 밖에 없다.) 이로 인해서 block size를 너무 크게 늘리게 되어도, miss rate는 증가하게 된다. 뿐만 아니라 miss penalty도 크게 증가한다. 해당 데이터를 cache에 끌어오는 동안의 시간이 증가할 것이기 때문이다. 따라서, 적당한 크기의 block 사이즈를 지정해야 한다.\n\n마지막으로, Cache를 읽기를 요청하였지만 해당 정보가 없는 경우 이를 `Miss`라고 하는데, `Miss`가 발생하면 이 데이터를 Main Memory에서 불러오기 위해서 어쩔 수 없이 우리는 stall을 수행해야 한다. 이러한 `Miss`는 굉장한 비용을 발생시키기 때문에 대게 세가지 방식에 의해서 이를 해결한다. \n1. Multiprocess or Multithread 환경에서는 다른 process를 해당 stall 동안 실행시켜서 이를 해결한다.\n2. OoO(Out of Order) Execution을 지원하는 장비에서는 이를 통해서 stall을 방지한다.\n3. Software를 개발할 당시에 해당 사항을 인지하고 최적화를 수행하는 것이다. cache의 hit 정도를 아래 그림에서 오른쪽과 같이 설정하게 되면, 결론적으로 hit 확률이 급격하게 증가하는 것을 알 수 있다. 이런식으로 Cache 크기에 유의하여 소프트웨어를 해당 장치에 최적화하는 방식도 존재한다.\n\n![software-optimize](/images/software-optimize.png)\n\n\u003e **Write**\n\n데이터를 Main Memory로 write하는 상황을 생각해보자. cache에서 작업을 진행하여 해당 위치에만 데이터를 최신화하게 되면, 필연적으로 cache와 Main Memory 사이에서 불일치가 발생할 수 밖에 없다. 따라서, 이를 해결하기 위한 방법이 세 가지가 있다.\n\n1. **Write Through**   \n   가장 간단한 방법으로, write가 발생하면, 모든 저장 장치의 일관성을 유지하기 위해 모두 update 해주는 것이다. 그러나, 이 write의 비용이 엄청나게 크다는 것을 알기 때문에 이를 최대한 적게 하는 것이 사실상 performance 향상에 핵심이라고 생각하면, 이는 실제로 사용하기에는 무리가 있다.\n2. **Write Buffer**   \n   Main Memory에 쓰이기를 기다리는 buffer를 만들어 놓고, 해당 장치에서 write를 일임하여 놓는 방식이다. 이를 이용하게 되면, Write의 완료를 cache에서 더 이상 기달릴 필요가 없다. 하지만, Write 명령어를 processor가 처라하는 속도가 buffer가 Main Memory에 쓰는 속도보다 훨씬 빠르기 때문에 당연하게 buffer가 꽉찰 수 있다. 그렇게 되면, 반드시 공간이 날 때까지 stall을 해야만 한다.\n3. **Write Back**   \n   이 방식은 일관성을 포기하는 방식이다. 즉, 데이터를 가지고 있다가 실제로 이 값이 다른 값으로 변경될 때, cache의 특정 index에 있는 값이 다른 tag의 값으로 변경될 때에만 데이터를 쓰는 방식이다. 또는 강제적으로 하위 memory로의 저장을 요구할 경우에만 쓰도록 한다. 이를 이용하면, 성능은 확연히 올라가지만, 불일치성으로 인해 발생하는 문제를 해결하기 위해서 더 복잡한 요구사항이 발생한다. (일단 cache의 table에 각 row에 해당 값이 하위 Memory에서 copy된 이후로 변경되었는지를 표시하는 dirty bit가 필요하며, multi processor 환경에서는 더 큰 문제를 야기한다.)\n\n### 더 나은 Cache 저장법\n\n`Directed Mapping`을 통해서 Cache에 데이터를 저장하게 되면, 특정 Block이 위치할 수 있는 장소가 고정되어 버린다. 만약, index가 겹치는 값이 동시에 여러 번 사용된다면, miss rate가 크게 증가할 수 밖에 없다. 여기서, cache의 위치를 고정하지 않고, 자유롭게 하여 이러한 문제는 크게 줄일려고 하는 방법이 있다.\n\ntag에 모든 address 값을 저장하고, index를 address의 값으로 전혀 사용하지 않는 방식이 있다. 이것을 `full-associative cache`라고 한다. 이 경우에는 해당하는 index 범위에서 tag가 존재하는지를 확인하기 위해서 추가적인 연산이 필요하지만, hardware 장치를 추가적으로 배치하여 이를 동시에 실행시켜 성능을 향상시키는 방식을 택한다. 이 방식은 결론적으로 많은 hardware 장비를 추가적으로 요구하기 때문에 매우 비싸진다. 따라서, 적당한 합의점을 찾는 것이 `set-associative cache`이다. 이는 index 값을 일부만 이용하는 방식이라고 할 수 있다. 즉, 3bits를 index로 사용하는 cache에서 상위 n개의 bit만 실제로 사용하여 표현하는 것이다. 동일한 index를 가진 block은 $2^{전체 bit 수 - n}$ 존재하게 된다. 여기서, 이제부터 tag를 통해서 사용해서 검색을 수행하는 것이다. 따라서, 만약 n이 전체 bit 수와 같아 진다면, 이것이 `full-associative cache`가 되는 것이고, n = 0이라면, 일반적인 `Directed Mapping`이 되는 것이다.\n\n![set-associative](/images/set-associative.png)\n\n그렇다면, 이렇게 여러 개의 index가 data를 담을 수 있는 그릇이 될 때, 어느 위치에 값을 덮어 씌우는 것이 현명할 것인가는 **temporal locality**에 따라서 우리는 가장 쓰인지 오래된 index에 값을 덮어씌운다. 이것이 LRU(Least Recently Used) 방식이다. 이를 구현하기 위해서는 cache에 추가적인 reference bit라는 것을 위치시킨다.\n\n\n\n### MultiLevel Cache\n\n이제 cache를 여러 개 층(multilevel cache)을 이루어 사용한다고 해보자. process에 가까운 쪽을 primary cache라고 하고, 그 다음을 secondary cache라고 하자. 만약, primary cache에서 miss가 발생했을 대, secondary cache에 있으면, miss penalty를 줄일 수 있을 것이다. 하지만, secondary cache도 miss가 나면, miss penalty자체가 증가한다. 왜냐하면, secondary 로 불러오고, 다시 primary로 옮겨야 하기 때문이다. 그렇기에 무조건 cache를 많이 둔다고 좋은 것은 아니다. 적절한 cahce를 설정하는 것이 중요하고, 대게 이는 3개 정도로 한다.\n\n그리고 직관적으로 각 cache를 보면, primary cache는 hit time을 줄이는 것이 목표이고, secondary cache는 miss rate를 줄여야 한다. 그래서, primary cache에서는 block size를 줄이고, associative의 크기를 줄이지만, secondary cache에서는 block size를 키울 뿐만 아니라 associative의 크기 역시 키우는 것이 일반적이다.\n\n## Virtual Memory\n\nMain Memory를 안정적으로 관리하기 위해서, Virtual Memory라는 개념을 도입한다. 이는 실제로 존재하는 Main Memory와 Secondary Storage의 주소(**Physical Address**)를 가상의 주소(**Virtual Address**)로 바꾸고, 필요에 따라 이를 번역하여 사용함으로써, 하나의 process가 마치 Main Memory 하나를 장악하고 있는 거 같은 느낌을 느끼도록 할 수 있다. 왜냐하면, 당장에 쓰지 않는 process의 data는 Secondary Storage로 빼놓고, Virtual Address로 번역 시에는 해당 위치를 가르키도록 하면 된다. 그러면, 마치 각 process는 Main Memory 이상의 data를 갖고 있는 것 같다고 느낄 수 있다. 이러한 Virtual Memory를 이용하면 다음과 같은 작업을 쉽게할 수 있다.\n\n1. **동일한 장치에서 program 간의 Memory 영역을 구분할 때**, 일반적으로 Main Memory에 있는 데이터 역시 **locality**에 따라 계속해서 바뀌게 되는데, 특정 process 전체 크기를 실행 중일 동안 계속해서 제공한다면, 유연한 동작이 어렵다. 따라서, Virtual Memory는 이를 더 쉽게 하도록 돕는다.\n2. **동일한 장치 내에서 돌아가는 Virtual Machine간의 Main Memory 영역을 구분할 때**, 각 Virtual Memory는 Physical Memory로 번역되었을 때, 서로 충돌하지 않는 것을 보장하기 때문에 서로 다른 process간에 간섭이 없음을 보장할 수 있다.\n3. **Main Memory 보다 큰 크기의 Program을 돌리고자 할 때**, Main Memory 이상의 process를 돌리기 위해서는 Secondary Storage에 직접적인 접근을 수행해야 하는데, 이를 수행하지 않고, 실제로 현재 사용하지 않는 Memory 공간의 데이터는 Secondary Storage로 옮기고 이를 가르키는 Virtual Address만 바꾸어주면 되기 때문에, 쉽게 Main Memory 보다 큰 크기의 Program을 동작시키는 것도 가능하다.\n\nVirtual Memory 방식은 각 program, Virtual Machine마다 고유한 address space를 가지기 때문에 각자 독립되었다고 볼 수 있다. 그렇기에 각자가 서로의 동작으로 인한 영향을 받지 않는다. 즉, 다른 process에서 사용 중인 Memory에 접근할 수 없을 뿐만 아니라 이들에 의해서 발생하는 Memory의 변화가 자신이 진행 중인 process에 영향을 미치지 않는다. 즉, protection를 제공한다고 할 수 있다.\n\n또한, program을 상호간의 영향이 없는 조각으로 나눈 Overlay 단위로 나누어 초과되는 용량은 Secondary Storage에 상주시키고, 필요에 따라 Main Memory로 올려서 실행시킬 수 있다. 따라서, 용량이 부족한 Main Memory에서도 이보다 큰 크기의 Program을 동작시킬 수 있다.\n\nCache의 방식과 매우 유사하지만, 언어의 기원이 다르기 때문에 여기서는 Block을 **Page**라고 부른다. 그리고, 이 Page의 크기는 Page Offset이라고 표기한다. 따라서, **Virtual Address**는 사실상 두 개의 Part로 나뉘어진다. 첫 번째는 **Virtual Page Number**이고, 하나의 **Page offset**이다. 또한, Miss는 **Page Fault**라는 말로 바뀌어진다. 마지막으로, Virtual Address에 Mapping 되는 Physical Address를 Physical Page Number와 Page offset으로 이루어진다.\n\n위에서 말한 것처럼 Virtual Address를 Physical Address로 바꾸는 과정을 **Address Translation**이라고 한다.\n\n### Page 관리\n\n\u003e **Virtual Page Number를 통해서 실제 Physical Page Number로 변환하기**\n\n기존의 Cache에서도 Miss로 인한 비용도 컸지만, **Page Fault**의 비용은 이보다도 훨씬 크다고 할 수 있다. 이를 막기 위해서, Cache에서는 Full Associative한 구조를 가져갔지만, Main Memory는 Cache보다 훨씬 크기 때문에 이를 위한 추가적인 Hardware를 추가하는 것은 경제적으로 불가능하다고 볼 수 있다. 따라서, Main Memory에 존재하는 Page의 Address를 Mapping하기 위해서 table을 이용한다. 이를 **Page Table**이라고 부른다. 이는 Main Memory에 상중하고 있다. 각 각의 program은 고유의 Page Table을 하나씩 가지게 되며, Page Table 자체의 처음과 끝을 가르키는 register를 가지고 있다(**Page Table Register**). 그리고 Page Table에는 Virtual Page가 지금 어느 Physical Address에 존재하는지에 대한 정보와 이것이 Main Memory에 있는지를 표기하는 Valid Bit가 존재한다. 만약, Valid Bit가 0이라면, 이는 해당 Page가 지금 Main Memory가 아닌 Secondary Storage에 존재한다는 뜻이다. \n\n따라서, Page를 찾는 과정은 다음과 같다.\n1. Page Table Register를 기반으로 하여 Main Memory에서 **Page Table을 찾는다**.\n2. Virtual Address의 Virtual Page Number를 이용해서 Page Table에서 Page를 조회한다.\n3. Valid Bit를 확인하여 해당 Page가 현재 Main Memory에 존재하는지 아니면 Secondary Storage에 존재하는지를 확인한다.\n4. 이제 실제 Physical Page Number를 얻어와서, 기존의 Page Offset을 합치면, 이것이 Physical Address가 된다.\n\n```\n  \n  🤔 Page Table의 크기가 너무 크면 어떻게 될까?\n\n  Page가 너무 많아지면, Page Table의 크기가 너무 커질 수 있다.\n  따라서, 이를 해결하기 위해서 계층 구조를 가지고 정리한다. \n  즉, Page Table의 Table이 생기는 형태라고 보면 되겠다.\n\n```\n\n\u003e **Page Fault**\n\n위에서 말한대로 Page Fault가 발생한다면, 즉 Valid Bit가 0인 경우, 해당 Page를 Secondary Storage에서 찾고, 이를 Main Memory의 어느 위치에 놓을지를 결정해야 한다.\n\n우리가 번역한 Physical Address는 Secondary Storage의 직접적인 주소를 의미하기도 하지만 대게는 이를 이용해서 실제 Secondary Storage의 주소를 찾을 수 있도록 하는 자료구조를 가르키도록 되어있다. 그래서, 우리의 Operating System은 Process가 생성될 때, Process의 모든 Page를 Secondary Storage에 저장할 공간을 생성한다. 이를 `Swap Space`라고 부르며, 해당 Virtual Page가 실제 disk의 어디에 저장될지를 기록한 자료구조이다.\n\n만약, 이제 모든 Main Memory가 Page로 가득 차 있다면, OS는 어떤 Page를 대체할 것인지를 선택한다. 이때는 LRU(Least Recently Used) Algorithm을 사용한다. 지금까지 가장 사용하지 않은 Page를 삭제하는 것이다. 이를 구현할 때는 Reference bit를 설정하고, 주기적으로 0으로 변경하기를 반복하면서, 해당 Page를 사용할 때마다 1로 변경주는 것을 수행하는 것이다. 그리고, Page Fault가 발생할 시에 Reference Bit가 0인 대상이 있다면, 이를 우선으로 제거하는 방식이다.\n\n\u003e **Write**\n\nWrite하는 것은 굉장히 많은 시간을 소요한다. 따라서, Virtual Memory System에서는 이를 최소화하는 것을 목표로 하기 때문에 이전에 소개한 Write Back이 default이다.\n\n\u003e **TLB를 이용한 변환작업 속도 향상**\n\nPage Table이 실제로 Main Memory에 저장되기 때문에 우리는 Page를 조회하기 위해서 결국 무조건 Main Memory에 한 번 접근해야 한다. 이는 많은 시간을 소요하는 동작이기에 이를 최소화할 방법이 필요했다. 또한, Temporarl / Spatial Locality에 따라 사용한 Page는 다시 사용할 확룰이 많다. 따라서, 대게의 processor에서는 이를 위한 특별한 cache를 추가로 가지고 있다. 이것이 TLB(Translate Lookaside Buffer)이다. (아마 Translation cache라고 부르는 것이 더 자연스럽긴 할 것이다.) 따라서, TLB는 Virtual Page Number와 Dirty Bit, 그리고 Reference Bit를 가진다. TLB를 설계할 때에는 fully associative하게 만드는 것이 기본이다. 왜냐하면, TLB 자체가 매우 작고, hit rate가 성능에 큰 영향을 미치기 때문이다. 이렇게 구축하는 것이 성능에 큰 도움이 된다. 또한, replacing을 할 때에도 LRU를 구현할 수도 있지만 대게 이를 구현하기가 너무 경제적으로 어렵기 때문에, 대부분의 system은 랜덤하게 고르는 것을 선택한다고 한다.\n\n\n따라서, Page를 얻는 과정은 다음과 같다고 다시 요약할 수 있다.\n\n1. Page Table Register를 기반으로 하여 TLB에서 **Page Table을 찾는다**. 존재하지 않는다면, Main Memory에서 조회해야 한다.(TLB miss)\n2. Virtual Address의 Virtual Page Number를 이용해서 Page Table에서 Page를 조회한다.\n3. Valid Bit를 확인하여 해당 Page가 현재 Main Memory에 존재하는지 아니면 Secondary Storage에 존재하는지를 확인한다.\n4. 이제 실제 Physical Page Number를 얻어와서, 기존의 Page Offset을 합치면, 이것이 Physical Address가 된다.\n5. 이를 통해서, 조회를 수행하는데 만약, Secondary Storage에 있었다면, LRU를 이용해서 Page Swap을 수행하여 Page를 Main Memory로 올린다. \n6. 만약, TLB miss가 발생했었다면, 해당 Page 정보를 업데이트한다.\n\n자주 헷갈릴 수 있는 TLB miss가 Page Fault가 아니라는 것을 꼭 명심하자.\n\n![Virtual Memory](/images/virtual-memory.png)","slug":"architecture-memory","title":"5. Memory Hierarchy","category":"Computer Architecture","tags":["Computer Organization And Design","Memory","Memory Hierarchy","Cache","Directed Mapping","Virtual Memory","Page"],"date":"2022년 4월 29일 19:25","thumbnailSrc":"https://euidong.github.io/images/default.jpg"},{"content":"\n## **Reference**\n\n![\u003cimg src=\"/images/default.jpg\" width=\"190\" /\u003e](/images/default.jpg)\n\nDavid A. Patterson, John L. Hennessy, Computer Organization and Design\n\n본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 \"-다\"로 표현합니다.\n\n---\n\n우리가 원하는 것은 강한 performance를 발휘하면서도, 가용성(availability, 끊김 없이 사용할 수 있는 능력의 정도)가 높은 computer를 만드는 것이다. 이를 위해서, 우리는 단순히 하나의 processor를 정교하게 만들기보다는 동등한 기능을 하는 여러 개의 processor를 연결하여 사용하는 것이 더 효율적이라는 것이라는 것을 알아냈다. (이를 software가 잘 활용할 수만 있다면, 성능이 크게 향상될 것이다.)\n\n- 하나의 장치를 동작시키는 방식보다 적은 에너지로 같은 작업을 수행할 수 있다. (동시에 실행시키기 때문에 더 짧은 시간 사용할 수 있다.)\n- n개의 processor에서 하나가 실패하여도 n-1개는 정상 작동하기 때문에 전체 시스템은 문제 없이 동작한다. (Redundant, 추가자원을 통해서 가용성을 향상시킴)\n\n이에 따라 우리는 multi-processor를 사용한다. \n이는 multi-processor가 어떻게 존재하느냐에 따라서 다음과 같은 형태로 나눈다.\n\n1. **Multicore Microprocessor** : 하나의 IC(집적 회로) 칩에 여러 개의 processor(core)가 존재한다.\n2. **Multiple Processor** : IC칩의 갯수를 늘린다.\n3. **Cluster System** : Machine(Computer) 자체의 갯수를 늘린다.\n\n따라서, 개인 PC에서는 Multiple Multicore Microprocessor를 지원하고, 있는 상황이고, Datacenter와 같은 환경에서는 이러한 Machine들이 여러 개 존재하는 Cluster System이라고 생각하면 되겠다.\n\n또한, 이용하는 방식에 따라 크게 두 가지로 나눌 수 있다. \n\n1. Task Level Parallelism(=Process Level Parallelism) : 동시에 독립된 여러 program을 실행시키는 방식\n2. Parallel Processing Program : 동시에 여러 개의 processor를 이용하여 하나의 program을 실행시키는 방식\n\n## Parallel Processing Program의 구현\n\n하나의 작업을 더 빠르게 처리하기 위하여 multiple processor를 사용하는 software를 작성하는 것은 어렵다. 이는 processor의 수가 늘어날 수록 심해진다. multiprocessor program을 이용할 경우에, 수가 늘어날 수록 우리는 다음과 같은 작업에 대한 부담을 가질 수 밖에 없다.\n\n1. **Scheduling** : process 또는 thread를 scheduling하여 어떤 것을 먼저 실행시킬지에 대한 scheduling 역시 큰 부담이다.\n2. **Partitioning** : Memory의 구간을 각 processor에게 어떻게 나누고 서로 독립되게 존재하기 위한 관리를 수행하는 것 역시 큰 부담이 된다.\n3. **Balancing the Load** : 작업을 각 processor에게 균등히 분배하는 것 역시 어렵다.\n4. **Time to Synchronize** : 여러 개가 동시에 하나의 process를 실행시키면, 읽고 쓰기에서 충돌이 발생하는 것에 의한 문제가 발생하고 이를 해결하기 위해서 시간을 사용할 수 밖에 없다.\n5. **Overhead for Communication** : 각 processor간의 의사소통에 너무 큰 비용이 발생하는 경우 오히려 하나의 processor가 실행시키는 것보다 더 많은 시간을 요구할 수도 있다.\n\n이 모든 것을 software에서 제대로 관리할 수 있을 때, 그제서야 우리는 multi processor 시스템을 제대로 활용할 수 있는 것이다.\n\n우리가 processor의 갯수를 늘림으로써 얻을 수 있는 혜택은 각 processor에 전달되는 작업의 수를 균등하게 나누어, 기존에 하나의 processor가 할 수 없던 일을 처리(weak scaling)하거나, 기존의 문제를 더 빠르게 처리(strong scaling)할 수 있다.\n\n## Data Stream, Instruction Stream\n\nprocessor들로 들어오는 data의 양을 의미하는 **Data Stream**과 instruction의 양을 의미하는 **Instruction Stream**에 따라서, 우리는 각 processor들을 다양한 이름으로 부른다.\n\n1. **SISD**(Single Instruction Stream, Single Data Stream) : 대게 single processor일 경우 이와 같은 형태를 채택한다.\n2. **MIMD**(Multiple Instrunction Stream, Multiple Data Stream) : Multiple Processor System에서는 당연히 이와 같은 시스템을 채택한다.\n3. **MISD**(Multiple Instrunction Stream, Single Data Stream) : 잘 사용하지 않는 형태이다. 대게는 Data의 처리가 더 많이 발생하기 때문이다.\n4. **SIMD**(Single Instruction Stream, Multiple Data Stream) : 하나의 Instruction을 이용하여 복합적인 여러 개의 데이터를 한 번에 처리하는 vector 연산 등을 빠르게 처리할 수 있다.   \n   1. vector 연산 하나가 for loop 하나를 의미할 수 있다. 이는 processor part의 각 pipeline 단계에서 fetch와 decode에 의한 비용을 크게 감소시킬 수 있다.\n   2. 하나의 vector 연산은 내부에서 각각이 독립적으로 수행되기 때문에, data hazard를 check하는 비용이 발생하지 않는다. 👉 따라서, vector의 각 요소를 모두 검사하는 것이 아닌 vector 외부 간의 data hazard 유무만 확인하면 된다.\n   3. Main Memory에서 데이터를 불러올 경우에도 각 요소를 불러오는 것이 아닌 한 번에 가져올 수 있기 때문에 매우 빠르다.\n   4. Loop를 표현이 vector 연산으로 대체되기 때문에, Loop Branch가 줄어든다.   \n\n## Hardware Multithreading\n\nprogrammer의 입장에서 MIMD는 hardware multithreading처럼 동작한다고 생각하게 한다. 이는 processor의 사용성을 최대화하기 위해서, 특정 thread가 stall 되었을 때, 다른 thread를 수행하도록 하는 방식이다. 즉, 하나의 processor에서 여러 개의 thread를 실행시킨다는 것이다. 그러기 위해 사실상 여러 processor가 존재하는 multiprocessor 환경에서 서로간 실행 환경을 서로 공유해야 한다. 이를 실현하려면, 각 thread의 독립된 상태를 복사할 수 있어야 한다. 즉, 각 각의 register file과 PC가 존재해야 한다. 이들 간의 Memory 공유 같은 경우는 이전에 보았던 Virtual Memory 정보를 공유하여 수행하게 된다. 그리고 무엇보다 중요한 것은 이 실행하는 thread를 바꾸는 시간적 비용이 작아야 한다. 이를 위해서, process가 아닌 thread를 바꾸는 것이다. process를 바꾸는 것보다는 비용이 훨씬 적기 때문이다. \n\nthread를 변경 시에 어떤 방법을 택할 것인가 역시 중요한데, 아래와 같은 방법론이 존재한다.\n\n\u003e **1. Fine Grained Multithreading**\n\nthread의 명령어를 round robine 방식을 이용하여 매번 바꾸면서 실행시키는 방식이다. 변경한 thread 역시 stall이 된 thread라면, 건너뛰고 다음 thread를 실행시킨다.\n\n- 장점 : stall 기간이 짧던 길던 이로 인한 손실을 감추고, 그 동안 다른 thread를 실행시킬 수 있다.\n- 단점 : 실행 준비가 된 상태(stall이 아닌 상태)에서도 다음 차례가 올 때까지 반드시 기다려야 하기 때문에 하나의 thread에 대한 처리 속도가 dramatic하게 줄어든다.\n\n\u003e **2. Coarse Grained Multithreading**\n\n하나의 thread에 대한 Instruction만 처리하다가 stall이 발생했을 때에만 thread를 변경하도록 하는 방식이다.\n\n- 장점 : 하나의 thread에 대한 처리 속도의 손실이 적고, switching을 빨리 하는 것에 대한 부담이 적다.\n- 단점 : 하나의 thread에 대한 Instruction만 처리하기 때문에, thread를 변경하는 것에 대한 비용이 크다. (long pipeline setup time) 따라서, 짧은 기간의 stall인 경우에는 해당 stall이 끝나길 기다린다.\n\n\u003e **3. Simultaneous Multithreading(SMT)**\n\nThread Level에서 Parallelism과 Instruction Level에서의 Parallelism을 동시에 수행하는 방식이다. Multiple Instruction 시스템에서는 더 많은 functional unit(register, pc, etc)이 있기 때문에 이를 Multi Threading에서도 적절히 사용할 수 있다는 접근법에서 나왔다. 여기서는 register renaming과 dynamic scheduling을 이용하여 multiple thread에서 여러 개의 Instruction을 빈틈없이 배치할 수 있다. 의존성은 dynamic scheduling이 해결하고, register renaming을 통해 필요에 따라 여분의 register를 불러와서 사용하는 것이 가능해졌다. 이를 통해서 위의 두 방식으로 할 수 없었던, multi processor를 최대한으로 사용하는 효과를 볼 수 있다.\n\n![multi-threading](/images/multi-threading.png)\n\n## GPU(Graphic Processing Unit)\n\ngame 산업 및 그래픽 분야의 큰 성장에 힘업어 graphic 처리에 대한 processor의 성능 향상이 필요했다. 즉, 기존 micro processor와 겉아 다용도로 사용되는 것이 아닌 graphic 연산만을 빠르게 처리할 수 있는 processor를 분리할 필요가 생긴 것이다. 이것만을 위해서 만들어진 것이 GPU이다.\n\nGPU는 앞 서 설명한 Multi Threading 기술을 적극 도입했기 때문에 Memory 접근에 따른 Latency가 성능에 큰 영향을 미치지 않는다. 그런 만큼 반대로 높은 Bandwidth를 가진 저장 장치를 필요로 한다.\n\n후에는 이 장치가 수행하는 vector 연산이 여러 용도로 사용됨에 따라 이를 위한 programming language들도 만들어졌다. 대표적인 것이 NVidia가 C를 통해서 만든 CUDA이다.","slug":"architecture-parallel-processors","title":"6. Parallel Processors","category":"Computer Architecture","tags":["Computer Organization And Design","Multi Processors","Multi Threading","MTU"],"date":"2022년 5월 2일 20:22","thumbnailSrc":"https://euidong.github.io/images/default.jpg"}],"Docker":[{"content":"# Mysql\n\nMysql is a basic Database to store countless data. It is RDMS(This think that Relation is very very very important than any other things). You can Read, Create, Update, Delete data with it faster, managable (like transaction) than FileSystem.\nIt is manage by Oracle. And It can get good performance in read.\n\nEspectially 5.7 version is stable version. So industry use this version for development or test.\n\n![why-use-5.7](/images/why-use-5.7.png)\n\nIf you want get more information [click this](https://mysql.com)\n\n# Docker\n\nDocker is a virtualization application.\nIt is usally show more performance than any other virtualization machine program.\nBecase It use container.\nSo, It can make more efficient feature.\nIf you want get database running in Linux then you just build and run container that has database with Linux.\nWhen you anymore need taht database, you just delete that container.\nIt's so simple, clear. Let's enjoy.\n\nIf you want get more information [click this](https://www.docker.com/)\n\n### Install\n\nFollowing That\nhttps://www.docker.com/get-started\n\n# Mysql with Docker\n\n### Just Run script.\n\n```bash\nsudo docker run \\ # run container\n -e MYSQL_ROOT_PASSWORD=qwe123 \\ # setting MYSQL_ROOT_PASSWORD\n -e MYSQL_DATABASE=just \\ # default database name\n -e TZ=Asia/Seoul \\ # setting Timezone\n -p 3309:3306 \\ # setting port (my Pc port:container port)\n mysql:5.7 \\ # image name\n --character-set-server=utf8 \\ # setting utf8\n --collation-server=utf8_unicode_ci # setting utf8\n```\n\n### With compose file\n\ndocker-compose.yml\n\n```yml\nversion: \"3.7\"\nservices:\n  # Mysql Server\n  db:\n    image: mysql:5.7\n    # mysql utf-8 설정\n    command:\n      - --character-set-server=utf8\n      - --collation-server=utf8_unicode_ci\n    # db password 및 db 자동 생성\n    environment:\n      MYSQL_ROOT_PASSWORD: \"qwe123\"\n      MYSQL_DATABASE: \"just\"\n      MYSQL_TCP_PORT: \"3306\"\n      TZ: \"Asia/Seoul\"\n    ports:\n      - \"3309:3306\"\n    # for db data backUp\n    volumes:\n      - ./mysql/data:/var/lib/mysql\n```\n\n```bash\ndocker-compose up --build\n```\n\nmore information =\u003e https://docs.docker.com/get-started/\n\nmore infomation =\u003e https://docs.docker.com/compose/","slug":"docker-mysql","title":"Docker Mysql","category":"Docker","tags":["virtualEnv","mysql"],"date":"2020년 4월 11일 12:00","thumbnailSrc":"https://euidong.github.io/images/hero.png"}],"Web":[{"content":"# Gatsby\n\nLink : https://www.gatsbyjs.com\n\n\u003e Gatsby is a React-based open-source framework for creating websites and apps.\n\u003e It's great whether you're building a portfolio site or blog,\n\u003e or a high-traffic e-commerce store or company homepage.\n\ngatsby introduce themselves that sentense. they focus on that big, high performance, and complicated feature view.\nThat is gatsby's advantage. they can make high performance feature more faster.\n\n### Why?\n\n##### First. Bigger and Faster\n\nIt uses React And GraphQL feature.\nSo, it can make better performance than other static web site platform. ex) jk ...\n\n##### Second. Support many feature\n\n- It can do many thing in framework.\n\nhttps://www.gatsbyjs.com/docs/conceptual/\n\n##### Third. Showcase\n\n- gatsby Showcase\n\nhttps://themejam.gatsbyjs.org/showcase\n\n### This Blog's feature\n\n- novela Theme\n\nhttps://github.com/narative/gatsby-theme-novela\n\n### SetUp\n\n=\u003e github : https://github.com/euidong/euidong.github.io\n\n##### 1. Install\n\n```shell\n$ mkdir blog\n$ yarn add react react-dom gatsby @narative/gatsby-theme-novela\n$ yarn install\n```\n\n##### 2. set script\n\n`blog/package.json`\n\n```json\n{\n  \"licenses\": [\n    {\n      \"type\": \"MIT\",\n      \"url\": \"https://www.opensource.org/licenses/mit-license.php\"\n    }\n  ],\n  \"dependencies\": {\n    \"@narative/gatsby-theme-novela\": \"^0.18.4\",\n    \"gatsby\": \"^2.28.0\",\n    \"gh-pages\": \"^3.1.0\",\n    \"react\": \"^17.0.1\",\n    \"react-dom\": \"^17.0.1\"\n  },\n  \"scripts\": {\n    \"build\": \"gatsby build --prefix-paths\",\n    \"deploy\": \"gatsby build --prefix-paths \u0026\u0026 gh-pages -d public\",\n    \"dev\": \"gatsby develop\"\n  },\n  \"homepage\": \"https://euidong.github.io\"\n}\n```\n\n##### 3. post \u0026 author setting\n\nThis theme require at least one post and one author.\n\n`blog/content/authors/authors.yml`\n\n```yml\n- name: Euidong Jung\n  authorsPage: true\n  bio: |\n    Dev - Lang : Javascript Typescript \u003cbr /\u003e\n    Dev - Front : ReactJS ReactNative \u003cbr /\u003e\n    Dev - Back : NodeJS Apollo Express \u003cbr /\u003e\n    Dev - ENV : CloudNative Docker Kubernates AWS\n  avatar: ./avatars/euidong-avatar.jpeg\n  featured: true\n  social:\n    - url: https://github.com/euidong\n```\n\nand add image to\n`blog/content/authors/avatars/euidong-avatar.jpeg`\n\n`blog/content/posts/2021-01-03-gatsby/index.mdx`\n\n```mdx\n---\ntitle: Gatsby Blog\nauthor: Euidong Jung\ndate: 2021-01-03\nhero: ./images/gatsby.png\nexcerpt: Gatsby Flatform\n---\n\n# hellow world\n\n### good world\n\n##### happy world\n```\n\n##### 4. Icon\n\n`blog/src/@narative/gatsby-theme-novela/components/Logo`\n\n```javascript\nimport React from \"react\";\nimport { Link } from \"gatsby\";\nimport LogoBlack from \"../../../../image/icon/logo-black.png\";\nimport LogoWhite from \"../../../../image/icon/logo-white.png\";\n\n/**\n * Paste in your SVG logo and return it from this component.\n * Make sure you have a height set for your logo.\n * It is recommended to keep the height within 25-35px.\n */\nexport default function Logo({ fill }) {\n  return (\n    \u003cLink\n      to=\"/\"\n      style={{\n        fontSize: \"40px\",\n        fontWeight: 700,\n        fontFamily: \"Merriweather',Georgia,Serif\",\n      }}\n    \u003e\n      \u003cimg\n        src={fill === \"#fff\" ? LogoWhite : LogoBlack}\n        alt=\"logo\"\n        style={{ height: \"60px\" }}\n      /\u003e\n    \u003c/Link\u003e\n  );\n}\n```\n\n##### 5. testing\n\n```shell\n$ yarn dev  # testing\n```\n\n##### 6. deployment\n\nSelect static web site deploy platform.(ex. gh-page / aws s3 / heroku ...)\n\n```shell\n$ yarn deploy # deploying to gh-page\n```\n\nIf you want deploy instantly when push to branch. You can use github action. (It is simple CI/CD)\n\nSee bellow example\n\nblog/.github/workflows/main.yml\n\n```yml\nname: github pages\n\non:\n  push:\n    branches:\n      - dev\n\njobs:\n  deploy:\n    runs-on: ubuntu-18.04\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Setup Node\n        uses: actions/setup-node@v2.1.2\n        with:\n          node-version: \"12.x\"\n\n      - name: Cache dependencies\n        uses: actions/cache@v2\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n\n      - name: Install yarn\n        run: npm install -g yarn\n\n      - name: Install node_modules\n        run: yarn install\n\n      - name: Build\n        run: yarn build\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./public\n```\n\nIt is status Badge.\n![github pages](https://github.com/euidong/euidong.github.io/workflows/github%20pages/badge.svg?branch=dev\u0026event=push)","slug":"gatsby","title":"Gatsby","category":"Web","tags":["Gatsby","MDX","Blog"],"date":"2020년 4월 10일 12:00","thumbnailSrc":"https://euidong.github.io/images/gatsby.png"},{"content":"열심히 만든 Blog를 검색 엔진들에 노출하기 위한 일지를 기록한다.\n\n먼저 내가 원하는 것은 구글, 네이버, 다음에 나의 블로그의 태그, 카테고리, 타이틀로 검색어가 노출이 되는 것이다.\n이를 위해서 무엇을 해야 하는지를 정리한다.\n\n## robots.txt\nrobots.txt는 CRA로 React Project를 생성했을 때도, 자동으로 생성해줄만큼 가장 기본적인 요소이다. 이는 가종 검색 엔진의 Posting을 Crawling하는 장치들에게 해당 Posting에 대한 접근 권한을 명시해놓는 곳이다. 따라서, 작성 시에는 간략하게 다음과 같이 표현하는 것이 일반적이다.\n```text\nUser-agent: *\nDisallow:\n``` \n이는 어떠한 검색 엔진 봇의 접근을 허락하며, 모든 하위 uri에 대한 접근을 허락한다는 것이다.\n더 알고 싶다면 공식 문서를 참고하자. https://www.robotstxt.org/robotstxt.html\n\n## sitemap.xml\n웹 페이지 내의 모든 페이지 목록을 나열한 파일이다. 이는 site에 해당하는 모든 url을 등록하고, 어느곳에 어느 컨텐츠가 존재하는지를 알려주는 mapping table이라고 볼 수 있다.\n이를 명시해두어야만 후에 bot들이 작업을 할 때, 조회를 하여 사용할 수 있다. 이를 생성하기 위한 Script는 해당 Project가 포함하고 있다.\n[euidong.github.io's dev branch](https://github.com/euidong/euidong.github.io/blob/dev/generater.js)\n\n---\n# Reference\n\n- Tumbnail : Photo by [NASA](https://unsplash.com/@nasa?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/website?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n  ","slug":"seo","title":"SEO","category":"Web","tags":["SEO","GoogleSearchEngine","검색어 노출","구글 검색어 노출"],"date":"2022년 4월 20일 00:00","thumbnailSrc":"https://euidong.github.io/images/web.jpg"},{"content":"\n해당 포스팅은 블로그를 직접 만드는 과정에서 겪은 시행착오를 정리한 내용이다.\n\n나의 블로그 포스팅을 향한 일대기는 2019년도에서 부터 시작된다.\n\n## JSP / Servlet\n\n2019년도에 군대를 막 전역하고, 학점을 잘 챙기면서 여러가지 행사에 참여했다. 그 과정에서 기술 블로그를 제작하겠다는 꿈을 꾸고 작업에 착수한다.\n그 당시에는 JSP와 Servlet을 이용한 방법을 통해서 Posting하는 것을 시도했다.\n\ngithub : [euidong/blog](https://github.com/euidong/blog)\n\n해당 방식은 markdown file을 그대로 가져와서 rendering하여 만들었다. 하지만, jar file을 실행해야 한다. 따라서, JAVA Virtual Machine이 필요하기에 결론적으로 이를 호스팅할 machine이 필요하다. 따라서, AWS free tier를 이용해서 배포했지만, 다소 배포 관리가 귀찮고, 당시에는 frontend \u0026 backend 등 아직 개념이 제대로 스지 않았기 대문에 중간에 포스팅을 조기 종료했다.\n\n결국 JSP + Servlet을 이용한 시도는 종료된다.\n\n## Gatsby\n\n후에 2021년도 1월에 다시 새롭게 블로그를 쓰겠다는 포부를 갖고, 블로그 작성 방법을 찾는다. 당시에는 React를 이용해서 다수의 Application을 제작해본 경험이 있었기 때문에 이를 이용한 Blog를 만들려고 했다. 자세히 기억은 안나는데 Gatsby Showcase에 있는 source code를 이용해서 Blog를 제작했다. 하지만, Gatsby에 대해 아는게 없고, 시간을 쓸 여유가 없어서 결국에는 중도에 멈춘다. 추가적으로 Github action으로 CI/CD 구현을 수행하는 작업까지도 진행하였다. 하지만 결국 제대로 진행된 것 없이 종료되었다.\n\ngithub : [euidong/euidong.github.io/dev@deprecated](https://github.com/euidong/euidong.github.io/tree/dev%40deprecated)\n\n## Tistory\n\n2021년도 3월에 결국 직접 제작을 하는 것을 포기하고, Tistory를 이용해서 블로그에 포스팅을 시작한다. 해당 시기부터 시작해서 몇 개의 포스팅을 작성하였다. 대략 35개 정도의 포스팅을 작성했고, 최근에 이르러서 작성의 한계를 느끼며 갈아타야겠다고 생각했다.\n\n다음은 직접 커스텀을 해야겠다고 생각했던 이유이다.\n1. 호환성이 떨어진다. =\u003e Markdown으로 변환도 가능하지만, Github와 완벽한 호환이 안된다.\n2. 가끔 모바일에서 문자가 깨진다. =\u003e 아마 MAC으로 작성하는 경우 문자가 깨지는 것 같다. 근데, 이를 매번 모바일로 켜서 확인하기에는 너무 번거롭다.\n3. 커스텀을 할 때 다른 Library를 맘대로 가져와서 쓸 수 있지만, pure js, jquery 기반으로만 가능하고, 유지보수가 쉽지 않다.\n4. 가끔 작성 결과가 너무 예측 불가능하다. \n5. tag 관리가 불편하다.\n6. 기본 UI가 안이쁘다.\n\n몇 가지 이유가 더 있었던 거 같은데, 아마 이정도가 문제였던 거 같다. 암튼 내가 관리하지 못하는 것으로 인한 스트레스가 있었기 때문에 이를 해결하기 위해서 완전 커스텀을 다시 결정하였다.\n\ntistory: [justlog](https://justlog.tistory.com)\n\n## 완전 커스텀\n\n### 생 React\n\n처음에는 생 React를 통해서 Blog를 만들어야겠다고 생각했다. 가장 일반적으로 할 수 있는 작업이고, 다른 static page generating 기능을 수행하는 react framework를 다시 공부하는 workload를 지고 싶지 않았고, 굳이 필요하지 않은 의존성을 만들고 싶지 않아서 결국 생 React로 바로 작업을 시작한다. \n\n당시에는 Tistory에서 한계를 느꼈던 부분을 고치면서, Tistory에서 갖고 싶었던 장점을 가져가고자 했다.\n1. 호환성이 떨어지던 점은 Markdown을 이용해서 작성하고, Github viewer style(GFM, Github Flavor Markdown)을 사용하기로 한다. 따라서, 해당 블로그의 모든 글을 Github에 올려도 이미지 경로 빼고는 매우 잘 작동할 것이다. (이는 후에 이미지 호스팅 CDN을 따로 설정하면 해결됨.)\n2. Tistory에서 장점이라고 생각했던, Category로 작성글을 묶고, Tag들로 다시 한 번 더 분류한다.\n3. Posting을 보기 쉽게 정리되어있어야 한다.\n4. Dark Mode를 지원해야 한다.\n5. 조회수 관리를 위해서 Google Analytics 설정을 해야한다.\n6. 구글 / 네이버 검색에 노출되어야 한다.\n7. 광고를 게시할 수 있어야 한다.\n8. Github에 Push하는 것만으로 Posting이 게시될 수 있어야 한다. (Github Action)\n9. Category와 Tag들은 Markdown안에 작성하지만, 이를 조회할 수 있어야 한다. 따라서, code를 build할 때 json으로 generating 할 수 있는 로직을 설계한다.\n10. UI는 최대한 Simple 하고 깔끔하게 만드는 것을 목표로 하였다.\n\n따라서, 모든 Button 부터 모든 UI를 직접 제작(여타 디자인 사용 x - material, ant 등)하고, Routing 설정하고, 작업을 모두 마무리한다.\n\n여기까지는 모든 작업이 순조롭게 진행되고, 마무리가 되었다. 하지만, SEO(검색 엔진 최적화) 작업을 진행하면서, 결국 static page가 필요함을 깨닫는다. 왜냐하면, 기존의 React Router를 사용하게 되면, https://euidong.github.io/posts/dfs1 를 찾을 수가 없다. 왜냐하면, github에서는 page를 직접 접근할 때에는 배포 branch에서 해당 파일을 찾게 되는데 해당 파일이 없으면 결국 404 Not Found를 노출하게 된다. 이를 해결하기 위해서, dummy redirect로 root로 돌려보내줄 수도 있지만, 결코 좋은 방법은 아니다. 검색엔진 최적화에도 좋지 못하다. 따라서, static file을 각 각의 url마다 생성해주는 Static Page Generating이 필요하다고 느낀다. 따라서, Gatsby와 NextJS 중에서 선택을 하기로 한다.\n\n이제 추가된 요구사항은 다음과 같다.\n\n1. 기존 코드를 그대로 활용할 수 있어야 한다. \n2. Static Page Generating을 지원해야 한다.\n\ngithub : [euidong/euidong.github.io/dev@pure-react](https://github.com/euidong/euidong.github.io/tree/dev%40pure-react)\n\n### Gatsby\n\n다시 돌아와 Gatsby를 시도하기로 한다. 애초에 GraphQL과 React 모두 경험이 있기 때문에 쉽게 할 수 있을 거라고 생각했다. 하지만, 생각보다 GraphQL Query의 제한점이 많아서 결국 Gatsby는 포기하기로 한다. 물론 Gatsby의 확장 도구들은 유용했지만 위에서 제시한 9번을 구현하기에 한계를 느꼈다. (내 딴에는 GraphQL로 만들고 싶었는데 사실 포기하고 JSON으로 만들었으면 가능했을 듯하다.) \n\n### NextJS\n\n그래서 다음으로 시도한 것이 NextJS이다. NextJS는 생성 시에 내부 API를 정의하여 이를 기반으로 미리 compile을 완료한 html 파일들을 생성해두고, 제공하면서도, 그 내부에서는 SPA 처럼 동작할 수 있도록 돕는 방식이다. React를 이용한 Framework인 만큼 기존의 code를 그대로 사용할 수 있어서 쉽게 사용이 가능했다. 하지만, Gatsby와 마찬가지로 어느정도의 한계는 존재했기 때문에 결국은 react만 생성하던 방식처럼 JSON file을 generating하여 category와 tag들을 수집하였다.\n\n그 결과 지금과 같은 형태의 블로그를 완성하였다. 현재 포스팅을 계속해서 진행할 예정이며, 광고 및 여타 설정들도 추가로 진행할 예정이다.\n\n![blog-view](/images/blog.png)\n\ngithub : [euidong/euidong.github.io/dev](https://github.com/euidong/euidong.github.io/tree/dev)\n\n최종으로 만들어진 Blog는 다음과 같은 요구사항을 만족한다.\n\n- [x] Markdown을 통해서 작성이 가능하고, 이는 DB 즉, BackEnd를 필요로 하지 않는다.\n- [x] Category로 작성글을 묶고, Tag들로 다시 한 번 더 분류하는 것이 가능하다.\n- [x] Dark Mode를 지원한다.\n- [x] 조회수 관리를 위해서 Google Analytics를 사용한다.\n- [x] 구글 / 네이버 검색에 노출되어있다.\n- [x] 광고를 게시하였다.\n- [x] Github에 Push하는 것만으로 Posting이 게시된다. (Github Action)\n- [x] Build 시에 SEO에 필요한 sitemap을 자동 생성한다.\n- [x] Theme는 Github의 color palette에 기반하여 설정하여, 친숙하다.\n- [x] 모바일을 지원한다.\n- [x] 이미지 크기를 재설정할 수 있는 command를 포함한다. \n","slug":"making-blog","title":"블로그 제작기","category":"Web","tags":["frontend","react","gatsby","nextjs","github"],"date":"2022년 5월 5일 21:54","thumbnailSrc":"https://euidong.github.io/images/blog.png"}],"Network":[{"content":"\n### References\n\n- Thumbnail : Photo by [Tyler Farmer](https://unsplash.com/@tylerfarmer?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/forwarding?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n- \u003chttps://www.itworld.co.kr/tags/6580/MPLS/108621\u003e\n- \u003chttps://blog.naver.com/thorong/70147777745\u003e\n\n---\n\n기존의 Routing에서는 매 hop(router)당 Routing Table을 참조하여 packet을 전송했다. 하지만, 이 과정은 생각보다 많은 시간이 필요하다. 이를 이용해서 화상 통화 등을 한다면, 서비스 품질이 매우 떨어질 위험이 있다. 따라서, MPLS는 Routing를 더 빠르게 하고, 품질 항상을 위해서 만들어졌다. 이는 Multi-Protocol Label Switching(MPLS)이라는 말처럼, 기존의 IP를 이용한 Routing이 아닌 Label(또는 tag)이라는 별도의 data를 이용하여, 3계층을 거치지 않고, Routing을 고속화하는 역할을 할 수 있다.\n\n또한, **MPLS**에서는 사전에 고효율 경로를 설정하고, 이를 통해서 통신하도록 하여 성능 문제를 해결한다. 예를 들어, Packet이 들어오면, 진입점에 있는 Router(Ingress Router)가 해당 Packet에 Label을 표기하고 내부 Network로 전송하게 된다. 이제 내부 Router에서는 Packet을 모두 확인하지 않고, 해당 Label만을 이용하여 Forwarding을 수행한다. 그렇기에 더 빠른 Routing이 가능해지는 것이다.\n\n하지만, 그 외에도 추가로 더 많은 장점을 보유하고 있다.\n\n1. 여러 Protocol과 호환이 가능하도록 overlay로 개발되었다. (2.5 Layer라고도 불리는 이유이다.)\n2. TE(Traffic Engineering)를 위한 여러 설정을 제공한다. 따라서, bandwidth, QoS(서비스 품질)에 따라서 Traffic을 제어하는 것이 가능하다.\n\n## 용어\n\n- MPLS Network : **MPLS**를 통해서 구축한 Network를 의미한다. 해당 Network로 진입하는 순간 Packet에는 Label과 부가적인 header가 추가된다.\n- Label : Label은 각 Router에게 하나씩 주어지는 Router의 고유 식별값이다.\n- LER(Label Edge Router) : Network 제공자 입장에서 Edge Router로 두 가지 종류로 나뉜다.  \n  Ingress와 Egress는 항상 고정인 것이 아니라 packet에 입장에서 계속해서 변경된다.\n  - Ingress Router: packet이 Network로 진입하는 Router로 실제 Network를 전체 조회하고, Label을 추가하는 역할을 한다.\n  - Egress Router : packet이 Network를 탈출하는 Router로 Packet의 남아있는 Label을 삭제한다.\n- LSR(Label Switched Router) : MPLS Network 내부에 존재하는 LER이 아닌 Router들로 이들은 Packet의 Label을 Switching하고, Forwarding하는 역할을 수행한다.\n\n## 동작 원리\n\n`LSP(Label Switched Path)라는 최단 경로를 찾고, 이를 통해서 Packet을 전달시킨다.`가 Protocol의 핵심적인 전략이다. 형성된 LSP에 따라서 labe들을 설정해두면, 이제 내부 Router에서는 자신에게 해당하는 Label을 교환하여 다시 Forwarding을 수행하면 되는 것이다. 따라서, 3계층을 거치지 않고 Routing이 가능하다. 위에서 나온 용어로 정리하자면, Ingress LER에서는 packet의 목적지와 요청지 정보 등을 활용하여 LSP을 구성하고, 이에 알맞는 Label을 packet에 추가한다. 이제 이 packet을 받은 LSR에서는 Label을 하나 빼고, 다음 LSR을 찾아가기를 반복하며, egress LER에 도달한다. egress에서는 Label이 남아있다면, 모두 제거하고, 원래 사용 중이던 Protocol에 맞게 다시 Routing을 수행한다.\n\n### LSP 구성\n\n총 3가지 방법을 통해서 생성이 가능하다. 이는 후에 나올 Configuration에 따라서 어느정도 바뀌게 된다.\n\n1. Best Effort LSP : Label 할당이 알고리즘에 의해서 자동적으로 할당되며, 항상 연결이 지속될 수 있도록 하는 것을 최대 목표로 하기 때문에 여타 방식들에 비해 성능이 떨어질 수도 있지만, 장애 대응에 적절하다고 할 수 있다.\n2. Static LSP : Label을 직접 수작업을 통해서 할당해주며, 경로를 customizing할 수 있지만, 이로 인해서 예상치 못한 문제가 발생할 수도 있다.\n3. Signaled LSP : 일정 이상의 자원(Bandwidth, 등)을 제한하여 경로를 최적화할 수 있다.\n\n### Configuration\n\nMPLS network를 구성하기 위해서는 결국 각 Router에 Label을 나누어주는 것과 LSP를 구성하는 것이 중요하다. 아래에는 대표적인 MPLS의 Topology를 살펴본다.\n\n- LDP : 위에서 설명한 Best Effort LSP를 구성하는 Protocol로 Label을 분배하고, 각 Router에서는 Label의 Push/POP/Swap을 수행한다.\n- RSVP-TE : 특정 제약 조건을 먼저 제시를 하고, 이를 기반으로 이와 일치하는 경로를 찾아서 packet을 Routing하는 방식이다.\n\n## Versus\n\n| 구분                   | ATM       | IP        | MPLS      |\n| :--------------------- | :-------- | :-------- | :-------- |\n| IP Traffic Engineering | 우수      | 보통      | 매우 우수 |\n| 고속 포워딩            | 매우 우수 | 보통      | 우수/보통 |\n| QoS                    | 매우 우수 | 보통      | 우수      |\n| VPN 비용               | 고가      | 저가      | 중가      |\n| 확장성                 | 우수      | 매우 우수 | 매우 우수 |\n| 구축 / 유지 비용       | 매우 고가 | 저가      | 고가      |\n\n","slug":"mpls","title":"MPLS","category":"Network","tags":["Routing"],"date":"2022년 5월 22일 15:25","thumbnailSrc":"https://euidong.github.io/images/routing.jpg"},{"content":"\n### Reference\n\n- Thumbnail : Photo by [Jordan Harrison](https://unsplash.com/@jordanharrison?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/network-cable?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n- mininet : \u003chttps://github.com/mininet/mininet/wiki/Introduction-to-Mininet\u003e\n\nmininet은 현실적인 가상 네트워크 환경을 구축해주는 `Network Emulator`, 더 정확히는 `NETOWKR Emulation Orchestration System`이다.  \n이를 통해서, 가상의 End Device(Host), 각종 Switch, Router, 그리고 이를 연결하는 Link를 단 하나의 Linux Kernel로 만들 수 있다. 여기서 그치지 않고, 각 Host에 `ssh` 접근을 수행하여 기본 Linux Kernel 동작을 수행하거나 ethernet을 이용해서 각 device로 packet을 전송하는 것과 같은 효과를 볼 수 있다. (실제 speed와 delay에 기반한 속도를 볼 수 있다.) 또한, SDN과 같은 환경에 필요한 Controller 역시 구성하는 것이 가능하다. 그렇기에 실제로 SDN Network를 Test하고 연구하는 목적으로 많이 사용되고 있다.\n\n## 장점\n\n1. Fast - 가상 네트워크의 구성이 굉장히 빠른 시간 내에 구성된다. 실제로 동작해보면, 이를 알 수 있다.\n2. Customize Topology - 간단한 네트워크에서부터 시작해서, Backborn, Datacenter, Internet 등 모든 네트워크 구성이 가능하다.\n3. Can run every programs in Linux - 간단한 Web Server에서부터 시작하여 Mornitoring Service인 Wireshark 등의 활용이 가능하다.\n4. Progammable - 각 Switch의 동작도 programming이 가능하기에 OpenFlow Protocol을 기반으로 packet forwarding 역시 customizing이 가능하다.\n5. LightWeight - Labtop에서 돌아갈 정도로 가볍다.\n6. Can share results - 각 Topology와 같은 구성은 python code로 구성되고, test code 등도 쉽게 공유가 가능하다.\n7. Easy - Mininet 실행과 구축 그리고 운영이 매우 간단한 CLI, Python code로 작성이 가능하기 때문에 매우 쉽다.\n8. OpenSource - 쉽게 커뮤니케이션이 가능하고, 누구나 해당 프로젝트에 참여가 가능하다.\n\n## 주의사항\n\n1. 만약 10Gbps 이상의 traffic을 처리하기를 원하는 경우, 부하를 적절히 분배하기 위한 구조를 실행자 측에서 구성할 필요가 있다.\n2. Mininet은 하나의 Linux Kernel을 통해 모든 Virtual Host를 제어한다. (다른 Platform, Window 등은 지원하지 않는다. VM 필요)\n3. Mininet에서는 OpenFlow Controller를 사용할 수는 있지만, 이를 직접 제어할 방법은 제공하지 않는다.\n4. 기본적으로는 Host LAN과는 분리되어 있다. (물론 `NAT`를 통해서 연결도 가능하다.)\n5. 기본적으로 Mininet에 의해 생성된 Host는 PID와 file system을 공유한다. (물론 바꿀 수는 있지만, 유의하자.)\n6. Simulator가 아니기 때문에, Virtual Time에 대한 매우 정확한 지표를 제시할 수는 없다.\n\n\u003e Mininet 활용\n\nMininet을 제대로 활용하기 위해서는 다음과 같은 사항을 숙지해야 한다.\n\n0. 설치\n1. Topology 생성\n2. Performance 측정\n3. OpenFlow를 이용해서 Custom Routing\n\n이제부터 위의 내용을 하나하나 수행해 볼 것이다.\n\n## 0. 설치\n\n[Mininet Repo](https://github.com/mininet/mininet)\n\n위의 링크에서 INSTALL이라는 파일에 따라서 설치를 진행해보자. 역시 제일 쉬운 것은 제작자가 직접 만들어놓은 Virtual Machine 이미지를 활용하여 실행하는 것이다.\n\n## 1. Topology 생성\n\n아래의 형태가 가장 기본적인 형태의 Topology이다. 이를 실행시키면, 기본적으로 두 개의 Host가 하나의 Switch에 각 각 연결된 형태로 구성되어진다.\n\n![one-switch-topology](/images/one-switch-topo.jpeg)\n\n```python\nfrom mininet.topo import Topo\n\nclass SingleSwitchTopo(Topo):\n  \"Single switch connected to n Hosts.\"\n  # build function 내부에서 topology를 구성하는 요소에 대해 정의\n  # self.__init__의 parameter가 해당 함수로 그대로 전달된다.\n  def build(self, n=2):\n    # s1이라는 이름으로 Switch 생성\n    switch = self.addSwitch('s1')\n    for h in range(n):\n      # h1, h2, ... 이라는 이름으로 Host 생성\n      host = self.addHost('h%s' % (h+1))\n      # h1, h2, ... 을 s1과 연결\n      self.addLink(host, switch)\n\n# 후에 topology를 생성할 때, 아래 이름을 통해서 지정이 가능\ntopos = { 'singleSwitch': (lambda: SingleSwitchTopo())}\n```\n\n이를 파일로 생성하고, 다음과 같이 실행시키면 된다.\n\n```bash\n$ sudo mn --custom [file명.py] --topo [topology 이름],[build function parameters]\n\n# example\n$ sudo mn --custom mytopo.py --topo singleSwitch,3\n```\n\n하지만, 위와 같이 mininet command를 통해서 실행시키는 것은 자동화에는 적절하지 않을 수 있다.  \n만약, 부가적인 설정을 해주고 싶거나 실행 후에 test 및 실험하고자 하는 상황을 만들고자 한다면 추가적인 programming이 필요하다.  \n아래 코드를 추가적으로 살펴보자.\n\n```python\nfrom mininet.topo import Topo\nfrom mininet.net import Mininet\nfrom mininet.util import dumpNodeConnections\nfrom mininet.log import setLogLevel\n\nclass SingleSwitchTopo(Topo):\n  \"Single switch connected to n Hosts.\"\n  def build(self, n=2):\n    switch = self.addSwitch('s1')\n    for h in range(n):\n      host = self.addHost('h%s' % (h+1))\n      self.addLink(host, switch)\n\ndef simpleTest():\n    \"Create and test a simple network\"\n    topo = SingleSwitchTopo(n=4)\n    # Mininet 생성\n    # 이때, Topology, Host, Switch, Controller, Link 등에 대한 Customizing이 가능하다.\n    net = Mininet(topo)\n    # mininet 실행\n    net.start()\n    print( \"Host의 연결 상태를 출력\" )\n    dumpNodeConnections(net.hosts)\n    print( \"Netowork 연결 상태를 체크\" )\n    # ping to every node with each node.\n    net.pingAll()\n    # mininet 정지\n    net.stop()\n\nif __name__ == '__main__':\n    # Tell mininet to print useful information\n    setLogLevel('info')\n    simpleTest()\n```\n\n```bash\npython [file명.py]\n```\n\n이를 통해서, Mininet를 우리가 정의한 Topology에 따라서 실행하고 테스트를 수행하는 code이다.  \n이러한 기능 뿐만 아니라 host의 성능을 제한하거나 Link 용량을 제어할 수도 있고, Switch를 제어할 수도 있고, 특정 Host에서 Command를 실행시키도록 할 수도 있다.  \n더 자세한 사항은 아래 링크를 통해서 확인해보자.\n[More Example](https://github.com/mininet/mininet/tree/master/examples)\n\n위에서 살펴본 사항은 가장 기본적인 Mininet에서 제공하는 Template에 기반하여 programming을 수행하는 것이다. 만약, 직접적으로 제어를 원하는 경우 더 하위 단계의 API를 활용하여 구현하는 것도 가능하다. [API Doc](http://api.mininet.org)\n\n### 추가 참고사항\n\ncode convention이 후에 버전에서는 좀 변경되었다.\n\n- camelCase 표기가 snake_case형태로 변경되었다. example. `addHost -\u003e add_host`.\n- `build`가 `__init__`으로 바뀌어, 나의 기준에서는 이해하기 쉬워졌다.\n\n변경되었지만, 여전히 기존 버전 표기도 지원하기 때문에 사용하는데는 문제가 없다.\n\n\n## 2. Performance 측정\n\n해당 사항은 Mininet에서 권장하는 방법이다.\n\n1. Bandwidth - `bwm-ng`, `ethstats`\n2. Latency - `ping`\n3. Queues - `tc`\n4. TCP Congestion Window statistics - `tcp_probe`\n5. CPU usage - for all: `top`, per host: `cpuacct`\n\n## 3. OpenFlow를 이용해서 Custom Routing\n\nMininet 자체만으로도 값지지만 SDN을 구축하기 위한 OpenFlow Protocol을 이용한 Routing을 Emulating할 때에 굉장한 효과를 얻을 수 있다.  \nMininet을 실행시킬 때에 아무 설정을 하지 않으면 기본 Ethernet switch를 사용하는 기본 Controller를 사용한다. 하지만, Open vSwitch(ovs)와 같은 OpenFlow Protocol을 지원하는 Controller를 활용할 수도 있다.  \n기본적인 Switch(대략 4096개)는 이미 지원을 하고 있다. 이를 불러와서 사용하거나 원하는 경우에는 python을 통해서 직접 구현하여도 무방하다. 심지어는 원격에 있는 controller를 사용할 수도 있다. \n\n이렇게 Controller를 정의하고, 외부에서 해당 Controller의 동작을 정의해주면, Mininet에 의해서 정의된 Network가 의도대로 동작하는지를 계속해서 확인할 수 있다.\n\n## NutShell\n\nMininet에서 어떻게 이렇게 빠르게 가상 Network System을 가볍게 구현할 수 있는가에 대한 열쇠는 `container`이다. 이를 통해서, 서로 완전 분리된 Host를 기본적으로 구성하는 Container이기에 이를 쉽게 구현할 수 있을 뿐만 아니라 Virtual Machine을 직접적으로 구현하지 않기 때문에 가볍고 빠를 수 있는 것이다. 또한, Virtual Link 같은 경우에는 Linux Traffic Control(`tc`)를 활용하여, Virtual Ethernet이 각 Virtual Switch와 Interface들을 통해서 전달되는 것을 제어할 수 있다. 마지막으로, Switch는 기본적인 Linux Bridge를 활요하거나 Open vSwitch를 활용하여 구성하여 가상화가 가능하다.\n\n\n## 결론\n\nMininet은 가상 Network를 Emulating 할 수 있는 Tool이기에 실제로 SDN을 테스트하기 이전에 각종 기능을 체크하기에 용이하다.  \n또한, Network에서 핵심적인 Forwarding에 관한 기술은 다른 기술에게 맡겨서 더 안정적인 구조를 가지고 있다.  \n이에 따라 Open vSwitch를 이용해서 자유롭게 시스템을 제어할 수 있을 뿐만 아니라 ONOS와 같은 도구를 통해서 Network를 구성하는 과정을 테스트하기에 굉장히 유용하다.","slug":"mininet","title":"Mininet","category":"Network","tags":["Emulator","Tool"],"date":"2022년 5월 24일 12:58","thumbnailSrc":"https://euidong.github.io/images/switch-with-cable.jpg"},{"content":"\n## Reference\n\n- [Openflow specification](https://opennetworking.org/wp-content/uploads/2013/04/openflow-spec-v1.3.1.pdf), ONF, 2012\n- Thumbnail: Photo by [Jordan Harrison](https://unsplash.com/@jordanharrison?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/network?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n\n이전 Posting인 SDN의 본격적인 시작이 OpenFlow라고 보아도 무방하다. OpenFlow는 2007년 Stanford 대학에서 개발이 시작되었고, 지금도 de facto standard(사실상의 표준)으로 받아들여지고 있는 Protocol이다. 해당 Protocol의 핵심은 기존 Switch/Router를 data plane(데이터 평면)과 control plane(제어 평면)으로 나누고, 제어 평면을 OpenFlow Protocol에 따르는 Controler로 대체하면서, OpenFlow Protocol을 따르는 Switch는 data plane만을 포함하여, 둘 간의 통신을 통해서 제어 평면을 구성하자는 것이다. 여기서 데이터 평면은 실제로 interface로 packet이 들어오고, 내보내는 역할을 하는 계층이라고 보면 되고, 제어 평면은 packet에 어떤 동작을 수행시킬지 그리고 어느 interface로 내보낼지를 결정하는 역할을 하는 계층이라고 보면 된다. 이러한 구성을 통해서, 결국 SDN을 구축할 수 있는 토대를 제공하게 된 것이다.\n\n따라서, OpenFlow Switch는 다음과 같은 형태로 구성되어진다.\n\n![OpenFlow Switch](/images/openflow-switch.jpeg)\n\n## OpenFlow Protocol\n\n해당 사항은 reference에 기반한 version 1.3.1의 기능을 요약한 내용이다.\n\n기본적으로 OpenFlow Protocol을 지원하는 Switch의 구조부터 알아보아야 한다. Switch는 기본적으로 외부와 연결이 가능한 Port, Routing을 위한 여러 개의 Table, 그리고 Controller와의 의사소통을 위한 Channel을 가진다. 각 요소의 역할을 간략히 하나하나 알아보도록 하자.\n\n\u003e **1. Port**\n\nOpenFlow에서 packet이 Switch로 왔다갔다하는 통로라고 볼 수 있다. 대게 Switch를 가르키거나 packet의 진입 위치를 식별할 때 사용된다. 이는 실제로 존재하는 것이 아닌 추상화된 개념으로, 총 3가지의 Port를 통해서 Switch를 가르킬 수 있다. 각 Switch는 여러 개의 Port를 가지고 이를 통해서 다른 Switch들과도 연결되어진다.\n\n- Physical Port : 실제 Switch의 interface와 일대일로 대응되는 가상 Port이다. 즉, 해당 interface로 packet이 들어왔다면, OpenFlow에서는 이와 대응되는 port로 packet이 들어왔다고 판단한다.\n- Logical Port : OpenFlow를 쓰지 않고, Switch 자체적으로 정의한 Tunnel과 Loopback과 같은 가상 Port이다.\n- Reserved Port : OpenFlow Protocol에 의해서 정의된 Port이다. 이를 통해서, Controller, All, Table의 맨 처음, IN_PORT 등을 쉽게 가르킬 수 있다.\n\n\u003e **2. Table**\n\nSwitch는 여러 개의 Table을 가지고 있다. Table을 통해서 Switch는 Routing을 수행하는 것은 기본적인 Switch의 동작과 동일하다. Switch의 특정 Port로 packet이 들어왔을 때, packet의 목적지와 진입한 Port, 그 외에 metadata에 기반하여 matching을 수행하여 일치하는 대상을 찾아서, 해당 Table에 기술된 동작을 수행하는 것이다. 대게 무슨 동작을 수행할 것인가에 따라서 종류가 나뉘어지며, v1.3.1에는 총 3가지의 종류가 존재한다.\n\n1. Flow Table : 대게 어떻게 Packet을 어느 Port로 Routing할 것인가를 다룬다. 뿐만 아니라 Packet의 Header를 변경하거나 MPLS Label과 같은 추가 정보를 더하는 등의 동작을 수행할 수 있다. (각 Switch는 하나 이상의 Flow Table을 소유한다.)\n2. Group Table : 패턴과 일치하는 packet에 대해서 여러 동작을 수행하게 하거나 상황에 따라 다르게 적용하도록 하기 위해서 사용할 수 있다. (각 Switch는 1개 이하의 Group Table을 소유한다.)\n3. Meter Table : packet의 빈도(rate) 조절과 측정을 수행할 수 있다. (Meter Table은 Controller에 의해서 관리된다.)\n\n\u003e **3. OpenFlow Channel**\n\nOpenFlow Switch 내부에서 Controller를 연결하는 Interface로 Switch의 상태를 Controller에게 알리거나 Controller로 부터 변경사항을 전달 받기 위한 통신 채널이다.\n\n---\n\n이렇게 이루어진 OpenFlow Switch들은 서로 연결되어 있으며, 하나 또는 여러 Controller와 각 각 연결되어 있다. Controller는 각 OpenFlow Switch로 부터 상태 정보와 인접 Switch 정보 등을 전달받아서 내부적으로 Flow Table을 구축한다. 그리고, Controller에서 중앙 통제를 통해서 전체 네트워크를 관리할 수 있는 것이다. 이를 수행할 때에는 Controller에서 각 Switch의 Table을 지정함으로써 구현이 가능하다. 그렇다면, Switch에 Table을 설치하였을 때, 어떻게 Packet을 처리하는지에 대해서 알아보자.\n\n### Pipeline\n\nSwitch 내부에는 여러 개의 Table이 존재하는데, Packet이 Switch의 특정 Port로 들어오면, 먼저 Flow Table을 거치게 된다. Switch 내부의 여러 Flow Table 중에서 index($\\ge 0$)가 작은 값부터 시작하여 Flow Table에서 일치하는 pattern의 Flow Entry를 찾게 된다(Flow Table의 하나의 열). 해당 Entry에 적힌 `Instruction`에 따라 `Action`을 바로 수행하거나 `Action Set`에 추가한 후에 다음 Table 또는 Port를 통해서 다음 Switch로 이동하게 된다. 이때 Port 밖으로 나가기 이전에 Action Set에 모아둔 Action을 한 번에 수행한다.  \n만약, Flow Table의 어떤 pattern과도 일치하지 않는다면, 이를 `Table Miss`라고 하고, 미리 지정해둔 miss flow entry에 따라 Action을 수행한다. 아무 설정도 하지 않았다면 default로 해당 packet을 drop한다.\n\n그렇다면, 각 Table을 구성하는 요소(entry)들이 어떻게 구성되는지를 확인해보자.\n\n\u003e **1. Flow Entry**\n\n- Match Field : 일치하는 Packet을 찾기 위하여 Ingress Port / Egress Port / Packet Header / 다른 Table에서 생성된  Metadata 등을 사용한다.\n- Priority : 일치하는 대상이 많을 경우, 높을 수록 조회 시에 우선시 되어진다.\n- Counters : match가 수행된 횟수를 마킹한다.\n- Instructions : packet에 대해서 특정 Action을 수행시키거나 Action Set을 변경한다.\n- Timeout : 최대 처리 시간 또는 남은 시간 등을 표시한다.\n- Cookie : Controller에 의해 설정된 데이터로 대게 해쉬 / 암호화 되어진다. 이는 Controller에서 Flow 관측 및 조절 시에 사용한다.\n\n\n\u003e **2. Group Entry**\n\n- Group Identifier : Group 식별자\n- Action Buckets : 여러 개의 action과 이에 해당하는 parameter를 담은 bucket들을 정렬 후 보관\n- Group Type : Group의 동장 방식을 선택\n  - all :  모든 bucket을 실행\n  - select : bucket을 번갈아가면서 실행하여 Load Balancing을 실행\n  - indirect : bucket 하나만 실행하며, bucket을 여러 개 두는 것을 허락하지 않는다.\n  - fast failover : 가장 먼저 켜져있다고 판단되는 port를 가진 bucket 하나만 실행\n- Counters : Group에 의해 처리된 packet의 수\n\n\u003e **3. Meter Entry**\n\n- Meter Identifier : Meter 식별자\n- Meter Bands : packet rate와 이에 따른 packet 처리 방법을 가진 여러 meter band를 순서없이 저장. band를 선택할 때에는 측정된 rate보다 작으면서 가장 큰 rate를 가진 band를 선택한다. 각 band는 아래와 같이 구성된다.\n  - Band Type : rate를 넘긴 후의 packet 처리 방식을 선택\n    - drop : packet을 버린다.\n    - dscp remark : IP header에 drop 우선순위를 높인다.\n  - Rate : packet rate의 하한선\n  - Couter : 처리된 packet의 수\n  - Type Specific Arguments : 부가 정보\n- Counters : Meter에 의해 처리된 packet의 수\n\n---\n\n마지막으로, Instruction과 Action 그리고 Action Set의 구성을 살펴보자.\n\n\u003e **1. Instruction**\n\nInstruction은 다음과 같은 종류가 있다. 이를 통해서 명령을 적용하거나 Table을 이동하고, ActionSet을 변경하는 것이 가능하다.\n\n1. `meter meter_id` : packet에 특정 meter를 적용\n2. `apply-actions action(s)` : packet에 해당 action(s)를 즉각적으로 수행\n3. `clear-actions` : `Action set`을 바로 비우기\n4. `write-actions action(s)` : Action Set에 해당 action(s)를 추가\n5. `write-metadata metadata/mask` : metadata를 추가\n6. `goto-table next-table-id` : 특정 table로 이동. 단, 반드시 현재 Table index보다 더 큰 index로 이동해야 한다.\n\n\u003e **2. Action Set**\n\npipeline이 종료 된 후에 실행되는 action이 저장되어 있다.\n\naction은 기본적으로 아래 순서대로 실행되지만, 동일한 action은 들어온대로 실행되는 것이 아닌 임의로 실행된다.\n\n1. `copy TTL inwards` : TTL을 체크하는 action을 실행\n2. `pop` : 만약, packet에 tag가 존재한다면, 모두 제거한\n3. `push MPLS` : MPLS tag(=label)을 추가\n4. `push PBB` : PBB tag를 추가\n5. `push VLAN` : VLAN tag를 추가\n6. `copy TTL outwards` : TTL을 체크하는 action을 실행\n7. `decrement TTL` : TTL을 감소시키는 action을 실행\n8. `set` : `set-field`에 해당하는 action을 실행\n9. `qos` : `qos` 관련 action을 실행\n10. `group` : 연관된 group bucket의 action을 실행\n11. `output` : `output` action으로 명시된 port로 packet을 forwarding\n\n\u003e **3. Action**\n\n실제로 packet을 처리하는 방법에 대한 방법이다.\n\n1. `output` : OpenFlow port 중 어디로 forwarding할지를 지정\n2. `set-queue` : QoS 지원을 위해 packet을 내보낼 Switch의 queue Id를 지정\n3. `drop` : 직접 호출할 수는 없지만, output이 없거나 `clean-actions` 수행 시에 내부적으로 수행한다.\n4. `group` : group을 통해 packet을 처리하도록 group table로 packet 전달\n5. `push-tag` : MPLS / VLAN 등의 tag를 추가\n6. `pop-tag` : MPLS / VLAN 등의 tag를 삭제\n7. `set-field` : header의 가장 끝에 특정 값을 추가\n8. `change-ttl` : ttl값을 수정\n\n## 표준화 현황\n\n| version | 발표일  | 주요 기능 추가                                  | 기관                |\n| :------ | :------ | :---------------------------------------------- | :------------------ |\n| OF 1.0  | 2009.12 | MAC, IPv4, Single Table                         | OpenFlow Consortium |\n| OF 1.1  | 2011.2  | MPLS/tunnel, Pipeline(Multi Table), Group Table | OpenFlow Consortium |\n| OF 1.2  | 2011.12 | IPv6, Of-Config, 다중 Controller 지원           | ONF                 |\n| OF 1.3  | 2012.9  | Meter Table(QoS), Controller 별Event Filtering  | ONF                 |\n| OF 1.4  | 2013.10 | Optical port monitoring, Flow 삭제 원인         | ONF                 |\n| OF 1.5  | 2014.12 | Egress Table 추가                               | ONF                 |\n\n현재에는 OpenFlow 표준화는 중단된 상태이다. 모든 요구사항을 받아들이다보니 match field의 크기가 너무나 커졌기 때문이다. 따라서, 이용자의 요구에 따라서 programming 할 수 있는 환경을 제공하기 위한 P4(Programmable Protocol-Independent Packet Protocol)을 제작하였다.\n\n즉, 기존에는 Protocol과 이를 지원하는 Switch를 주요 서비스로 삼았다면, 이제는 Programming이 가능한 언어와 이를 이용할 수 있는 Switch를 제공하는 방향으로 전환하였다.\n","slug":"openflow","title":"OpenFlow","category":"Network","tags":["SDN","ONF"],"date":"2022년 5월 25일 22:23","thumbnailSrc":"https://euidong.github.io/images/switch-with-cable.jpg"},{"content":"\n## Reference\n\n- Thumbnail : Photo by [Nastya Dulhiier](https://unsplash.com/@dulhiier?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/network?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n\nSDN(Software Defined Network)은 기존에 Hardware단에 결합되어 있던 각종 Routing, Forwarding 방식을 별도의 Controller를 통해서 제어하는 방식을 제시한 것이다. 현재 이러한 기술에 대한 연구가 꾸준히 이루어지고 있는데, 이유를 알기 위해서는 기존의 Network 구성 방식의 문제점을 먼저 짚어보자.\n\n## Internet의 문제\n\n\u003e **Traffic 과증가**\n\nTraffic의 매년 20% 이상으로 굉장히 가파르게 성장하고 있다. 이것 자체도 문제가 될 수 있지만, 이로 인한 문제가 더 큰 문제가 되고 있다.\n\n\u003e **통신사업자의 고민**\n\n계속해서 늘어나는 traffic 대비 수익의 정체가 발생하였다. 즉, 증가하는 traffic을 수용하기 위한 link, switch 등의 투자 비용은 계속해서 요구되는 한편 신규 가입자 수는 거의 존재하지 않기 때문에 통신사업자가 가져가는 수익은 현재 매우 정체되어있다. 반면에 늘어난 traffic에 대한 이득은 고스란히 대규모 service 업체에서 가져가고 있다. (ex. Google, Netflix, etc..)\n\n이러한 관점에서 통신사업자와 서비스 사업자 간의 아래와 같은 대립이 계속되고 있다.\n\n- 공정성(Fairity) : traffic 증가는 서비스 사업자도 같이 부담하자.\n- 망중립성(Neutrality) : traffic 증가는 서비스 사업자가 상관할 영역이 아니다.\n\n\u003e **느린 표준화**\n\n표준화라는 절차는 호환성 검사 및 성능 확인 등을 거치면서 굉장히 많은 시간을 요구한다. 하지만, 신기술은 계속해서 쏟아지고 있기 때문에 표준화가 이 속도를 못따라가고 있는 것이 실황이다. 이를 실제 상용에서 적용하는 것 역시 더 많은 시간이 들게 될 수 있다.\n\n\u003e **Vender 의존성**\n\n통신 장비(Switch, Router, Ethernet, etc...)를 제작하는 Vender(Cisco, Juniper, etc...)가 만든 platform에 의존하는 설정 방법이 혼란을 야기했다. 즉, 각 vender마다 다른 시스템과 configuration 방법이 존재하기 때문에 human error를 야기할 가능성이 높았다.\n\n또한, Switch/Router의 동작을 제어하는 것이 해당 vender가 제공하는 API에 제한되기 때문에 사용자가 Programming을 통해 Routing을 제어하는 것이 불가능했다. 그렇기에 신기술에 대한 테스트를 수행할 수 없을 뿐만 아니라 Vender에서 해당 신기술을 적용하기를 기다리는 수 밖에 없었다.\n\n\u003e **Router/Switch의 복잡도 증가**\n\ntraffic의 증가만큼 Router, Switch의 성능적인 향상 및 양적 증가는 많은 문제를 야기하고 있다. 먼저, 성능을 만족하기 위하여 점점 가격이 급격하게 상승하고 있다. 양적으로의 증가는 결국 Routing Table의 크기를 크게 증가시키고 있다. 이는 Table Lookup, Convergence Time 증가를 야기한다.\n\n\u003e **초기 인터넷의 구조적 문제**\n\n초기 인터넷인 ARPANET은 설계 자체가 절대 연결이 끊기지 않는(autonomous, Best Effort) Network를 추구했다. 그렇기에 사람에 의한 개입이 쉽지 않고, 통제가 어려운 구조이다. 따라서, 각 장비에게 부여되는 책임이 커졌다.\n\n\u003e **TCP/IP 기반의 수 많은 Protocol**\n\n지연보다는 연결에 초점을 맞춘 안전한 TCP/IP 기반의 통신은 Network의 성능면에서 많은 어려움을 겪고 있다. 물론 새로운 TCP 방식도 제시되고 있지만, 이를 교체하는 것은 전체 Network를 변경해야하는 경우가 많기에 이에 대한 교체는 사실상 불가능하다고 간주되고 있다(호환성 문제). 또한, IoT 디바이스에서는 해당 TCP/IP가 다소 무거운 구현이기에 이를 포함할 수 없는 경우가 많다. 따라서, 별도의 Protocol을 지원하는 시스템이 필요하다.\n\n### 요약\n\n즉, Traffic은 계속해서 증가하고 있는데, 이를 해결하기 위한 신기술들은 계속해서 적용이 느려지고 있으며, Vender들 마다 다른 표준으로 인해 너무나 복잡한 네트워크 구성은 운영비용의 최적화가 어렵고, 유연한 네트워크 구조를 만드는데 굉장한 부담으로 다가왔다. 따라서, 이를 해결할 방법이 필요해졌다.\n\n## SDN\n\n위에서 제시한 문제들은 결국 각 Switch/Router와 같은 Hardware 장치에 Software가 귀속되어서 발생한다. 따라서, Switch/Router는 단지 Hardware의 기능을 수행하도록하고, Software는 최소한의 기능만을 남긴 후 이들이 수행하는 Forwarding/Routing 등의 동작을 별도의 Generic Computer에 Controller라는 역할을 부여하고, 이 Controller에 의해서 Forwarding/Routing을 제어할 수 있도록 구성한 Network를 통해서 기존 문제를 해결하자는 것이다.\n\n이를 통해서, 결국 각 장치들은 Routing이 어떻게 정해졌는지에 대한 내용은 알지 못한다. 하지만, Hardware적으로 packet의 입력을 받을 수 있을 뿐만 아니라 Controller로부터 어디로 packet을 forwarding 해야할지에 대한 정보는 알고 있고, 이에 따라 packet을 내보내는 것도 가능하다. 따라서, 전체 네트워크가 Controller를 분리함으로써 추상화가 되는 것이다. 이러한 추상화의 장점은 결국 유연한 네트워크를 만들 수 있다는 것이다.\n\n이것이 SDN이 추구하는 사상이다. 이것을 가능하게 한 것이 OpenFlow의 등장이다. OpenFlow에 대한 설명은 별도의 [Posting](/posts/openflow)에서 다룬다.\n\n\n### Google의 SDN 활용 사례\n\n\u003e **문제 상황**\n\nGoogle에서는 매년 40\\~45%의 Traffic의 증가가 발생하였다. 이를 대비하기 위해서, Google에서 전용 해저 케이블을 설치하였다. 이를 통해서, Google의 각 DataCenter 간의 연결 품질을 올리고 싶었다. 하지만, 실제로 DataCenter간의 통신에는 30\\~40% 수준으로만 케이블을 사용했다. 기존의 Routing으로 DataCenter간 서비스의 Traffic을 적절하게 분배하고 싶었지만 이를 수행할 수 없었다.\n\n\u003e **해결책**\n\n자체 개발한 OpenFlow Protocol을 지원하는 Switch를 개발하여, 이를 이용하여, 다음과 같은 서비스에 weight를 부여하여 적절하게 traffic을 분배하였다.\n\n- User data copy : 각 데이터 센터간의 e-mail, video 등의 파일 동기화\n- 검색어 ranking을 위한 데이터 copy\n- Datacenter간 상태 동기화\n\n해당 service에서 발생하는 traffic을 적절하게 weight를 부과하여 SDN을 활용하여 분배하여 결국 Datacenter간의 통신에서 광케이블 활용률이 90%까지 상승했다.\n\n## NFV\n\nSDN과 같이 얘기되어지는 NFV(Network Function Virtualization)도 살펴보고자 한다. 위에서 SDN을 설명하였지만, 결국 아직까지는 DataCenter를 운영하는 서비스 사업자 지향적이다. 대게 닫힌 네트워크 내에서 사용이 용이하다는 것인데, 이는 보안과 관련된 부분도 부족하기 때문이다. 따라서, 통신 사업자들은 SDN을 효과적으로 구성하기 위해서 통신 장비의 하드웨어와 소프트웨어를 분리할 방법을 찾아야 했다. 여기서 나온 방법이 Cloud를 활용하여 소프트웨어 영역을 Cloud 내부에서 구현하고, 통신 장비는 최소한의 소프트웨어만으로 구성하는 것이다. 즉, Network의 특정 기능을 가상화해서 필요에 따라 각 하드웨어 장비가 불러와 사용한다는 개념이다. 결국 통신 사업자 입장에서는 SDN을 구축하기 위해서는 NFV의 구현이 우선시되는 것이다. 이를 수행하게 되면, 당연히 Software의 유연한 구현이 가능하고, 각 장치에서 Software까지 부담해야 하는 비용이 줄기 때문에 설치 및 운영비용(CAPEX / OPEX)에서 큰 이점을 볼 수 있는 것이다.\n","slug":"sdn","title":"SDN","category":"Network","tags":["SDN","NFV"],"date":"2022년 5월 25일 09:00","thumbnailSrc":"https://euidong.github.io/images/network-background.jpg"},{"content":"\n### Reference\n\n- Thumbnail: Photo by [Arno Senoner](https://unsplash.com/@arnosenoner?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/forwarding?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n\n---\n\nSegment Routing은 MPLS의 차세대 버전으로, 초기에는 MPLS의 문제를 해결하기 위해서 제시되었다. 예를들면, TE(Traffic Engineering) 시에 Star Topology에서는 효율이 안나온다던지 ECMP(Traffic을 여러 output interface로 분배시키는 방식)을 활용할 수 없다와 같은 제한을 해결하고자 등장하였다. 그렇지만, 현재에 와서 와서 더 중요시 여겨지는 것은 **네트워크 구조의 단순화**이다. 즉, 기존의 복잡하던 Switch의 설정 방법(통신장비 vender 마다 다른 설정법, 여러 Protocold이 존재)과 운용 방법을 통일하고, 단순화 시킴으로써 사람에 의한 에러(Human Error)를 최소화하고자 하는 노력이라고 볼 수 있다.\n\n### 용어\n\n- **Segment** : 하나의 path가 여러 개의 작은 path들로 구성되는 것에서 유래하였다고 보며, 하나의 명령어(instruction)을 segment라고도 부른다. 명령어는 어디로 전달할 것인가와 packet을 어떻게 변형할 것인가에 대한 내용을 포함한다.  \n  Segment는 SID라는 id값을 통해서 구분하며, 이는 [0, 1,048,575] 까지를 사용할 수 있다. 특별한 목적을 가지는 [0, 15,000) 예약된 SID이고, [15,000 ~ 16,000)는 인접한 egress Router를 가르키는데 사용하는 `Adjacency SID`이고, [16,000, 24,000)는 Segment Routing이 유효한 범위 내에서 각 Router에 임의 설정이 가능한 영역대로 `Prefix SID` 라고 부른다. 그 외에 영역은 동적으로 할당되는 SID로 자동 할당 시에 사용된다. 여기서 중요한 점은 **Adjacency SID와 Prefix SID만 있으면, 모든 경로를 표현하는 것이 가능하다는 것이다.** 추가적으로, SR Policy를 재사용하고 싶은 경우가 발생할 수 있는데 이를 위해서 SR Policy 자체에 SID를 부여하는 것이 BSID(Binding SID)이다.\n  [그림]\n- **Headend Router** : Segment Routing 영역으로 들어오는 Ingress Router이다.\n\n### 동작 원리\n\nSegment Routing 영역으로 Packet이 진입하면, 해당 packet의 Destination과 부가 정보를 확인하여, SR Policy(=Segment List, 방문해야할 경로를 순서대로 나열해놓은 리스트)를 MPLS 또는 IPv6의 부가 공간에 삽입한다. 이때에는 Stack 형태로 List를 구성하고, 중간 Router들에서는 Segment에 따라서 동작을 수행하며, packet을 최종 Egress Router까지 전달한다. 여기서 각 경로는 모든 세세한 경로를 표시할 필요는 없다. 만약 A에서 B로 가는 SID를 설정했어도, 그 내부에서 어떤 경로를 선택할지는 System적으로 알아서 Routing하도록 설정하는 것도 가능하다.(`Loose Source Routing`) Ingress에서 SR Policy를 지정하면 이를 `Push`라고 하고, 내부 Router는 가장 아래 Segment를 확인하고 자신과 관련 있는 경우에는 `Pop`을 수행하여 하나의 Segment를 삭제 후 이에 따라 동작을 수행하고, 그렇지 않으면 연결된 Link로 기존 BGP에 따라 알아서 Routing을 수행한다. 이를 `Continue`라고 한다.\n\n### Usecase\n\n다음과 같은 형태로 Routing을 설정하는 것이다. 아래 예시에서는 모두 1 -\u003e 2 -\u003e 3 -\u003e 4 순으로 Routing을 수행하기를 원한다고 생각하자.\n\n`SID 16002`의 경우에는 `1 -\u003e 2`로 이동하는 것이 `1 -\u003e 4 -\u003e 3 -\u003e 2` 보다 IGP cost가 적으므로, `1 -\u003e 2`로 원하는대로 이동할 것이라고 예상할 수 있다.\n이후 `SID 16004`의 경우에도 `2 -\u003e 3 -\u003e 4`로 이동하는 것이 `2 -\u003e 1 -\u003e 4`로 이동하는 것보다 IGP cost가 적으므로, `2 -\u003e 3 -\u003e 4`로 원하는대로 이동하는 것을 예상할 수 있다.\n\n[그림 1 - 경우 1]\n\n하지만, IGP cost가 우리의 바램과는 다른 경우에는 다음과 같은 현상이 발생할 수도 있다.\n아래에서 `SID 16004`를 보면, `2 -\u003e 1 -\u003e 4`가 `2 -\u003e 3 -\u003e 4`보다 IGP cost가 적기 때문에 우리가 원하는 방향과는 반대로 동작할 것임을 예상할 수 있다. 따라서, 이를 해결하기 위해서 우리는 다음과 같은 경로를 채택해야 한다.\n\n[그림 2 - 경우 2]\n\n여기서는 `1 -\u003e 2 -\u003e 3`이 `1 -\u003e 4 -\u003e 3`보다 크기 때문에 원하는대로 `1 -\u003e 2 -\u003e 3`으로 움직일 것이다. 하지만, 여기서 `3 -\u003e 4`로 가는 경로가 어려울 수 있다. 이 경우에는 앞 서 보았던 Adjacency SID를 활용하여야 한다. 이는 마지막으로 가야할 egress Router를 지정하기 때문에 routing 시에 costing을 고려하지 않고, 바로 Static Routing이 가능하다. 따라서, 이를 활용하면 최종으로 `3 -\u003e 4`로 가는 경로를 획득하는 것이 가능하다.\n\n[그림 3 - 경우 3]\n\n### Configuration\n\n- SR-MPLS : MPLS와 같은 방식을 추구하지만, 설정 방식에서 LDP와 RSVP를 사용하지 않고 IGP를 활용해서 이를 수행할 수 있도록 하여 Protocol을 단순화하였다.  \n  Segment List(`SR Policy`)를 전달하는 과정이 MPLS의 Label을 전달하는 방식과 유사하며, 지나야하는 경로를 명시하여 stack 형태로 쌓아서 전달하면, 각 내부 Router는 이를 참고하여 제거 또는 유지하며, Egress Router를 찾는다.\n- SRv6 : IGP와 IPv6 Protocol만을 활용하여 네트워크를 구성할 수 있도록 하는 것이 목표이다. 네트워크 자체를 프로그래밍 하고자 하는 요구 때문에 필요성이 강조되었다. 이는 IPv6의 주소값인 128bit를 topology를 식별할 주소값과 packet 처리를 위한 값(특정 packet에게는 다른 routing table을 적용 등)으로 나누어 사용함으로써 구현이 가능하다. 따라서, IPv4의 짧은 주소 체계로는 이를 수행할 수 없다. 따라서, IPv6 Protocol을 이용하여 수행하는 것이다.  \n  Segment List(`SR Policy`)를 전달하는 과정은 위와 유사하지만, 이를 IPv6 Option 영역에 stack형태로 저장한다.\n\n### Traffic Engineering\n\nTraffic을 제어하고, 해당 제어를 위한 제한사항들을 실시간으로 update하고, 운용 관리하는 것이 가능하다. MPLS에서 수행하던 TE(Traffic Engineering)과 유사하지만, Bandwidth를 사용하지 않는 대신에 delay라는 조건을 갖고 있다. 이는 packet이 도착하는데 걸리는 시간을 측정한 값이다.  \n해당 조건들을 활용하여 Traffic을 입맛에 맞게 변경하는 것이 가능하다.\n\n또한, 장애 대책 시에도 Segment Routing은 강점을 가지고 있다. 일반적인 OSPF를 활용하는 경우에는 LFA(Loop Free Alternate)를 통해서 우회 경로를 계산한다. 하지만, 이는 생각보다 비효율적인 경로 계산을 수행하게 된다. 따라서, 이를 개선하는데 Segment Routing이 적절하다. 다음 예시를 보자.\n\n[그림]\n\n장애 이전에 `1 -\u003e 2 -\u003e 3 -\u003e 5` 그리고 `6 -\u003e 2 -\u003e 3 -\u003e 5` 라는 traffic이 존재할 때, 만약 `2 -\u003e 3` link가 끊어지면, 기존의 LFA를 이용하면 찾게 되는 경로는 다음 경로와 같아진다. 이는 상당히 비효율적인 경로인데, 이렇게 계산을 수행하는 이유는 `1 -\u003e 2 -\u003e 6 -\u003e 7 -\u003e 3 -\u003e 5` 라는 차선 경로로 가는 도중에 `2 -\u003e 6`으로 이동 이후에 기존 Traffic에 영향으로 인해 `6 -\u003e 2`로 다시 돌아오는 현상이 발생하기 때문이다. 따라서, 결론상 더 큰 비용이 발생하는 경로(`2 -\u003e 9`)로 들어가서 오히려 더 많은 비용이 발생하게 된다.\n\n이를 해결하기 위해서는 장애가 발생한 이후에 다시 IGP가 계산하는 최단 경로인 `Post-Convergence Path`를 사용하면 된다. 하지만, 해당 경로는 Loop를 야기할 가능성이 존재한다. 이로 인해, 해당 방식을 사용하지 않았었는데, Segment Routing을 이용하여 경로를 제한함으로써 Post Convergence Path를 사용할 수 있게 되었다. 즉, Segment Routing의 Adjacency SID를 이용해서 나가야할 지점을 명확하게 하며, Loop가 발생할 수 있는 지점에서 Static Routing을 지정하면서, Prefix SID를 통해서 경로를 적절히 지정하여 해결이 가능한 것이다.\n\n### Programmable\n\nSegment Routing의 또 하나의 강점은 SDN 지향적인 구조라는 것이다. 즉, 중앙에서 각 Switch의 동작을 제어하는 Controller를 Segment Routing을 통해서 직접 구현이 가능하다는 것이다. 즉, Segment Routing Network가 특정 Controller에게 자신의 상태 정보 등을 주기적으로 보내면, Controller에서는 이를 이용해서 Database를 구축하고, 이를 바탕으로 Routing Table을 완성하는 것이다. 이를 기반으로, 후에 요청이 Headend 장치로 들어오면, 해당 장치는 Controller에게 처리를 요청하고, 이에 대한 응답을 받은 Headend 장비는 적절하게 SR Policy를 해당 packet에 저장하여 Routing이 가능해지는 것이다.\n\n### Summary\n\n|                   | MPLS                                                               | SR-MPLS                  | SRv6                 | Segment Routing의 장점                                                            |\n| :---------------- | :----------------------------------------------------------------- | :----------------------- | :------------------- | :-------------------------------------------------------------------------------- |\n| 제어 프로토콜     | 기반 : IGP/BGP, 추가 : LDP/RSVP-TE                                 | IGP/BGP                  | IGP/BGP              | LDP/RSVP-TE 와 같은 추가 Protocol이 없음                                          |\n| 데이터 평면       | MPLS 데이터 평면을 정의해서 사용                                   | MPLS 데이터 평면을 활용  | IPv6를 활용          | IPv6를 활용한 경우 추가적인 설정이 필요없음                                       |\n| 경로 계산 및 조정 | 사실 Ingress에서 설정하지만 각 노드가 관여                         | Source(Ingress)에서 결정 | 동일                 | Source Routing으로 명확한 구조                                                    |\n| LSP의 Label 관리  | LSP의 갯수가 많아질 수록 각 노드의 부담 증가                       | 인접 노드, 링크만 관리   | 동일                 | 내부 Router의 부담이 크게 감소                                                    |\n| Operation         | Push, Swap, Pop                                                    | Push, Next, Continue     | 동일                 | Swap 연산이 필요없다.                                                             |\n| 장애 대책         | Fast ReRoute                                                       | TI-LFA, Fast ReRoute     | 동일                 | Fast ReRoute는 convergence time이 길어 실용 사례가 적다.                          |\n| Programmability   | 불가능                                                             | 불가능                   | Network Programmable | IPv6를 이용한다면, Traffic Engineering, VPN을 Programming을 통해 구현이 가능하다. |\n| 네트워크 확장성   | 일반적으로는 높다. 하지만, RSVP-TE를 활용하는 경우 낮아질 수 있다. | 확장성이 높다.           | 동일                 | 확장성이 높다.                                                                    |\n| 네트워크 구조     | 일반적인 분산 제어 구조                                            | SDN 적용이 가능          | 동일                 | SDN 기반의 중앙집중 제어와 기존 방식으로 분산 제어도 가능함                       |\n","slug":"segment-routing","title":"Segment Routing","category":"Network","tags":["Routing"],"date":"2022년 5월 23일 10:41","thumbnailSrc":"https://euidong.github.io/images/forwarding.jpg"}]}},"__N_SSG":true},"page":"/","query":{},"buildId":"SZR6hfY4iOgLPmapXPdc9","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>