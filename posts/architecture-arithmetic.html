<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="description" content="Just Tech Blog"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta property="og:type" content="blog"/><meta property="og:site_name" content="JustLog"/><title>3. Arithmetic<!-- --> | JustLog<!-- --></title><meta property="og:url" content="https://euidong.github.io/posts/architecture-arithmetic"/><meta property="og:title" content="3. Arithmetic"/><meta property="og:description" content="Just Tech Posting"/><meta property="og:image" content="https://euidong.github.io/images/default.jpg"/><meta name="next-head-count" content="10"/><link rel="icon" href="https://euidong.github.io/favicon.png"/><link rel="apple-touch-icon" href="https://euidong.github.io/logo192.png"/><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7452732177557701" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/05397e4762032a4c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/05397e4762032a4c.css" data-n-g=""/><link rel="preload" href="/_next/static/css/62095437b77217ec.css" as="style"/><link rel="stylesheet" href="/_next/static/css/62095437b77217ec.css" data-n-p=""/><link rel="preload" href="/_next/static/css/0280a25e2c606f5b.css" as="style"/><link rel="stylesheet" href="/_next/static/css/0280a25e2c606f5b.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-81da43a8dcd978d9.js" defer=""></script><script src="/_next/static/chunks/main-7b6c38cbad60dfcf.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f48285af76dbcc5b.js" defer=""></script><script src="/_next/static/chunks/175675d1-5e59763be147fa1f.js" defer=""></script><script src="/_next/static/chunks/675-ae8e8a351ce30ae2.js" defer=""></script><script src="/_next/static/chunks/332-5860389bd4081566.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-3dc22c0239d7ec00.js" defer=""></script><script src="/_next/static/bkZxmn80PN7rXSZz1oSH_/_buildManifest.js" defer=""></script><script src="/_next/static/bkZxmn80PN7rXSZz1oSH_/_ssgManifest.js" defer=""></script><script src="/_next/static/bkZxmn80PN7rXSZz1oSH_/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_wrapper__dKJSz root"><header class="Layout_header__XosLl"><div><input type="checkbox" class="SideBarToggler_openSidebarMenu__FWGTp" id="openSidebarMenu"/><label class="SideBarToggler_sidebarIconToggle__y_9Yh" for="openSidebarMenu" tabindex="1"><div class="SideBarToggler_spinner__0IPkC SideBarToggler_diagonal__XS8QG SideBarToggler_part-1__X7acd"></div><div class="SideBarToggler_spinner__0IPkC SideBarToggler_horizontal__Awo5t"></div><div class="SideBarToggler_spinner__0IPkC SideBarToggler_diagonal__XS8QG SideBarToggler_part-2__Fx2xu"></div></label><nav class="SideBar_side_bar__wrapper--close__8Nwnr"><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/">Home</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/tags">Tags</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Algorithm">Algorithm<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->10<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Computer%20Architecture">Computer Architecture<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->5<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Docker">Docker<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->1<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Web">Web<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->2<!-- -->)<!-- --></span></a></nav></div><a class="Logo_logo___yD0t" tabindex="1" href="/"></a><div><button class="SearchBarToggler_search_bar_toggler__3dHbA" tabindex="2"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="25px" width="25px" xmlns="http://www.w3.org/2000/svg"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"></path></svg></button></div></header><section><div class="Post_post__wrapper__Qq8vV"><h1 class="Post_post__title__CYNLY">3. Arithmetic</h1><p class="Post_post__date__Sx37s">2022년 4월 27일 20:50</p><article class="markdown-body MarkDown_markdown-body__ABwUt"><h2><strong>Reference<!-- --></strong></h2>
<!-- --><p><img src="/images/default.jpg" alt="&lt;img src=&quot;/images/default.jpg&quot; width=&quot;190&quot; /&gt;"/></p>
<!-- --><p>David A. Patterson, John L. Hennessy, Computer Organization and Design<!-- --></p>
<!-- --><p>본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 &quot;-다&quot;로 표현합니다.<!-- --></p>
<!-- --><ul>
<!-- --><li>Full Adder 이미지는 WIKIPEDIA full adder의 발췌이다. (<!-- --><a href="https://upload.wikimedia.org/wikipedia/commons/5/57/Fulladder.gif">https://upload.wikimedia.org/wikipedia/commons/5/57/Fulladder.gif<!-- --></a>)<!-- --></li>
<!-- --></ul>
<!-- --><hr/>
<!-- --><p>여기서는 기본이 되는 <!-- --><strong>사칙연산<!-- --></strong>과 <!-- --><strong>소수점<!-- --></strong>의 표현방식(<!-- --><strong>Floating Point<!-- --></strong>)을 다룹니다.<!-- --></p>
<!-- --><h2>Overflow<!-- --></h2>
<!-- --><p>시작하기에 앞서서 Overflow라는 개념을 알고가야한다. Overflow란 특정 변수의 표현범위를 벗어나는 경우에 발생하게 되는 에러 상황을 의미한다. 일반적인 사람의 생각에는 수의 범위가 있는 것은 이상할 수 있지만, 컴퓨터에서는 이것이 매우 당연하다. 무한대를 표현하는 것은 사실상 컴퓨터로는 불가능하다. 대신 매우 큰 수를 통해서 표현하는 것이 컴퓨터에게는 일반적이다. 예를 들어 우리가 빈번하게 사용하는 integer 변수 type은 그 값의 범위가 정해져있다. 이는 대게 하나의 변수를 표현하기 위해서 4bytes를 사용하는데 이는 32bits이기 때문에, 최대 <!-- --><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2<!-- --></mn><mn>32<!-- --></mn></msup></mrow><annotation encoding="application/x-tex">2^{32}<!-- --></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord">2<!-- --></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">32<!-- --></span></span></span></span></span></span></span></span></span></span></span></span></span>까지가 표현의 범위가 되는 것이다. 여기에 음수를 표현하게 되는 경우에는 범위가 <!-- --><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−<!-- --></mo><msup><mn>2<!-- --></mn><mn>31<!-- --></mn></msup></mrow><annotation encoding="application/x-tex">-2^{31}<!-- --></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em"></span><span class="mord">−<!-- --></span><span class="mord"><span class="mord">2<!-- --></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31<!-- --></span></span></span></span></span></span></span></span></span></span></span></span></span> ~ <!-- --><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2<!-- --></mn><mn>31<!-- --></mn></msup></mrow><annotation encoding="application/x-tex">2^{31}<!-- --></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord"><span class="mord">2<!-- --></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31<!-- --></span></span></span></span></span></span></span></span></span></span></span></span></span>로 제한된다. 따라서, 이렇게 범위를 벗어나는 경우에 대해서는 programming language 마다 처리가 달라지지만, 대게 에러를 발생시키는 것이 일반적이다. (python에서는 알아서 범위를 추가한다.)<!-- --></p>
<!-- --><h2>덧셈 / 뺄셈<!-- --></h2>
<!-- --><p>덧셈은 각 자릿수의 합과 이전 자릿수에서 올림된 수(Carry)의 합이라고 다시 해석할 수 있다.
이진수에서는 결국 올림된 수와 두 수가 만들어 낼 수 있는 경우의 수는 00 ~ 11이다.<!-- --></p>
<!-- --><table><thead><tr><th style="text-align:left">A<!-- --></th><th style="text-align:left">B<!-- --></th><th style="text-align:left">Carry<!-- --></th><th style="text-align:left">Result<!-- --></th></tr></thead><tbody><tr><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">00<!-- --></td></tr><tr><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">01<!-- --></td></tr><tr><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">01<!-- --></td></tr><tr><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">10<!-- --></td></tr><tr><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">01<!-- --></td></tr><tr><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">10<!-- --></td></tr><tr><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">10<!-- --></td></tr><tr><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">11<!-- --></td></tr></tbody></table>
<!-- --><p>이를 수행하기 위해서 우리는 XOR 2개와 AND 2개 그리고 OR 1개로 만들 수 있다.(C&#x27;와 S가 결과값이다.)<!-- --></p>
<!-- --><table><thead><tr><th style="text-align:left">A<!-- --></th><th style="text-align:left">B<!-- --></th><th style="text-align:left">Carry(C)<!-- --></th><th style="text-align:left">A XOR B(D)<!-- --></th><th style="text-align:left">A AND B(E)<!-- --></th><th style="text-align:left">C AND D(F)<!-- --></th><th style="text-align:left">E OR F(C&#x27;)<!-- --></th><th style="text-align:left">C XOR D(S)<!-- --></th></tr></thead><tbody><tr><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td></tr><tr><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td></tr><tr><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td></tr><tr><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td></tr><tr><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td></tr><tr><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td></tr><tr><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td></tr><tr><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">0<!-- --></td><td style="text-align:left">1<!-- --></td><td style="text-align:left">1<!-- --></td></tr></tbody></table>
<!-- --><p><img src="https://upload.wikimedia.org/wikipedia/commons/5/57/Fulladder.gif" alt="fullAdder"/></p>
<!-- --><h3>음수<!-- --></h3>
<!-- --><p>음수는 기본적으로 2의 보수라는 방식을 활용한다. 만약 특정 수를 음수로 변환하고 싶다면 전체 수를 반전 시킨 후 <!-- --><code>+1<!-- --></code>을 수행하는 방식이다. 이를 통해서, 우리는 쉽게 음수를 생성할 수 있다. 그리고 놀랍게도 특정 수를 음수로 변환하고 덧셈을 하게 되면, 이것이 바로 뺄셈이 된다.<!-- --></p>
<!-- --><h2>곱셈<!-- --></h2>
<!-- --><p>먼저 이진수의 곱셈은 아래와 같이 십진수에서의 곱셈 연산과 방법은 같다.<!-- --></p>
<!-- --><p>곱해지는 수(multiplicand), 곱하는 수(multipler), 곱해진 결과(product)이다.<!-- --></p>
<!-- --><p><img src="/images/multiplication.png" alt="곱셈 예제"/></p>
<!-- --><p>하지만, 여기서 하나의 특징을 발견할 수 있다. 각 자릿수의 결과값은 곱하는 수에 의해서 결정된다는 점이다. 곱하는 수가 1이면, 곱해지는 수의 해당 자릿수가 결과값이 되고, 0이면 무조건 0이라는 결과가 나온다는 것을 알 수 있다. 따라서, 다음과 같은 알고리즘에 따라서 연산이 수행된다는 것을 알 수 있다.<!-- --></p>
<!-- --><p><img src="/images/multiplication-flow.png" alt="곱셈 알고리즘"/></p>
<!-- --><p>만약, 음수의 곱셈의 경우에는 간단하게 해당 값을 양수로 변환하고, 연산을 수행한 뒤에 다시 음수로 변환하는 방식을 수행한다.<!-- --></p>
<!-- --><h2>나눗셈<!-- --></h2>
<!-- --><p>나눗셈은 역시 동일하다.<!-- --></p>
<!-- --><p>나누어지는 수(Dividend), 나누는 수(Divisor), 몫(Quotient), 나머지(Remainder) 이다.<!-- --></p>
<!-- --><p><img src="/images/division.png" alt="나눗셈 예제"/></p>
<!-- --><p>이때는 역으로 나누는 수를 오른쪽으로 32번 shift하여 매우 큰 수로 만들고, 나머지를 나누어지는 수로 초기화하여 차근차근 빼보면서 양수이면 빼고, 음수이면 되돌리기를 반복하면서 몫과 나머지를 계산할 수 있다.<!-- --></p>
<!-- --><p><img src="/images/division-flow.png" alt="나눗셈 알고리즘"/></p>
<!-- --><h2>실수 연산<!-- --></h2>
<!-- --><p>위에서는 여태까지 정수의 연산을 다루었지만, 소수점을 포함하는 실수 연산을 수행할 때에는 달라지는 사항이 꽤나있다.<!-- --></p>
<!-- --><p>먼저, 실수를 표기하기 위한 방법을 먼저 보자.<!-- --></p>
<!-- --><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>31231.<!-- --></mn><msub><mn>4<!-- --></mn><mrow><mo stretchy="false">(<!-- --></mo><mn>10<!-- --></mn><mo stretchy="false">)<!-- --></mo></mrow></msub><mo>=<!-- --></mo><mn>3.1231<!-- --></mn><msub><mn>4<!-- --></mn><mrow><mo stretchy="false">(<!-- --></mo><mn>10<!-- --></mn><mo stretchy="false">)<!-- --></mo></mrow></msub><mo>×<!-- --></mo><mn>1<!-- --></mn><msup><mn>0<!-- --></mn><msub><mn>4<!-- --></mn><mrow><mo stretchy="false">(<!-- --></mo><mn>10<!-- --></mn><mo stretchy="false">)<!-- --></mo></mrow></msub></msup></mrow><annotation encoding="application/x-tex">31231.4_{(10)} = 3.12314_{(10)} \times 10^{4_{(10)}}<!-- --></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9996em;vertical-align:-0.3552em"></span><span class="mord">31231.<!-- --></span><span class="mord"><span class="mord">4<!-- --></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(<!-- --></span><span class="mord mtight">10<!-- --></span><span class="mclose mtight">)<!-- --></span></span></span></span></span><span class="vlist-s">​<!-- --></span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=<!-- --></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.9996em;vertical-align:-0.3552em"></span><span class="mord">3.1231<!-- --></span><span class="mord"><span class="mord">4<!-- --></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(<!-- --></span><span class="mord mtight">10<!-- --></span><span class="mclose mtight">)<!-- --></span></span></span></span></span><span class="vlist-s">​<!-- --></span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×<!-- --></span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8175em"></span><span class="mord">1<!-- --></span><span class="mord"><span class="mord">0<!-- --></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8175em"><span style="top:-3.0664em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">4<!-- --></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3448em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5357em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(<!-- --></span><span class="mord mtight">10<!-- --></span><span class="mclose mtight">)<!-- --></span></span></span></span></span><span class="vlist-s">​<!-- --></span></span><span class="vlist-r"><span class="vlist" style="height:0.3695em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<!-- --><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100101.<!-- --></mn><msub><mn>1<!-- --></mn><mrow><mo stretchy="false">(<!-- --></mo><mn>2<!-- --></mn><mo stretchy="false">)<!-- --></mo></mrow></msub><mo>=<!-- --></mo><mn>1.00101<!-- --></mn><msub><mn>1<!-- --></mn><mrow><mo stretchy="false">(<!-- --></mo><mn>2<!-- --></mn><mo stretchy="false">)<!-- --></mo></mrow></msub><mo>×<!-- --></mo><msup><mn>2<!-- --></mn><mrow><mn>10<!-- --></mn><msub><mn>1<!-- --></mn><mrow><mo stretchy="false">(<!-- --></mo><mn>2<!-- --></mn><mo stretchy="false">)<!-- --></mo></mrow></msub></mrow></msup></mrow><annotation encoding="application/x-tex">100101.1_{(2)}= 1.001011_{(2)} \times 2^{101_{(2)}} <!-- --></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9996em;vertical-align:-0.3552em"></span><span class="mord">100101.<!-- --></span><span class="mord"><span class="mord">1<!-- --></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(<!-- --></span><span class="mord mtight">2<!-- --></span><span class="mclose mtight">)<!-- --></span></span></span></span></span><span class="vlist-s">​<!-- --></span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=<!-- --></span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.9996em;vertical-align:-0.3552em"></span><span class="mord">1.00101<!-- --></span><span class="mord"><span class="mord">1<!-- --></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(<!-- --></span><span class="mord mtight">2<!-- --></span><span class="mclose mtight">)<!-- --></span></span></span></span></span><span class="vlist-s">​<!-- --></span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×<!-- --></span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8175em"></span><span class="mord"><span class="mord">2<!-- --></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8175em"><span style="top:-3.0664em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10<!-- --></span><span class="mord mtight"><span class="mord mtight">1<!-- --></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3448em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5357em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(<!-- --></span><span class="mord mtight">2<!-- --></span><span class="mclose mtight">)<!-- --></span></span></span></span></span><span class="vlist-s">​<!-- --></span></span><span class="vlist-r"><span class="vlist" style="height:0.3695em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<!-- --><p>이를 일반적으로 normalization이라고 하며, 이진수 체계에서는 다음과 같은 형태를 갖게 된다.<!-- --></p>
<!-- --><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>1.xxxxx<!-- --></mtext><mo>×<!-- --></mo><msup><mn>2<!-- --></mn><mrow><mi>y<!-- --></mi><mi>y<!-- --></mi><mi>y<!-- --></mi><mi>y<!-- --></mi><mi>y<!-- --></mi></mrow></msup></mrow><annotation encoding="application/x-tex">\text{1.xxxxx} \times 2^{yyyyy}<!-- --></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em"></span><span class="mord text"><span class="mord">1.xxxxx<!-- --></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×<!-- --></span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6644em"></span><span class="mord"><span class="mord">2<!-- --></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em">yyyyy<!-- --></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<!-- --><p>따라서, 대게 실수를 표현할 때에는 x부분(fraction)과 y부분(exponent) 그리고 부호를 표현(sign)하는 부분으로 나누어서 저장한다. 이 또한, 4byte를 통해서 표현할 경우에는 x부분에 8bits, y부분에 23bits 그리고 부호에 1bit를 할당한다.<!-- --></p>
<!-- --><p>따라서, 일반적으로 표현하면 다음과 같이 쓰는 것이 일반적인 실수의 표현이다.<!-- --></p>
<!-- --><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(<!-- --></mo><mo>−<!-- --></mo><mn>1<!-- --></mn><msup><mo stretchy="false">)<!-- --></mo><mi>s<!-- --></mi></msup><mo>×<!-- --></mo><mo stretchy="false">(<!-- --></mo><mn>1<!-- --></mn><mo>+<!-- --></mo><mtext>Fraction<!-- --></mtext><mo stretchy="false">)<!-- --></mo><mo>×<!-- --></mo><msup><mn>2<!-- --></mn><mrow><mo stretchy="false">(<!-- --></mo><mtext>Exponent<!-- --></mtext><mo stretchy="false">)<!-- --></mo></mrow></msup></mrow><annotation encoding="application/x-tex">(-1)^s \times(1+\text{Fraction})\times2^{(\text{Exponent})}<!-- --></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(<!-- --></span><span class="mord">−<!-- --></span><span class="mord">1<!-- --></span><span class="mclose"><span class="mclose">)<!-- --></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s<!-- --></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×<!-- --></span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(<!-- --></span><span class="mord">1<!-- --></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+<!-- --></span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord">Fraction<!-- --></span></span><span class="mclose">)<!-- --></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">×<!-- --></span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.888em"></span><span class="mord"><span class="mord">2<!-- --></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.888em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(<!-- --></span><span class="mord text mtight"><span class="mord mtight">Exponent<!-- --></span></span><span class="mclose mtight">)<!-- --></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<!-- --><p>단, 모두 0이면 0으로 친다. floating point 연산은 후에 더 시간이 있으면 자세히 다루겠다.<!-- --></p></article><ins class="adsbygoogle" style="display:block;text-align:center;margin:50px 0" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7452732177557701" data-ad-slot="1964032750"></ins><div class="ColumnCard_column_card__list__background__kZObh"><h2 class="ColumnCard_column_card__list__title__pawoL">Related Posts</h2><div class="ColumnCard_column_card__list__wrapper__lsbEP"><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/architecture-base"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/default.jpg?imwidth=384 1x, https://euidong.github.io/images/default.jpg?imwidth=640 2x" src="https://euidong.github.io/images/default.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/architecture-base">1. Base</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Computer%20Organization%20And%20Design"># <!-- -->Computer Organization And Design<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/ISA"># <!-- -->ISA<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/architecture-instruction"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/default.jpg?imwidth=384 1x, https://euidong.github.io/images/default.jpg?imwidth=640 2x" src="https://euidong.github.io/images/default.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/architecture-instruction">2. Instruction</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Computer%20Organization%20And%20Design"># <!-- -->Computer Organization And Design<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Instruction"># <!-- -->Instruction<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/ISA"># <!-- -->ISA<!-- --></a></ul></div></div><div class="ColumnCard_column_card__wrapper__iVPbY"><a class="ColumnCard_column_card__thumbnail__wrapper__M3Kfm" href="/posts/architecture-processor"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27320%27%20height=%27320%27/%3e"/></span><img alt="thumbnail" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="ColumnCard_column_card__thumbnail__bx9FL" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover"/><noscript><img alt="thumbnail" srcSet="https://euidong.github.io/images/default.jpg?imwidth=384 1x, https://euidong.github.io/images/default.jpg?imwidth=640 2x" src="https://euidong.github.io/images/default.jpg?imwidth=640" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:cover" class="ColumnCard_column_card__thumbnail__bx9FL" loading="lazy"/></noscript></span></a><div class="ColumnCard_column_card__tray__v9oLc"><a class="ColumnCard_column_card__tray__title__fEApg" tabindex="-1" href="/posts/architecture-processor">4. Processing</a><ul class="ColumnCard_column_card__tray__tag__UUiD6"><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Computer%20Organization%20And%20Design"># <!-- -->Computer Organization And Design<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Processing"># <!-- -->Processing<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/MIPS%20Implementation"># <!-- -->MIPS Implementation<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Pipeline"># <!-- -->Pipeline<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/Branch%20Prediction"># <!-- -->Branch Prediction<!-- --></a><a tabindex="-1" class="ColumnCard_column_card__tray__tag__li__YRXLc" href="/tags/SuperScalar"># <!-- -->SuperScalar<!-- --></a></ul></div></div></div></div></div></section><footer class="Layout_footer__EL5v8"><div class="Layout_footer__copyright__r5baC"><span>Copyright © euidong</span><br/><span>모든 컨텐츠에 대한 저작권은 작성자에게 존재합니다. <!-- --><br/>불법 복제를 통한 상업적 사용을 절대적으로 금지합니다. <!-- --><br/>단, 비상업적 이용의 경우 출처 및 링크를 적용한다면 자유롭게 사용가능 합니다.<!-- --></span><span>Also I use photos by<!-- --> <!-- --><a href="https://unsplash.com/@lorenzoherrera?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Lorenzo Herrera</a> <!-- -->on<!-- --> <!-- --><a href="https://unsplash.com/s/photos/tech?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Unsplash</a></span></div><div class="Layout_footer__contents__YZWSm"><a class="Layout_footer__contents__link__K_TKH" href="https://github.com/euidong" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>github</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://euidong.github.io/portfolio" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M6 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-5 6s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H1zM11 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5zm.5 2.5a.5.5 0 0 0 0 1h4a.5.5 0 0 0 0-1h-4zm2 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2zm0 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2z"></path></svg><span>portfolio</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://chrome.google.com/webstore/detail/bonfire/nkooidijgbppkojdgkoafcoppnohdfka?hl=ko" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M5.016 16c-1.066-2.219-0.498-3.49 0.321-4.688 0.897-1.312 1.129-2.61 1.129-2.61s0.706 0.917 0.423 2.352c1.246-1.387 1.482-3.598 1.293-4.445 2.817 1.969 4.021 6.232 2.399 9.392 8.631-4.883 2.147-12.19 1.018-13.013 0.376 0.823 0.448 2.216-0.313 2.893-1.287-4.879-4.468-5.879-4.468-5.879 0.376 2.516-1.364 5.268-3.042 7.324-0.059-1.003-0.122-1.696-0.649-2.656-0.118 1.823-1.511 3.309-1.889 5.135-0.511 2.473 0.383 4.284 3.777 6.197z"></path></svg><span>chat</span></a></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"content":"## **Reference**\n\n![\u003cimg src=\"/images/default.jpg\" width=\"190\" /\u003e](/images/default.jpg)\n\nDavid A. Patterson, John L. Hennessy, Computer Organization and Design\n\n본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 \"-다\"로 표현합니다.\n\n- Full Adder 이미지는 WIKIPEDIA full adder의 발췌이다. (https://upload.wikimedia.org/wikipedia/commons/5/57/Fulladder.gif)\n\n---\n\n여기서는 기본이 되는 **사칙연산**과 **소수점**의 표현방식(**Floating Point**)을 다룹니다.\n\n## Overflow\n\n시작하기에 앞서서 Overflow라는 개념을 알고가야한다. Overflow란 특정 변수의 표현범위를 벗어나는 경우에 발생하게 되는 에러 상황을 의미한다. 일반적인 사람의 생각에는 수의 범위가 있는 것은 이상할 수 있지만, 컴퓨터에서는 이것이 매우 당연하다. 무한대를 표현하는 것은 사실상 컴퓨터로는 불가능하다. 대신 매우 큰 수를 통해서 표현하는 것이 컴퓨터에게는 일반적이다. 예를 들어 우리가 빈번하게 사용하는 integer 변수 type은 그 값의 범위가 정해져있다. 이는 대게 하나의 변수를 표현하기 위해서 4bytes를 사용하는데 이는 32bits이기 때문에, 최대 $2^{32}$까지가 표현의 범위가 되는 것이다. 여기에 음수를 표현하게 되는 경우에는 범위가 $-2^{31}$ ~ $2^{31}$로 제한된다. 따라서, 이렇게 범위를 벗어나는 경우에 대해서는 programming language 마다 처리가 달라지지만, 대게 에러를 발생시키는 것이 일반적이다. (python에서는 알아서 범위를 추가한다.)\n\n## 덧셈 / 뺄셈\n덧셈은 각 자릿수의 합과 이전 자릿수에서 올림된 수(Carry)의 합이라고 다시 해석할 수 있다. \n이진수에서는 결국 올림된 수와 두 수가 만들어 낼 수 있는 경우의 수는 00 ~ 11이다.\n\n| A    | B    | Carry | Result |\n| :--- | :--- | :---- | :----- |\n| 0    | 0    | 0     | 00     |\n| 0    | 0    | 1     | 01     |\n| 0    | 1    | 0     | 01     |\n| 0    | 1    | 1     | 10     |\n| 1    | 0    | 0     | 01     |\n| 1    | 0    | 1     | 10     |\n| 1    | 1    | 0     | 10     |\n| 1    | 1    | 1     | 11     |\n\n이를 수행하기 위해서 우리는 XOR 2개와 AND 2개 그리고 OR 1개로 만들 수 있다.(C'와 S가 결과값이다.)\n\n| A    | B    | Carry(C) | A XOR B(D) | A AND B(E) | C AND D(F) | E OR F(C') | C XOR D(S) |\n| :--- | :--- | :------- | :--------- | :--------- | :--------- | :--------- | :--------- |\n| 0    | 0    | 0        | 0          | 0          | 0          | 0          | 0          |\n| 0    | 0    | 1        | 0          | 0          | 0          | 0          | 1          |\n| 0    | 1    | 0        | 1          | 0          | 0          | 0          | 1          |\n| 0    | 1    | 1        | 1          | 0          | 1          | 1          | 0          |\n| 1    | 0    | 0        | 1          | 0          | 0          | 0          | 1          |\n| 1    | 0    | 1        | 1          | 0          | 1          | 1          | 0          |\n| 1    | 1    | 0        | 0          | 1          | 0          | 1          | 0          |\n| 1    | 1    | 1        | 0          | 1          | 0          | 1          | 1          |\n\n![fullAdder](https://upload.wikimedia.org/wikipedia/commons/5/57/Fulladder.gif)\n\n### 음수\n\n음수는 기본적으로 2의 보수라는 방식을 활용한다. 만약 특정 수를 음수로 변환하고 싶다면 전체 수를 반전 시킨 후 `+1`을 수행하는 방식이다. 이를 통해서, 우리는 쉽게 음수를 생성할 수 있다. 그리고 놀랍게도 특정 수를 음수로 변환하고 덧셈을 하게 되면, 이것이 바로 뺄셈이 된다.\n\n## 곱셈   \n먼저 이진수의 곱셈은 아래와 같이 십진수에서의 곱셈 연산과 방법은 같다.   \n\n곱해지는 수(multiplicand), 곱하는 수(multipler), 곱해진 결과(product)이다.\n\n![곱셈 예제](/images/multiplication.png)\n\n하지만, 여기서 하나의 특징을 발견할 수 있다. 각 자릿수의 결과값은 곱하는 수에 의해서 결정된다는 점이다. 곱하는 수가 1이면, 곱해지는 수의 해당 자릿수가 결과값이 되고, 0이면 무조건 0이라는 결과가 나온다는 것을 알 수 있다. 따라서, 다음과 같은 알고리즘에 따라서 연산이 수행된다는 것을 알 수 있다.\n\n![곱셈 알고리즘](/images/multiplication-flow.png)\n\n만약, 음수의 곱셈의 경우에는 간단하게 해당 값을 양수로 변환하고, 연산을 수행한 뒤에 다시 음수로 변환하는 방식을 수행한다.\n\n## 나눗셈\n나눗셈은 역시 동일하다.   \n\n나누어지는 수(Dividend), 나누는 수(Divisor), 몫(Quotient), 나머지(Remainder) 이다.\n\n![나눗셈 예제](/images/division.png)\n\n이때는 역으로 나누는 수를 오른쪽으로 32번 shift하여 매우 큰 수로 만들고, 나머지를 나누어지는 수로 초기화하여 차근차근 빼보면서 양수이면 빼고, 음수이면 되돌리기를 반복하면서 몫과 나머지를 계산할 수 있다.\n\n\n![나눗셈 알고리즘](/images/division-flow.png)\n\n## 실수 연산\n\n위에서는 여태까지 정수의 연산을 다루었지만, 소수점을 포함하는 실수 연산을 수행할 때에는 달라지는 사항이 꽤나있다.    \n\n먼저, 실수를 표기하기 위한 방법을 먼저 보자.\n\n$$31231.4_{(10)} = 3.12314_{(10)} \\times 10^{4_{(10)}}$$   \n\n$$100101.1_{(2)}= 1.001011_{(2)} \\times 2^{101_{(2)}} $$   \n\n이를 일반적으로 normalization이라고 하며, 이진수 체계에서는 다음과 같은 형태를 갖게 된다.\n\n$$\\text{1.xxxxx} \\times 2^{yyyyy}$$\n\n따라서, 대게 실수를 표현할 때에는 x부분(fraction)과 y부분(exponent) 그리고 부호를 표현(sign)하는 부분으로 나누어서 저장한다. 이 또한, 4byte를 통해서 표현할 경우에는 x부분에 8bits, y부분에 23bits 그리고 부호에 1bit를 할당한다.\n\n따라서, 일반적으로 표현하면 다음과 같이 쓰는 것이 일반적인 실수의 표현이다.\n\n$$(-1)^s \\times(1+\\text{Fraction})\\times2^{(\\text{Exponent})}$$\n\n단, 모두 0이면 0으로 친다. floating point 연산은 후에 더 시간이 있으면 자세히 다루겠다.\n","slug":"architecture-arithmetic","title":"3. Arithmetic","category":"Computer Architecture","tags":["Computer Organization And Design","Arithmetic"],"date":"2022년 4월 27일 20:50","thumbnailSrc":"https://euidong.github.io/images/default.jpg"},"relatedPosts":[{"content":"\n## **Reference**\n\n![\u003cimg src=\"/images/default.jpg\" width=\"190\" /\u003e](/images/default.jpg)\n\nDavid A. Patterson, John L. Hennessy, Computer Organization and Design\n\n본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 \"-다\"로 표현합니다.\n\n---\n\n## **1\\. 8 Greate Ideas**\n\n컴퓨터 구조를 설계하는 과정에서 중요하게 여겨지는 8가지 핵심 아이디어들이다. 뿐만 아니라 이는 전체적인 컴퓨터 과학에서 중요하다고 볼 수 있는 아이디어들이다. 따라서, 앞으로의 Posting에서 Why라는 의문이 든다면, 아래 8가지 이유 중의 하나로 설명할 수 있다.\n\n1.  **Moore's Law**  \n    18 ~ 24 개월마다 컴퓨터 성능의 지대한 영향을 미치는 IC 칩의 성능이 2배씩 성장한다는 Moore의 주장에서 유래하였다. 즉, **컴퓨터의 성능은 지수적으로 빠르게 성장을 하고 있음을 의미한다.** 이로 인해 구조를 설계하는 과정에서도 현재의 IC 칩의 성능에 맞추는 것이 아닌 이보다 더 큰 성능을 타겟으로 설정을 한다.\n2.  **Abstraction**  \n    우리 말로 추상화라고 표현하며, 복잡한 하위 내용을 모두 기술하지 않고, 간단하게 표현하여 이를 쉽게 사용할 수 있도록 하는 방식이다. 이를 통해서, **설계 과정에서의 복잡도를 줄일 수 있다.**\n3.  **Common Case Fast**  \n    **드물게 일어나는 case보다는 일반적인 case를 빠르게 만듬으로써 성능을 향상시킬 수 있다.** 드물게 일어나는 case는 매우 복잡하고, 해결하기도 난해할 수 있다. 하지만, 대게의 경우 일반적인 case는 간단하다. 이를 최적화하는 것이 전체적인 시스템 성능 향상에 큰 도움이 되는 것은 당연하며 해결도 매우 쉽다.\n4.  **Performance via Parallelism**  \n    성능 향상을 위한 방법은 크게 두 가지이다. 하나는 하나의 장치의 성능을 올리는 것이고 또 하나가 바로 **하나의 작업을 여러 명이 동시에 수행하는 방식이다.**\n5.  **Performance via Pipelining**  \n    성능 향상을 위한 병렬처리 방식 중에서 가장 유명한 방식이 pipelining이다. 쉽게 생각하면, 분업이라고 할 수 있다. **여러 명이서 하나의 목적을 위해 일을 할 때, 효율적으로 작업하기 위해서 업무를 분담하여 동시에 작업**하는 방식이다.\n6.  **Performance via Prediction**  \n    우리는 무슨 작업을 할 때, 아직 결정되지 않은 사항 때문에 기다리는 경우가 있는데, 이것이 어떻게 될지를 **예측하여 기다리지 않고, 미리 진행하자**는 발상에서 나온 것이다. 만약, 이 예측의 적중률이 높다면, 성능 향상에 굉장한 도움을 줄 수 있다.\n7.  **Hierarchy of Memories**  \n    컴퓨터의 사용자가 원하는 메모리는 빠르고, 크고, 싸야 한다. 하지만, 빠르기 위해서는 비싸야하고, 크기 위해서도 비싸야 한다. 그래서 생각해낸 방법이 계층화이다. **빠르고, 작은 memory를 위로 쌓고, 느리고, 큰 memory를 아래로 쌓음으로써 비용을 절감**하자는 것이다.\n8.  **Dependability via Redundancy**  \n    컴퓨터는 빠르기만 해서 되는 것은 아니다. **신뢰**할 수 있는 시스템을 구축해야 한다. 실패하지 않는 시스템을 구축하는 것은 매우 힘든 일이기 때문에, 우리는 **여분 장치**를 두어 이를 통해서 실패 시에 이를 떠맡을 수 있도록 하는 설계를 해야 한다.\n\n## **2\\. Below Your Program**\n\nprogram 밑에는 무엇이 있는가?\n\n우리의 program은 모두 application software이고, 이는 hardware 바로 위에 존재하는 것이 아닌 system software위에서 동작하게 된다.\n\n![\u003cimg src=\"/images/kernel.png\" width=\"190\" /\u003e](/images/kernel.png)\n\n**System Software**는 Hardware를 직접적으로 제어하거나 computer가 작동하기 위해 필수적이며 기본적인 softwre를 말한다. 그 중에서 가장 대표적인 것이 OS이고 **OS**는 사실상 우리가 보는 Software와 Hardware 간의 interface역할을 한다. 예를 들어, memory 관리, process 관리 등(이는 OS 에서 자세히 배웁시다.)을 수행한다. 반면, **Application** **Software**는 직접적으로 hardware를 관리하거나 필수적인 요소는 아니지만 computer를 통해서 가치있는 작업을 수행하도록 한다. 대표적인 예시가 웹브라우저, word, game 등이 여기에 포함된다.\n\n  그렇다면, 우리가 만든 코드(Application Software)가 어떻게 실행되어질 수 있을까? 이 또한, System Software인 compiler, assembler, linker, loader의 도움을 통해서 실행되어진다. **compiler**는 우리가 고 수준의 언어(C++, Java, 등)로 만든 software code를 Assembly 언어로 변경한다. 그러면, 이를 **Assembler**가 0과 1로 이루어진 기계어로 번역해준다. 해당 작업이 끝나면, **Linker**가 나타나 여러 개로 나뉘어져있던 이 파일과 기존 라이브러리를 하나의 파일로 묶어주는 역할을 한다. 이 작업을 마치고 만들어진 최종 파일을 실행하고자할 때, **Loader**는 이를 memory에 올리는 역할을 한다. 이렇게 실행된 program은 여기서 그치지 않고, memory의 아예 다른 영역에 위치하는 library도 불러와서 사용하는 것이 가능하다. 이것을 **Dynamic Linked Library**(DLL)라고 한다.\n\n![\u003cimg src=\"/images/run-process.png\" width=\"190\" /\u003e](/images/run-process.png)\n\n이렇게 하나의 코드를 작성하면, 실제로 실행되기까지 여러 작업들을 거쳐야만 한다. 그럼에도 assembly 언어나 기계어를 사용하여 코딩을 하지 않는 이유는 아래 세 가지 이유가 주요하다.\n\n1.  사람이 이해하기 쉽다.\n2.  생산성을 높일 수 있다.\n3.  Compiler와 assembly를 통해서 어디서든 돌아가는 프로그램을 제작할 수 있다.\n\n## **3\\. Under the Covers**\n\n우리의 컴퓨터는 어떻게 이루어지는가를 크고 얇게 한 번 알아볼 것이다.\n\n-   **Input Device** : 우리의 입력을 받는 부분이다. 마우스, 키보드, 터치스크린 등이 있다.\n-   **Output Device** : 우리가 출력을 받는 부분이다. 모니터, 프린터 등이 있다.\n-   **IC(Integrated Circuits, Chip)** : 집적 회로로 번역되어지며, 통상 우리가 chip이라고 부르는 녀석들이다. 이들은 적게는 수십개 많게는 억 단위 이상에 이르는 양의 transister를 가지고 있고, 이를 통해서 데이터를 저장하거나 처리하는 역할을 할 수 있다. 즉, IC를 통해서 CPU, Memory를 만들 수 있다.\n    -   trasistor: 쉽게 말해서 전기를 통해서 on/off를 수행할 수 있는 switch라고 볼 수 있다. 이를 통해서, 데이터를 연산하거나 저장하는 것이 가능하다.\n-   **CPU (Central Processor Unit, Processor, MicroProcessor)** : 중앙 처리 장치라는 의미로, 각종 연산과 I/O Device 처리 등의 중심 역학을 수행한다. CPU는 크게 두 개의 요소로 이루어진다.\n    -   DataPath : 수학적인 연산을 수행한다.\n    -   Control : program의 instruction이 무엇을 요구하는지를 입출력 장치, memory 또는 datapath에 전달합니다.\n-   **Memory(RAM(Random Access Memory), main memory, primary memory)** : 실행되고 있는 프로그램이 위치하는 곳이다. 실행되는 프로그램에 대한 정보와 같은 내용을 포함한다고 할 수 있다. 이는 DRAM으로 이루어진다. 또한, Random Access Memory라고 불리는 이유는 어느 위치에 데이터를 저장하고 있어도 해당 데이터를 찾는데 걸리는 시간이 동일하기 때문이다.\n    -   DRAM(Dynamic Random Access Memory) : IC chip을 통해서 만들어진다. 여기서 Random Access란 접근할 때, 앞에서부터 차례로 접근하는 것이 아닌 한 번에 바로 짚을 수 있음을 의미한다.\n-   **Cache Memory** : 대게 Cache라고도 부르며, Processor 내부에 존재하는 memory라고 볼 수 있다. 즉, 실제 Memory의 buffer 기능을 한다. 여기서는 SRAM을 사용한다.\n\n-   SRAM(Static Random Aceess Memory) : DRAM보다는 빠르지만, 집적도가 낮고 더 비싸기 때문에 많이 사용할 수는 없는 chip이다. 하지만, 성능 향상을 위해서 processor 바로 앞에 buffer로써 사용한다.\n-   buffer : 자료구조의 queue를 이용한 것으로, 처리를 요청한 대상과 처리를 수행하는 대상 사이에서 데이터를 잠깐 보관하기 위한 장소로 사용된다.\n\n-   **Secondary Memory** : main memory는 휘발성이라는 특징을 갖고 있기 때문에 시스템이 종료되어 전기가 더 이상 공급되지 않으면, 모든 데이터는 날라간다. 이를 막기 위해서 그리고 부족한 main memory의 저장공간을 보조하기 위해서 보조 기억 장치를 사용한다. 이것에 사용되는 것은 크게 두 가지 이다.\n    -   magnatic disk : 자기 disk를 이용해서 정보를 저장하는 방식이다. 전기가 공급되지 않음에도 정보를 저장하고 있을 수 있다.\n    -   flash memory : 반도체를 이용하여 데이터를 저장하며, DRAM보다는 느리지만, 더 싸고 휘발성이 없다.\n-   **Instruction Set Architecture(ISA, architecture)** : 0과 1로 이루어진 기계어가 들어왔을 때, 이것이 무슨 의미인지를 나타내는 instruction \bSet에 따라 CPU가 알맞은 연산을 수행하는 architecture이다.\n    -   Instruction \bSet : hardware에게 동작을 요청하는 하나의 명령어를 Instruction이라고 한다. 이들이 무슨 역할을 하는지를 정리해놓은 것이 Instruction Set이다. 이를 통해서, Operating System은 hardware에 접근하여 특정 동작을 수행시킬 수 있다.\n    -   ABI(Application Binary Interface) : application 단에 programmer가 hardware 작업 등을 수행하기 위하여 호출할 수 있다. 이를 통해서, binary한 동작도 application programmer가 조작할 수 있다. 일반적인 API와 역할이 동일하지만, programming language가 아닌 machine language를 사용하여 구현되기 때문에 hardware 접근 등에 제한이 없다.\n\n## **4\\. Performance**\n\n우리가 Computer의 성능을 측정하는 것은 중요하다. 왜냐하면, 이를 지표로 계속해서 computer의 성능을 향상시켜야 하기 때문이다.\n\n그래서 우리는 다음과 같이 표현하는 것이 일반적이다.\n\n$$\\text{Excution Time} = \\text{Clock Cycle Time} \\times {\\text{Number of Instruction}} \\times {CPI}$$\n\n즉, **총 실행 시간**(Execution Time)은 **한 번 Clock이 회전하는데 걸리는 시간**(Clock Cycle Time)에 해당 **program의 instruction 수**(Number of Instruction) 그리고 **하나의 instruction을 처리하는데 걸리는 clock cycle의 횟수**(CPI)라고 볼 수 있다.\n\n즉, 우리가 특정 프로그램을 빠르게 돌리고 싶다면, 다음과 같은 식으로 생각할 수 있다.\n\n1.  한 번 회전하는데 걸리는 시간을 줄이기 위해 클락 frequency를 높인다. **하지만, 회전열로 인해 현재는 frequency를 올리는 것은 포기하고 있다.**\n2.  프로그램을 잘 짜거나 Compiler를 더욱 더 최적화하여 instruction의 수를 줄인다.\n3.  하드웨어를 잘 설계해서 명령 하나를 처리하는데 걸리는 시간(CPI)을 줄인다.\n4.  동시에 여러 CPU를 실행시켜서, 실행을 하는 unit 자체를 더 만드는 방법도 있다.\n\n따라서, 앞으로 우리가 Performance를 올리기 위해서, Compiler를 어떻게 최적화할지를 계략적으로 배우며, 하드웨어를 어떻게 잘 설계할지를 자세히 알아볼 것이다. 또한, Parallelism을 통해서 작업을 더 빠르게 수행하는 방법 또한 다룰 것이다.\n\n---\n\n## **\\+ Amdahl's Law**\n\n작업의 성능을 개선시켰을 때 이전과 비교하여 얼마나 효율이 증가했는지를 보여주는 지표이다.\n\n$$1\\over{(1-P) + {P\\over{S}}}$$\n\n여기서 개선된 작업이 전체에서 차지하는 비율을 P라고 하고, 해당 작업의 향상된 작업 효율을 S라고 한다.\n\n만약, 전체에 10%를 차지하는 작업을 2배 빠르게 진행한다면,\n\n$${1\\over{(1-0.1) + {0.1\\over{2}}}} = {1\\over{0.95}} \\approx 1.05$$\n\n따라서, 단기간의 성능향상을 하고 싶다면, 비율이 큰 작업의 성능향상을 꾀하는 것이 좋다는 것을 알 수 있다.","slug":"architecture-base","title":"1. Base","category":"Computer Architecture","tags":["Computer Organization And Design","ISA"],"date":"2022년 4월 12일 00:00","thumbnailSrc":"https://euidong.github.io/images/default.jpg"},{"content":"\n## **Reference**\n\n![\u003cimg src=\"/images/default.jpg\" width=\"190\" /\u003e](/images/default.jpg)\n\nDavid A. Patterson, John L. Hennessy, Computer Organization and Design\n\n본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 \"-다\"로 표현합니다.\n\n---\n\n컴퓨터가 알아들을 수 있는 명령을 우리는 Instruction이라고 한다. 그렇다면, 이들을 모아놓은 단어장(Vocabulary)는 **Instruction set**이 되는 것이다. 이런 의미에서 현대의 computer는 이를 기반으로 동작하도록 설계되었기 때문에, 이를 **Instruction set architecture**라고 부른다. 해당 책에서는 MIPS를 기준으로 하기 때문에 똑같이 MIPS를 기준으로 설명합니다. 이는 다른 processor들과 매우 유사하니 이를 배우면 쉽게 다른 것도 이해할 수 있을 것이다.\n\n그렇다면, Instruction이란 무엇일까? 이는 기계어(0과 1로 이루어진 이진수 체계)의 형태로 표현된다. 따라서, 이를 Assembly Instruction이라고도 한다. 이는 hardware에게 특정 동작을 수행하도록 하는 명령어라고 할 수 있다. 그렇기에 우리가 실행하거나 작성하는 모든 program들은 사실 Instruction들의 집합이라고 볼 수 있다. 실제로 Computer에서 Program이 동작할 때, 이는 Computer는 memory에 program의 내용과 program에서 사용할 data들을 위한 공간을 배정해준다. 그런 후에 실제로 실행될 때에는 program의 Instruction을 차례차례 읽어가면서 실행하는 것이다.\n\n---\n\n## **Assembly Instruction의 구성요소**\n\n기본적으로 MIPS는 32bit(=4Bytes) 시스템을 사용한다. 따라서, 하나의 Instruction은 4 Bytes로 표현된다. 이를 하나의 가장 단위라고 여겨서 word라고도 부른다. 따라서, 64bit(=8Bytes) CPU에서는 1 word가 8 Bytes가 될 수도 있다. 결국 모든 Instruction이 0과 1로 이루어진다. 하지만, 이는 너무 읽기 어렵기 때문에 우선 Assembly(기계어보다는 사람의 언어에 가깝지만 아주 원초적인 형태의 언어) Instruction을 알아볼 것이다. 이를 기계어로 바꾸는 것은 해당 포스팅의 밑에서 다룬다. \n\n#### **1\\. Operand**\n\n연산을 위해서 필요한 것은 연산자와 피연산자이다. 보통의 programming 언어에서는 이를 변수라고 한다.\n\nMIPS에서는 총 두 가지의 변수 type이 존재한다.\n\n1.  **Constant**  \n    하나의 상수로써 동작하는 변수이다. 주어진 범위 내에서 자유롭게 상수로 사용가능하다.\n2.  **Register No**  \n    하드웨어 상의 register들과 programming에서의 변수와 차이점이 있다면, 바로 갯수의 제한이 있다는 것이다. 보통은 갯수를 32개로 제한한다. 그렇게 하는 것이 효율적이라고 찾아냈다고 한다. 더 많이 써도 Clock Cycle이 더 소모될 뿐이고, 적다면 표현력이 부족해지 수도 있다. 또한, 하나의 register의 크기 또한 우리는 대게 32bit(1 word)로 제한한다. 이를 표현할 때에는 보통 \\$ 표시를 활용하고, register는 특정 목적을 위해서 지정되어 있다. (밑에 표를 참고)  \n    Instruction에서는 Register를 가르키기 위해서 5bit를 사용한다. $2^5$이면 모든 Register를 구분할 수 있기 때문이다.\n3.  **Memory Address**  \n    해당 공간에는 기본적으로 register에 담기진 못한 모든 정보가 저장된다. 왜냐하면, register 가 하나의 변수를 표현할 수 있는데 만약, 변수가 32개를 넘어간다면, 이를 처리하는 것이 매우 버거워진다. 따라서, 이를 임시로 저장해두어야 한다. 따라서, 이를 memory에 잠깐 저장하는데 이를 **spilling register**라고 부른다.  \n    좀 더 복잡한 데이터 구조를 가지는 경우에도 이를 모두 register에 담는 것은 불가능하다. 따라서, 우리는 Memory라는 것을 활용한다. Memory는 8bit 단위로 한 칸으로 나누어 4개의 칸을 합친 것을 하나의 단위로 봅니다. (왜냐하면 이것이 4x8bit = 32bit = 1word가 되기 때문이다.) 따라서, 우리가 특정 값에 접근할 때에는 4의 배수로 접근하는 것이 올바른 접근이다. 또한, 하나의 데이터가 4개의 칸으로 쪼개지기 때문에 저장 방법에 차이가 있을 수 있다. 어떤 사람들은 앞 자리부터 차곡차곡 넣을 수도 있지만, 누구는 역순으로도 넣을 수 있기 때문에 이를 유의해야 한다. MIPS에서는 앞에서붙터 차곡차곡 넣는 Big Endian 방식을 사용한다. (즉, 4개 중 가장 낮은 주소값에 높은 값을 의미하는 값(MSB)이 쓰인다.)  \n    하나의 Memory address를 가르키기 위해서는 32bit가 필요하다. 이렇게 하여 $2^{32}$ = 4GB 이하까지의 Memory는 가르킬 수 있는 것이다. Instruction 자체가 32bit인데, 이를 Instruction에 바로 넣을 수는 없기 때문에 특정 Memory address를 가르키기 위해서 별도의 register에 해당 Memory의 address를 저장해두고 해당 지점부터 offset을 constant로 전달하는 식으로 표기한다.(여기서 4의 배수로 memory가 표현되므로, 2bit를 뺀다고 해도 30bit로 여전히 많다.)\n\n다음은 MIPS의 Register와 Memory를 나타낸 것이다.\n\n![\u003cimg src=\"/images/registers.png\" width=\"190\" /\u003e](/images/registers.png)\n\n상식적으로 알아두고 갈 부분은 reigster는 직접적으로 연산이 이루어지는 곳이기 때문에, register에 접근하는 비용이 memory에 접근하는 부분보다 확연하게 비용이 싸다.(시간이 짧게 걸린다.) 따라서, 이를 효율적으로 다루어주는 것이 효율 향상에 도움이 된다.\n\n#### **2\\. Operation**\n\n모든 computer는 기본적인 연산을 수행할 수 있어야 한다. MIPS에서는 다음과 같은 표기법을 사용한다.\n\n```\n1. \u003c명령어(operation)\u003e \u003c연산자(operand) 1\u003e \u003c연산자(operand) 2\u003e \u003c연산자(operand) 3\u003e\n\n2. \u003c명령어(operation)\u003e \u003c연산자(operand) 1\u003e \u003c연산자(operand) 2\u003e\n\n3. \u003c명령어(operation)\u003e \u003c연산자(operand)\u003e\n```\n\n마치 우리가 영어를 처음 배울 때, 1형식, 2형식 배우는 형태랑 유사하다. 그리고 여기서는 모든 문장이 명령형으로 구성된다는 점을 유의하자. 이에 따라서, 다음 MIPS의 피연산자(operand)와 주요 Operation을 살펴보자.\n\n\u003e **Add / Substract**\n\n`add [연산자1] [연산자2] [연산자3]`\n\n모든 연산의 기본으로 위의 형태 중에서 첫번째에 해당한다. 이를 수학 기호로 나타내면 다음과 같다.\n\n`[연산자1] = [연산자2] + [연산자3]`\n\nSubstraction 연산도 이와 동일하게 동작한다.\n\n\u003e **Load / Save**\n\n우리가 Register에 특정 데이터를 저장하기를 원한다면, $zero register 에 저장하기를 원하는 값 또는 register를 add해서 해당 register에 저장하면 된다.\n\n`add [저장을 원하는 register No] [$zero] [1234]`\n\n하지만, Memory에 데이터를 저장하기 위해서는 별도의 명령어가 필요하다. 그것이 save 명령어 입니다. 앞 서 말한 것과 같이 memory address를 직접적으로 Instruction에 표현할 수는 없기 때문에 특정 register에 주소값을 저장하고, 해당 주소를 base로 해서 offset을 더해서 주소를 찾는 형태로 수행한다.\n\n`sw [불러올 register No] [Memory의 Base Address를 가진 register No] offset`\n\n이와 반대로 Memory에서 데이터를 register로 불러올 때에도 별도의 명령어가 필요하다.\n\n`lw [불러올 register No] [Memory의 Base Address를 가진 register No] offset`\n\n\u003e **Jump**\n\nInstruction 역시 Memory에 상주하고 있는데, 만약 필요에 따라 이전 Instruction으로 돌아가거나 Instruction을 뛰어넘어야 한다면, 그때 사용할 수 있는 Instruction이다.\n\n`j [이동할 instruction offset]`\n\n\u003e **Branch**\n\nBranch(분기)는 특정 조건의 부합 여부를 확인하고, Jump를 수행하는 Instruction이다. 이를 위한 operator가 beq, bne가 있다.\n\n`beq [비교할 register1] [비교할 register2] [이동할 instruction offset]`\n\nregister1과 2가 서로 동일하다면, 해당 instruction offset으로 이동하라는 의미이다. bne는 반대로 두 register가 다를 때에 이동할 수 있다.\n\n\u003e **기타 주요 명령어**\n\n![\u003cimg src=\"/images/instruction.png\" width=\"190\" /\u003e](/images/instruction.png)\n\n\\* PC : Program Counter의 줄임말로 현재 실행하고 있는 Program에서 어느 위치의 Instruction을 실행시키고 있는지를 나타낸다. 이를 이용해서 CPU는 다음 Instruction을 불러온다.\n\n\\* offset : offset은 대게 instruction 단위로 나타내기 때문에 1 offset은 4Bytes를 의미한다. 따라서, offset을 실제 주소에 더할 때에는 곱하기 4(실제로는 shift left 2)를 해야한다. 이로 인해서, 현재 Instruction의 다음 Instruction의 주소를 PC+4 라고 한다.\n\n---\n\n## **Instruction를 이용한 \bProgramming 언어 기본 요소 구현**\n\n#### **1\\. 조건문 (if / else)**\n\n```\nif (i == j) \n\tf = g + h;\nelse\n\tf = g - h;\n```\n\n다음과 같은 c의 조건문 코드를 아래와 같은 Instruction들로 변환이 가능하다. \n\n```\nbne $s3, $s4, Else # go to Else if i != j\nadd $s0, $s1, $s2 # f = g + h (skipped if i != j)\nj Exit # go to Exit\n\nElse: \nsub $s0, $s1, $s2 # f = g - h (skipped if i = j)\n\nExit:\n```\n\n여기서 Else는 임의의 offset을 나타낸다. 따라서, \"Else:\"라고 표시된 부분에 해당하는 offset이라고 생각하면 된다.\n\nSwitch/Case 문 같은 경우는 if/else로 변환해서 나타내기도 하고, 아니면 Switching 위치를 적어놓은 Table을 만들어서 해당 위치로 바로 이동하는 식으로 구현하기도 한다.\n\n#### **2\\. 반복문 (while)**\n\n```\nwhile(save[i] == k)\n\ti += 1;\n```\n\n다음과 같은 c의 반복문을 아래와 같은 Instruction들로 변환이 가능하다.\n\n```\n# $t1 : save[i] address pointer\n# $t0 : save[i] value\n# $s3 : i\n# $s6 : save의 base address (save[0] address pointer)\n# $s5 : k\n\n# sll shift left \"\u003c\u003c\" 를 의미합니다. \n# 즉, 아래에서는 두 번하므로, *2^2를 의미합니다.\nLoop: \nsll $t1, $s3, 2 # temp reg $t1 = i * 4\nadd $t1, $t1, $s6 # $t1 = address of save[i]\nlw $t0, 0($t1) # temp reg $t0 = save[i]\nbne $t0, $s5, Exit # go to Exit if save[i] != k\naddi $s3, $s3, 1 # i = i + 1\nj Loop # go to Loop\n\nExit:\n```\n\n#### **3\\. 함수 (function)**\n\nprocedure는 대게 function(함수)이라고도 불린다. 함수를 우리는 하나의 예시를 통해서 설명할 수 있다.\n\nprocedure를 비밀 작전을 맡고 떠난 spy라고 하자. 작전은 자원을 습득하여, 특정 작업을 수행하고, 흔적을 감춘 뒤에, 바람직한 결과를 들고 돌아오는 것을 의미한다. 즉, spy는 작업을 마치고, 원하는 결과를 갖고 왔지만, 해당 결과 외에는 아무것도 바뀌지 않기를 기대한다. (누군가한테 의심받지 않아야하기 때문에)\n\n이러한 과정이 똑같이 함수의 호출마다 발생한다. 아래는 이를 다소 축약한 형태입니다.\n\n1.  parameter를 procedure가 접근할 수 있는 곳에 위치시킵니다.\n2.  control을 procedure(callee)로 옮깁니다.\n3.  procedure는 해당하는 자원(parameter)을 습득합니다.\n4.  목표한 바를 수행합니다.\n5.  결과값을 자신을 호출한 program(caller)이 접근할 수 있는 곳에 위치시킵니다.\n6.  control을 호출한 곳(caller)으로 넘깁니다.\n\n\\* 여기서 control이 이동했다는 것은 \bPC값이 PC+4가 아닌 함수의 주소로 이동했다는 것을 의미합니다.\n\n이를 구현하기 위해서 우리는 다음과 같은 별도의 register를 사용합니다.\n\n```\n$a0 - $a3 : 4 argument(=parameter) registers.\n$v0 - $v1 : 2 return value registers.\n$ra : 1 return address register. 원래 위치를 기억하기 위한 register.\n```\n\n\\$a와 \\$v는 사실 함수 사용에서 필수적이기 때문에 쉽게 받아들일 수 있지만, \\$ra가 의아할 수 있을 것이다. 이는 procedure를 호출했던 시점으로 다시 돌아오기 위해서 호출한 시점의 주소(실제로는 호출한 시점에서 다음 Instruction의 주소)를 저장하고 있는 것이다. 이러한 과정 즉, \\$ra에 저장과 jump를 동시에 해주는 것이 jal instruction이다. 이는 바로 다음 instruction을 가르키도록 하여 PC+4로 저장하고, 특정 지점으로 이동한다. 그리고 돌아올 때에는 jr instruction을 이용해서 \\$ra로 돌아올 수 있다.\n\n만약, 더 많은 변수를 return value, argument로 쓰고 싶다면 우리는 이를 memory로 옮기는 과정을 수행해야 한다. 이때, computer 에서는 stack이라는 구조를 사용한다. (실제로 구현하는 것은 아니고, 마치 stack 처럼 사용하기에 이렇게 부른다.) Stack pointer라는 register(\\$sp)를 이용하여 현재 사용하고자 하는 data가 stack의 어디를 가르키고 있는지를 저장한다.\n\n\u003e **실제 예제**   \n\n```\nint leaf_example (int g, int h, int i, int j) {\n\tint f;\n\t\n\tf = (g + h) - (i + j);\n\treturn f;\n}\n```\n\n```\nleaf_example:\naddi $sp, $sp, –12 # adjust stack to make room for 3 items\nsw $t1, 8($sp) # save register $t1 for use afterwards\nsw $t0, 4($sp) # save register $t0 for use afterwards\nsw $s0, 0($sp) # save register $s0 for use afterwards\n\nadd $t0,$a0,$a1 # register $t0 contains g + h\nadd $t1,$a2,$a3 # register $t1 contains i + j\nsub $s0,$t0,$t1 # f = $t0 – $t1, which is (g + h)–(i + j)\n\nadd $v0,$s0,$zero # returns f ($v0 = $s0 + 0)\n\nlw $s0, 0($sp)  # restore register $s0 for caller\nlw $t0, 4($sp)  # restore register $t0 for caller\nlw $t1, 8($sp)  # restore register $t1 for caller\naddi $sp,$sp,12 # adjust stack to delete 3 items\n\njr $ra # jump back to calling routine\n```\n\n해당 방식을 통해서, 만약 우리가 argument를 각 argument register 채워주고, \"jal leaf\\_example\"를 수행하게 되면, 해당 함수를 실행하는 것과 같은 동작을 하게 되는 것이다.\n\n하지만, 더 고민해야 하는 경우가 있다. 바로 함수 안에서 또 함수를 호출하는 경우이다.\n\n\u003e **Nested Function call(Function 내부에서 Function의 호출)**   \n\nprocedure가 또 procedure를 호출하는 경우에는 어떻게 해야할까? 이 때에는 간단한게 stack의 retuern address를 저장해놓고, \\$ra를 덮어씌우는 식으로 작동한다. 아래는 recursive call을 수행한 경우를 담은 내용이다.\n\n```\nint fact (int n) {\n\tif (n \u003c 1) \n\t\treturn 1;\n\telse\n\t\treturn n * fact(n-1); \n}\n```\n\n```\nfact:\naddi  $sp, $sp, –8    # adjust stack for 2 items\nsw    $ra, 4($sp)     # save the return address\nsw    $a0, 0($sp)     # save the argument n\n# slti 는 $a0의 값이 상수보다 작다면, 0 크다면 1이 저장됩니다.\nslti  $t0, $a0, 1     # test for n \u003c 1\nbeq   $t0, $zero, L1  # if n \u003e= 1, go to L1\n\naddi  $sp, $sp, 8     # pop 2 items off stack\n\naddi  $v0, $zero, 1   # return 1\njr    $ra             # return to caller\n\nL1: addi $a0,$a0,–1   # n \u003e= 1: argument gets (n – 1)\njal fact              # call fact with (n –1)\n\nlw $a0, 0($sp)        # return from jal: restore argument n \nlw $ra, 4($sp)        # restore the return address\naddi $sp, $sp, 8      # adjust stack pointer to pop 2 items\n\nmul $v0,$a0,$v0       # return n * fact (n – 1)\njr   $ra              # return to the caller\n```\n\n이제 끝일 거 같지만, 마지막으로 생각해야 할 게 있다. 바로 내부에서 또 local variable을 선언한 경우이다. 이 경우에도 memory에 공간에 저장해야 하는데 이때에도 stack pointer를 이동 시켜서 구현하는 것은 후에 동작에 혼란을 야기할 수 있다. 따라서, frame pointer라는 것을 추가로 할당하였다. 이는 함수의 진입 시점에 stack pointer의 초기 위치를 가르킨다. 따라서, 쉽게 후에 돌아올 지점을 알 수 있기에 stack pointer를 더 유동적으로 움직일 수 있다.\n\n---\n\n## **여러 변수 형태 표현법**\n\n#### **Signed Numbers**\n\n일반적으로 unsigned number라고 하면, 0과 양수를 포함하는 범위이다. 하지만, signed number는 음수까지 포함한다. 그렇다면, 컴퓨터에서는 음수를 어떻게 표현할 수 있을까?\n\n사람의 머리로 가장 쉽게 생각할 수 있는 방법은 부호를 나타내기 위한 별도의 표시 bit를 하나 넣어주면 될 거 같다는 생각을 할 것이다. 이것이 정확하다. 바로 오른쪽 끝에 있는 bit가 1이면 음수 0이면 양수로 보는 방식이다. 1이 맨 앞에 올 때는 0이 원래 1의 역할을 대신한다. 그리고 0이 앞에 올 때는 원래 계산하던대로 수행하면 된다. 그러면 놀랍게도 우리가 생각하는 것처럼 덧셈 뺄셈 연산이 동작한다. 그리고 오른쪽 끝에 있는 수를 우리는 MST 라고 하고, 이를 sign bit라고 부른다.\n\n```\n0000 0000 0000 0000 0000 0000 0000 0000(two) = 0(ten) \n0000 0000 0000 0000 0000 0000 0000 0001(two) = 1(ten)\n0000 0000 0000 0000 0000 0000 0000 0010(two) = 2(ten)\n...\n0111 1111 1111 1111 1111 1111 1111 1101(two) = 2,147,483,645(ten)\n0111 1111 1111 1111 1111 1111 1111 1110(two) = 2,147,483,646(ten)\n0111 1111 1111 1111 1111 1111 1111 1111(two) = 2,147,483,647(ten)\n1000 0000 0000 0000 0000 0000 0000 0000(two) = –2,147,483,648(ten)\n1000 0000 0000 0000 0000 0000 0000 0001(two) = –2,147,483,647(ten)\n1000 0000 0000 0000 0000 0000 0000 0010(two) = –2,147,483,646(ten)\n...\n1111 1111 1111 1111 1111 1111 1111 1101(two) = –3(ten)\n1111 1111 1111 1111 1111 1111 1111 1110(two) = –2(ten)\n1111 1111 1111 1111 1111 1111 1111 1111(two) = –1(ten) \n```\n\n\u003e **Proof  \n\u003e **\n\n```\n# 덧셈\n  1111 1111 1111 1110 (-2)\n+                   1 (+1)\n----------------------\n  1111 1111 1111 1111 (-1)\n\n\n                   11  (+3)\n+ 1111 1111 1111 1000  (-8)\n----------------------\n  1111 1111 1111 1011  (-5)\n\n\n# 뺄셈 1\n  1111 1111 1111 1110 (-2)\n-                   1 (+1)\n----------------------\n  1111 1111 1111 1101 (-3)\n\n\n# 뺄셈 2\n                   11  (+3)\n- 1111 1111 1111 1000  (-8)\n----------------------\n                   11  (+3)\n+ 0000 0000 0000 1000  (+8)\n----------------------\n  0000 0000 0000 1011  (+11)\n```\n\n연산을 하다보면, 당연히 너무 큰 양수를 더하게 되면 overflow가 발생할 수 있는데 이 경우 운영체제마다 compiler마다 처리 방식이 상이하다. C에서는 overflow가 되면 그대로 값을 내놓기 때문에, 대게 굉장히 큰 음수가 나오게 된다.\n\n#### **Character**\n\ncomputer에서 수가 아닌 값을 어떻게 표현할 수 있는가는 ASCII code 표가 답해줄 수 있을 것이다. 하나의 문자를 우리는 character라고 부르고, ASCII code 표와 같은 방식을 통해서 수를 글자로 변환하여 표현한다. 또한, 하나의 문자가 아닌 단어, 문장에 이르게 되면 이를 우리는 string이라고 하며, 이는 이 데이터의 길이를 표기하기 위해서 다음 3가지 중 하나를 선택하게 된다.\n\n1.  string의 가장 앞에 길이를 나타내는 값을 넣어준다.\n2.  string을 구조체로 만들어서 길이를 나타내는 값을 따로 넣는다.\n3.  string의 가장 끝 문자를 구분자로 채워서 구분할 수 있도록 한다. ⇒ C에서는 \\\\0 을 사용하여 구분한다.\n\n---\n\n## **Representing Instruction with Machine Language**\n\n위에 나온 MIPS Assembly code를 이제 MIPS의 기계어로 변환하는 과정을 수행할 것이다.\n\n다시 한 번 설명하자면, 우리의 program들은 사실상 instruction의 집합이라고 볼 수 있다. 또한, 현대의 컴퓨터는 이러한 instruction들을 memory에 마치 데이터처럼 쌓아서 실행시킨다. 그래서 우리는 이러한 프로그램 실행 방식을 **stored program** 이라고 부른다. 우리는 위에서 memory에 데이터를 저장하기 위해서 하나의 word 즉 32bit를 사용했다. 따라서, 우리의 instruction도 하나의 word 단위로 표현한다.\n\n아래 그림은 32bit의 각 각 부분이 무엇을 의미하는지를 표현한 것이다. 위의 연산을 표시하기 위해서 다음과 같이 word를 구분한다. 이때 주의할 점은 큰 값을 처리할 때에는 I-Type을 사용하기 때문에 형태가 기본형인 R-Type과는 다소 다른 것을 볼 수 있다.\n\n\u003e **R-Type**\n\n![\u003cimg src=\"/images/r-type.png\" width=\"190\" /\u003e](/images/r-type.png)\n\n-   op : opcode라고 불리며, instruction의 동작이 무엇인지를 정의한다. (ex. add, jump, ...)\n-   rs : first source register\n-   rt : second source register\n-   rd : destination register. 연산의 결과값이 저장되는 위치를 의미한다.\n-   shamt : shift amount라는 의미로 shift 연산을 사용할 때 이용된다.\n-   funct : op field에서 구체적인 동작을 정의할 때 사용한다.\n\n\u003e **I-Type**\n\n![\u003cimg src=\"/images/i-type.png\" width=\"190\" /\u003e](/images/i-type.png)\n\n-   op : opcode라고 불리며, instruction의 동작이 무엇인지를 정의한다. (ex. addi, jump, ...)\n-   rs : first source register\n-   rt : second source register\n-   constraint or address : 긴 값이 필요한 연산에서는 다음과 같은 형태로 표현한다.\n\n## **Addressing**\n\nMIPS는 여러가지 instruction을 가지고 있기 때문에, 주소를 targeting하는 방식도 여러가지이다. 또한, 따른 instruction set architecture에서도 다양한 방법을 통해서 memory의 주소를 가르킨다.\n\n1.  Immediate addressing : 상수를 통해 직접 address를 지정하는 방식이다.\n2.  Register addressing : register로 address를 지정하는 방식이다.\n3.  Base addressing : 상수에 특정 register값을 더해서 구하는 방식이다.(MIPS → Load Word, Save Word)\n4.  PC-relative addressing : PC 값에 상수 값을 더해서 구하는 방식이다. (MIPS → Branch)\n5.  Psedodirect addressing : PC의 맨앞 내자리를 가져와서 쓰는 방식이다. (MIPS → Jump)","slug":"architecture-instruction","title":"2. Instruction","category":"Computer Architecture","tags":["Computer Organization And Design","Instruction","ISA"],"date":"2022년 4월 14일 00:00","thumbnailSrc":"https://euidong.github.io/images/default.jpg"},{"content":"## **Reference**\n\n![\u003cimg src=\"/images/default.jpg\" width=\"190\" /\u003e](/images/default.jpg)\n\nDavid A. Patterson, John L. Hennessy, Computer Organization and Design\n\n본 Posting은 다음 교제를 기반으로 챕터 별로 정리 한 내용입니다. 아래부터는 편의를 위해 \"-다\"로 표현합니다.\n\n---\n\n해당 내용은 이전에 다루었던, [논리회로 리뷰 내용](/posts/digital-logic-circuit)을 보고 보는 것을 추천합니다.\n\n우리의 컴퓨터 시스템은 결국 Finite State Machine(유한상태장치)라고 할 수 있다. 즉, 순서에 따라 유한한 상태에서 다음 상태로 넘어가면서, Output을 계속해서 내보내는 장치라는 것이다. 이때 하나의 작업은 하나의 Clock 단위로 수행되며, 연속적은 작업 처리를 통해서 컴퓨터는 사용자가 요구한 명령을 수행하게 된다.\n\n\n## Processor\n\nprocessor와 program의 성능을 측정하기 위해서 우리는 다음과 같은 식을 활용하였다.\n\n$$\\text{instruction count} \\times \\text{Clock Cycle Time} \\times \\text{Clock Cycles per Instruction}$$\n\n[2. post](/posts/architecture-instruction)에서는 Instruction Count를 관리하고, 어떻게 계산되는지를 보았다면, **해당 포스팅에서는 Clock Cycle Time과 Clock Cycle per Instruction이 어떻게 구성되는지를 알아보며, 이들을 어떻게 줄일 수 있는지를 알아볼 것이다.**\n\n이를 위해서 우리는\n\n1. MIPS CPU의 가장 기본적인 구현\n2. pipeline된 MIPS\n3. Instruction 단계에서의 병렬화\n\n를 살펴볼 것이다.\n\n```\n 🤔 주의\n\n 해당 단계에서는 다음과 같은 사항은 배제한다.\n 1. multiply, shift, divide 연산\n 2. floating point 연산\n\n 결론적으로, 앞으로 구현할 MIPS에서는 다음과 같은 연산을 할 수 있다.\n 1. Memory에 접근하는 Load Word, Store Word\n 2. 기본 연산자 ADD, SUB, AND, OR, 등\n 3. Branch 구문 (BEQ, JUMP)\n```\n\n## 1. 기본적인 MIPS 구현(Single Cycle CPU)\n\n기본적인 processor에서 program이 동작은 다음과 같다.\n1. PC(Program Counter)를 Memory에 보내서 code를 포함한 부분을 특정하여 Instruction을 불러온다.(Instruction Fetch)\n2. 하나 또는 두 개의 register를 읽어서 Instruction을 수행한다.\n\n따라서, 이를 수행할 수 있는 논리 구조를 간략히 그려보면, 다음과 같은 형태를 가지게 됩니다.\n\n![Basic MIPS](/images/basic-mips.png)\n\n먼저, PC값의 형성 부분부터 보면 기본적으로 PC는 현재값에 4를 더하는 연산이기 때문에 상단에서 더한 값이 바로 다음 Clock에 적용된다고 할 수 있다. 그런데, 만약 Jump나 Branch 연산이 들어온다면, 해당 PC값에 특정값을 더한 결과로 이동하게 될 수 도 있다.\n\n그리고, 나머지 부분은 PC를 통해서 첫번째 박스에서 Instruction을 골라내고, Instruction의 특정 부분에서 OP와 register 등에 대한 정보를 토대로 Register와 상수 등을 이용하여 ALU 장치에서 OP 정보에 따라 연산을 수행한 뒤에 결과값을 특정 Register에 돌려주거나 Memory에 저장하도록 한다.\n\n물론 위에서는 **mux**(Multiplexor)에서 사용하는 데이터에 대한 내용은 빠져있지만, 아래 그림을 보면 더 정확하게 이해할 수 있을 것이다. 여러가지 경우의 수 중 상황의 따라서 output이 다른 경우에 mux를 사용하게 되는데, 여기서는 Instruction의 특정부분을 통해서 Control bits를 얻어내고, mux를 설치하여 적절하게 행동하도록 제어하고 있다. \n\n대표적인 예시로 아까 PC값을 선택하는 부분이 보다 명확하게 표시되는 것을 볼 수 있다. 현재 계산된 PC+4를 사용할 것인지 아니면, Branch 명령어에서 계산된 값을 사용할 것인지를 Control bit가 결정하는 것을 볼 수 있다.\n\n![Basic MIPS 2](/images/basic-mips2.png)\n\n이제부터는 각 단계별로 뜯어서 살펴본다.\n\n### 1) IF 단계 - Instruction Fetch\n\n해당 단계에서는 PC에 저장된 값에 따라서, Memory에서 Instruction을 추출하면서 PC에 4가 더해지는 것을 볼 수 있다. 그리고, Instruction의 특정 부분과 연산이 수행되는 것을 볼 수 있는데 이는 Branch 구문에 의한 이동을 위해서 주소를 저장해놓는 것이다.\n\n그리고, 이를 mux와 signal bit를 통해서, 최종적으로 다음 Program의 line을 가르킬 수 있다.\n\n![MIPS IF](/images/mips-if.png)\n\n### 2) ID 단계 - Instruction Decode and Register File Read\n\n해당 단계에서는 크게 두가지의 일을 한다.\n\n첫 번째는, Instruction에 포함된 정보를 기반으로 하여 Register를 선택하고, 해당 Register에 해당하는 정보를 내보내는 것이며,\n\n![MIPS ID](/images/mips-id1.png)\n\n두 번째는, Control bits를 생성하는 역할이다.\n\n![MIPS ID](/images/mips-id2.png)\n\n### 3) EX 단계 - Execution or Address Calculating\n\n다음 단계에서는 `R-Type`, `I-Type`에 따라서 두번째(2nd) Register를 사용할지 아니면, 상수로 받아들일지를 선택해야 한다. 이는 이전 단계(ID)에서 생성했던 Control bit를 mux에 통과시키는 식으로 구현한다. \n\n이후에는 control bit들을 통해서 연산의 종류를 선택한 후에, ALU 내부에서 연산을 수행하여 결과값을 내보낸다.\n\n결과값은 일반적인 결과를 내보내며, 추가적으로 beq 또는 여타 연산의 결과를 쉽게 알리기 위해서 zero라는 output으로 결과값이 0인지를 알려준다. 이는 다른 beq와 같은 연산에서 control bit로 사용한다.\n\n![MIPS EX](/images/mips-ex.png)\n\n### 4) MEM 단계 - Data Memory Access\n\nData Memory에 접근하는 동작으로 만약 Memory에 데이터를 update하는 동작을 한다면, MemWrite가 1로 설정되어있고, 이를 보고 명령어를 처리하게 된다.(read도 동일하게 MemRead를 활용한다.) 물리적으로 CPU와 떨어져있는 장비이기 때문에 접근하는데 많은 시간이 소요된다. 따라서, MIPS의 Instruction 실행의 모든 단계들 중에서 가장 오랜 시간이 필요한 연산이라고 할 수 있다.\n\n![MIPS MEM](/images/mips-mem.png)\n\n\n### 5) WB 단계 - Write Back\n\n실제로 Register의 값을 update해주는 부분으로 register의 update는 Data Memory에서 값을 불러오거나 연산 결과를 받을 때 사용하기 때문에 둘 중에 어떤 경우인지를 확인하여 데이터를 update한다.\n\n![MIPS WB](/images/mips-wb.png)\n\n위와 같이 하나의 Instruction을 수행하기 위한 일련의 작업이 한 Clock을 단위로 실행되는 경우를 Single Cycle CPU라고 한다.\n\n### 2. Pipelining\n\n가장 기본적인 구조를 살펴보았으니 위의 형태를 최적화하기 위한 가장 효과적이였고, 모든 CPU에서 사용되고 있는 설계 방법을 설명할 것이다. 위의 과정을 보고 있으면 우리는 비효율을 하나 발견하게 된다. **바로 특정 단계가 실행 중인 동안에 해당 단계에 포함되지 않은 장비들은 놀려지고 있다는 점이다.** 즉, 위에서 processor의 성능을 측정하는 지표인 Clock Cycle Time이 증가한다. 따라서, 모든 장비를 계속해서 실행시키기 위해서, 한 단계가 한 Clock이 되도록 하는 방법이 고안되었다.(Multi Cycle CPU) \n\n하나의 예를 살펴보자.\n\n세차장에 갔다고 하자. 우리는 당연히 일열로 서서 자신의 차례가 되기를 기다린다. 하나의 장비가 세차에 들어가기 전에 사람에 의해서 먼저 비누거품을 내는 단계가 있다면, 우리는 당연히 줄을 서있는 동안 세차장 아르바이트생이 비누칠을 해주기를 기다릴 것이다. 하지만, 해당 세차장에서는 만약 기다리는 동안 해주는 것이 아니라 세차 기계가 이전 차량에 대한 작업을 마치고 안정적으로 작업이 끝난 후에 비누칠을 해준다고 하자. 이것은 굉장한 짜증을 유발하는 요소가 될 것이다.\n\n따라서, Single Cycle CPU를 사용하는 것은 하드웨어 장비를 최적화하지 못한 사례라고 할 수 있다.\n\n위와 같이 단게를 나누어 여러 Cycle에 나누어 하나의 명령어를 처리하게 되면, 우리는 다음과 같은 효과를 얻게 된다.\n\n1. Clock Cycle Time이 줄어든다.\n2. 하나의 CPU가 동시에 여러 개의 명령어를 실행하게 할 수도 있다.(**Instruction Overlapping**)\n\n![Pipeline Example](/images/pipeline-example.png)\n\n이렇게 Instruction을 동시에(병렬적으로) 실행할 수 있다면, 1개의 Cycle 동안 Hardware 장치의 잉여 시간을 최소화할 수 있다.\n\n\n하지만, tradeoff 역시 존재한다.\n1. 각 단계의 연산이 끝난 후에 해당 값을 보관할 추가적인 하드웨어 장비(register)가 필요하다.\n2. Clock이 올라가고, 떨어지는 동안의 미세한 시간의 추가로 시간 비용이 증가한다.\n3. Clock Cycle Time은 반드시 하나의 상수로 정해져야 하기 때문에 가장 실행 시간이 긴 단계에 의존하게 된다. 즉, 실행시간이 더 짧은 단계라고 할지라도 다른 긴 단계가 있다면 기다려야 한다.\n4. 2와 3번을 이유로 결론상 하나의 Instruction을 수행하는데 걸리는 시간은 증가할 수 밖에 없다.    \n   그렇기에 결론상 단계를 생각없이 무조건 잘게 자른다고 좋은 것이 아니다. 바로 균등하게 많이 나눌 수 있는 만큼 나누는 것이 좋은 것이다.\n5. Instruction을 동시에 실행하는 것으로 인한 문제가 발생할 수 있다(Hazard). 이는 바로 다음 부분에서 다룬다.\n\n### Hazard\n\nHarzard는 아래와 같이 총 3가지의 종류가 있다.\n\n\u003e **1. Structural Hazard**   \n\nHardware가 구조적으로 동시에 특정 Instruction 조합을 처리하지 못할 경우를 의미한다. 즉, 서로 다른 pipeline stage에서 동일한 resource(Hardware)에 접근하고자 할 때 발생할 수 있다. 만약 Instruction Memory와 Data Memory의 분리가 되어 있지 않은 경우에는 이러한 문제가 IF, MEM 단계에서 발생할 수도 있지만, MIPS에서는 발생하지 않는다.\n\n\u003e **2. Data Hazard**   \n\n바로 Instruction이 서로 연관(의존)되어있을 때의 문제이다.\n\n다음과 같은 상황을 가정해보자. 우리가 memory에서 데이터를 불러와서 3을 더하는 연산을 한다고 하자. 그렇다면 명령어는 다음과 같다.\n```\nlw $v 0\naddi $v 3\n```\n이를 실행하면 불행하게도 load가 채 끝나기도 전에 채워지지 않은 \\$v에 3이 더해지는 것을 알 수 있다.\n\n이를 해결하기 위해서 3가지의 선택지가 있다.\n1. 의존성이 있는 명령어가 실행 중인 경우 끝날 때까지 대기 (**Stall**)    \n   가장 간단한 방법이지만, pipelining을 통한 성능 향상을 감소시킬 수 있다.\n2. Compiler 단에서 의존이 발생하는 Instruction 사이에 순서가 상관없는 Instruction을 끼워넣어서 resource가 낭비되지 않으면서 hazard가 발생하지 않도록 한다. (**Reordering**)   \n   Hazard를 해결하는 좋은 방법이지만, 항상 이것이 가능할 수는 없다.\n3. 추가적인 Hardware를 사용하여 결과값을 필요로 하는 resource에게는 단계를 생략하고 넘긴다. (**Forwarding**, **Bypassing**)    \n   현재까지는 가장 괜찮다고 받아들여지는 방법이다. 예를 들어서, EX 단계에서 ALU 연산이 끝나자마자 Write Back을 자체적으로 수행해주면 총 3번의 stall을 1번으로 줄일 수 있다.\n   \n\n\u003e **3. Control Hazard**   \n\nBranch Hazard라고도 불리며, 이전 Instruction의 결과에 따라서 실행시킬 Instruction이 변화할 때, 어느 Instruction을 실행시킬지 알 수 없기 때문에 발생하는 Hazard이다. (JUMP, BEQ)\n\n이 경우에도 총 3가지의 선택지를 가진다.\n1. 성공적으로 분기문이 실행될 때까지 대기한다.(**Stall**)\n2. 어느 곳으로 Branch가 될지를 예상하여, 미리 시행해둔다. (**Branch Prediction**)   \n   Resource를 최적화한다. 별도의 hardware를 설치하여 미리 JUMP 및 Branch address를 계산해 놓는다(**Hardware Optimization**)는 가정이 필요하다. 또한, 예측이 얼마나 적중하는가 역시 굉장히 중요한 요소로 작용한다.\n   대게 이러한 예측은 두 가지의 종류가 있다.\n   1. 정적 예측   \n      쉽게 생각할 수 있는 것은 반드시 실패한다고 생각하거나 성공한다고 생각해서 진행하는 방식이다. 좀 더 복잡한 방식은 loop문에 의한 branch인 경우 branch가 수행될 확률이 높다는 것을 기반으로 하여 성공 가능성이 크다고 예측할 수 있다.\n   2. 동적 예측   \n      이전 예측들을 기반으로 하여 현재 예측을 수행하는 방식이다. 이를 사용하면, 여러 번 반복되는 행위에 대한 예측율이 상당히 높아진다. 대게, 우리가 하는 분기문이 loop 등에 의한 경우가 많으므로 좋다고 할 수 있다. 또한, 최근에는 machine learning을 활용하여 예측을 수행하는 방식 또한 나오고 있다.\n3. Branch 여부에 상관없는 요청을 Control Hazard에 의해서 발생하는 구간에 넣는다. (**Delayed Decision**)\n\n\n## Parallelism via Instruction\n\nPipelining을 통해서, Instruction을 동시에 여러 개 실행시킬 수 있는 환경이 구축되었다. 그 와중에 resourece 자체를 하나 이상 두어서 Instruction을 동시에 수행할 수 있도록 하는 방식이 고안되었는데, 이를 Multiple Issue processor라고 한다.\n\n이를 대표하는 방식은 크게 두가지로 나눌 수 있다.\n\n### 1. Static Multiple Issue\n\n이는 compiler가 program을 기계어로 번역하는 과정에서 이루어지며, 대표적으로 다음과 같은 것들이 있다.\n\n1. VLIW(Very Long Instruction Word)    \n   의존성이 없는 여러 Instruction을 하나의 Instruction으로 뭉쳐서 실행시키는 방법이다. 이를 통해서 중첩되는 OPCODE 및 기타 처리 등을 최소화할 수 있다. Processor가 해당 기능을 지원하는 경우에만 사용가능하다.\n2. Loop Unrolling   \n   loop를 풀어서 여러 개의 Instruction으로 만들어서 branch로 인한 비용을 줄일 수 있다.\n\n### 2. Dynamic Multiple Issue\n\nprocessor에서 직접 Instruction이 실행되는 동안 이루어진다. 이는 여러 개의 pipeline을 CPU에 두어 이를 SuperScalar 방식이라고도 한다. 이를 효율적으로 수행하기 위해서는 앞 서 보았던 Compiler 단에서의 조율도 필요하며, 실행 중에 Instruction을 어떻게 나눌 것인가에 대한 Dynamic Scheduling 역시 매우 중요하다. 대표적인 예시가 OoO(Out of Order) Execution을 이용하는 것이다. Instruction의 Fetch를 순서대로가 아닌 의존성에 알맞게 실행되도록 조절하는 방식이다.","slug":"architecture-processor","title":"4. Processing","category":"Computer Architecture","tags":["Computer Organization And Design","Processing","MIPS Implementation","Pipeline","Branch Prediction","SuperScalar"],"date":"2022년 4월 28일 19:25","thumbnailSrc":"https://euidong.github.io/images/default.jpg"}]},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"architecture-arithmetic"},"buildId":"bkZxmn80PN7rXSZz1oSH_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>