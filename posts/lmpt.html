<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta property="og:type" content="blog"/><meta property="og:site_name" content="JustLog"/><meta property="og:image" content="https://euidong.github.io/logo192.png"/><title>LMPT</title><meta property="og:title" content="LMPT"/><meta name="description" content="Ethereum의 TPS를 Client 단에서 향상 시키기 위한 노력으로, LMPT는 Layered Merkle Partical Trie의 약자이다. 이는 기존 Ethereum에서 사용하던 MPT의 성능 향상을 위하여 제기된 아이디어로 Computer Architecture에서 흔하게 사용되는 cache를 접목한 방법이다. (해당 논문 ICBC 2022의 논문 중 LMPT를 기반으로 한 요약글이다.)"/><meta property="og:description" content="Ethereum의 TPS를 Client 단에서 향상 시키기 위한 노력으로, LMPT는 Layered Merkle Partical Trie의 약자이다. 이는 기존 Ethereum에서 사용하던 MPT의 성능 향상을 위하여 제기된 아이디어로 Computer Architecture에서 흔하게 사용되는 cache를 접목한 방법이다. (해당 논문 ICBC 2022의 논문 중 LMPT를 기반으로 한 요약글이다.)"/><meta property="og:url" content="https://euidong.github.io/posts/lmpt"/><link rel="canonical" href="https://euidong.github.io/posts/lmpt"/><meta property="og:image" content="https://euidong.github.io/images/blockchain-thumbnail.jpg"/><meta name="next-head-count" content="12"/><link rel="icon" href="https://euidong.github.io/favicon.png"/><link rel="apple-touch-icon" href="https://euidong.github.io/logo192.png"/><link rel="preload" href="/_next/static/css/d4ec5c8b3df09443.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d4ec5c8b3df09443.css" data-n-g=""/><link rel="preload" href="/_next/static/css/084d6f830813377d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/084d6f830813377d.css" data-n-p=""/><link rel="preload" href="/_next/static/css/ce8fdf87155cc385.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ce8fdf87155cc385.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" id="Adsense-id" data-ad-client="ca-pub-7452732177557701" async="" defer="" data-nscript="beforeInteractive"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-81da43a8dcd978d9.js" defer=""></script><script src="/_next/static/chunks/main-7b6c38cbad60dfcf.js" defer=""></script><script src="/_next/static/chunks/pages/_app-8d9b43c3d8042477.js" defer=""></script><script src="/_next/static/chunks/78e521c3-e8d9bb51e7f4d69e.js" defer=""></script><script src="/_next/static/chunks/175675d1-1a2aae3f63998821.js" defer=""></script><script src="/_next/static/chunks/675-ae8e8a351ce30ae2.js" defer=""></script><script src="/_next/static/chunks/874-9e5d386a2b11b20f.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-3b07d85cb171445a.js" defer=""></script><script src="/_next/static/6SENXQ_RcGFHETqFmw7p-/_buildManifest.js" defer=""></script><script src="/_next/static/6SENXQ_RcGFHETqFmw7p-/_ssgManifest.js" defer=""></script><script src="/_next/static/6SENXQ_RcGFHETqFmw7p-/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="Layout_wrapper__dKJSz root"><header class="Layout_header__XosLl" style="position:static"><div><button tabindex="1" class="SideBarToggler_search_bar_toggler__CEuUg"><svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 24 24" height="35px" width="35px" xmlns="http://www.w3.org/2000/svg"><path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z" fill="currentColor"></path><path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z" fill="currentColor"></path><path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z" fill="currentColor"></path></svg></button><nav class="SideBar_side_bar__wrapper--close__8Nwnr"><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/">Home</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/tags">Tags</a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Algorithm">Algorithm<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->11<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Computer%20Architecture">Computer Architecture<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->7<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Tech">Tech<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->17<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Web">Web<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->4<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Paper">Paper<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->2<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Network">Network<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->11<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/AI">AI<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->20<!-- -->)<!-- --></span></a><a class="SideBar_side_bar__li__crDBH" tabindex="-1" href="/categories/Memoir">Memoir<!-- --><span class="SideBar_side_bar__li__cnt__9QV_z">(<!-- -->1<!-- -->)<!-- --></span></a></nav></div><a class="Logo_logo___yD0t" tabindex="1" href="/"></a><div><button class="SearchBarToggler_search_bar_toggler__3dHbA" tabindex="2"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="25px" width="25px" xmlns="http://www.w3.org/2000/svg"><path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"></path></svg></button></div></header><section><ins class="adsbygoogle" style="display:block;text-align:center;margin:50px 0" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7452732177557701" data-ad-slot="1964032750"></ins><div class="Post_post__wrapper__Qq8vV"><h1 class="Post_post__title__CYNLY">LMPT</h1><p class="Post_post__date__Sx37s">2022년 10월 28일 17시 17분</p><ul class="Post_post__tags__SU5Ql"><li class="Post_post__tags__element__SYmey"># Blockchain</li><li class="Post_post__tags__element__SYmey"># Ehtereum</li><li class="Post_post__tags__element__SYmey"># MPT</li></ul><article class="markdown-body MarkDown_markdown-body__ABwUt"><h2 id="Intro">Intro<!-- --></h2>
<!-- --><p>Ethereum의 TPS를 Client 단에서 향상 시키기 위한 노력으로, LMPT는 Layered Merkle Partical Trie의 약자이다. 이는 기존 Ethereum에서 사용하던 MPT의 성능 향상을 위하여 제기된 아이디어로 Computer Architecture에서 흔하게 사용되는 cache를 접목한 방법이다. (해당 논문 ICBC 2022의 논문 중 LMPT를 기반으로 한 요약글이다.)<!-- --></p>
<!-- --><h2 id="Terms">Terms<!-- --></h2>
<!-- --><ul>
<!-- --><li><strong>ERC-20<!-- --></strong><br/>
Ethereum과 호환이 가능한 token에 대한 표준을 제시한 문서이다. 즉, 이 표준을 만족하는 token은 Ethereum을 통해서 교환이 가능하며 그 반대도 가능하다.<!-- --></li>
<!-- --><li><strong>Tether token<!-- --></strong><br/>
Tether token은 ERC-20에 기반한 대표적인 token으로, 미국 달러와 1:1로 대응하는 USDT로 유명하다. 실제 거래에서도 빈번히 사용되는 ERC-20 token이다.<!-- --></li>
<!-- --><li><strong>Trie<!-- --></strong><br/>
Trie는 sequence로 이루어진 데이터의 빠른 검색을 위해서 만들어진 tree의 일종이다. 데이터를 저장할 때 sequence 데이터의 검색을 최적화하는 것을 목표로 한다. 원리는 다음과 같다. sequence의 검색 시에 sequence의 앞에서부터 맞는 node를 root에서부터 검색하며 찾아나간다. 이 덕분에 검색 시에는 sequence의 길이만큼의 시간이면 충분히 데이터를 찾는 것이 가능하다. 하지만, 저장 sequence를 풀어서 저장하는 방식이기 때문에 경우의 수가 엄청 많아진다. 이는 sequence를 하나의 데이터로 보는 것보다 저장 공간을 많이 차지한다는 단점도 있다.<!-- --></li>
<!-- --><li><strong>Patricia Trie<!-- --></strong><br/>
Trie에서는 기본적으로 모든 sequence를 요소 하나를 node로 보았다면, Patricia Trie에서는 각 nnode가 두 개로 나뉘어진다. branch node, leaf node이다. leaf node는 각 sequence의 끝을 의미하며 각 sequence는 반드시 하나의 leaf node로 종결되어지고, branch node는 저장한 데이터 중에서 중복이 발생하는 경우 중간 지점으로 저장해두는 방식이다. 따라서, Trie에서는 각 노드가 sequence의 하나의 값을 의미했다면, Patricia Trie에서는 path가 sequence의 요소들을 의미한다. 이에 대한 이해를 위해서는 아래에 제시된 그림을 보는 것이 좋을 것이다.(좌. trie, 우. patricia trie)<!-- --><br/>
<!-- --><img src="/images/patricia-trie.png" alt="patricia-trie"/></li>
<!-- --><li><strong>Merkle Tree<!-- --></strong><br/>
Bitcoin에서 사용된 자료구조로 Blockchain의 모든 Block을 저장하는 것은 특정 node에게는 부담이 될 수 있기 때문에 이에 대한 인증을 쉽게 하기 위해서 요약본만을 저장하는 방식이다. 자세한 내용은 <!-- --><a href="/posts/bitcoin-4">🔗 bitcoin-4<!-- --></a>의 2. Merkle Tree 부분에서 자세히 다루었다. 간단히 설명하자면, Block을 serialization하고 hash하여 결과값을 저장한 후 이를 leaf node로 하는 형태의 binary tree를 만드는 것이다. 그렇기에 우리는 Merkle Tree의 hash값 몇개만 갖고도 해당 transaction을 포함하는 block이 유효한지를 파악할 수 있다.<!-- --></li>
<!-- --><li><strong>MPT<!-- --></strong><br/>
Merkle Patricia Trie의 줄임말로 기존 Bitcoin에서 사용하던 Merkle Tree와 Patricia Trie의 결합을 통해 만들어낸 자료구조이다. 이에 대한 설명은 아래에서 더 자세히 다룬다.<!-- --></li>
<!-- --><li><strong>Latency bound issue<!-- --></strong><br/>
Memory에서 너무 많은 데이터를 얻어오려고 할 때를 의미하는 Memory Bound 중의 하나로 data를 Memory 만으로는 가져올 수 없을 때, secondary storage에서 불러오는데 발생하는 latency를 의미한다.<!-- --></li>
<!-- --></ul>
<!-- --><h2 id="Problem">Problem<!-- --></h2>
<!-- --><p>Bitcoin에서 시작된 Blockchain에 대한 응용은 의료, 공급망 관리 등으로 확장되며 계속해서 발전되고 있다. 그럼에도 불구하고 아직까지 <!-- --><strong>transaction의 빠른 처리<!-- --></strong>는 challenge한 부분으로 남아있다. 이는 P2P 환경에서 안전한 transaction의 생성 및 조회 그리고 검증을 위해서 어쩔 수 없는 trade off로 받아들여졌다. 그 결과 7~30 tps(transaction per second)정도에 그치는 성능을 보여주고 있다. 주류인 중앙 처리 방식은 수 천개의 transaction을 처리하는 것과 비교했을 때에는 굉장히 낮은 수준이다.<!-- --></p>
<!-- --><p>이를 해결하기 위해서 다년간 여러가지 접근 방식과 해결책이 제시되었다(AI-gorand, Conflux, Prism, OHIE, etc). 이를 통해서 수 천개의 transaction을 blockchain에서 처리하는 것이 가능하게 되었다. 하지만, 실제로 응용하는데에는 한계가 있었다. 그것은 state를 보관하는 ledger 단에서 발생하는 것이 아닌 실제로 transaction을 처리하는 client 단에서의 문제이다. 이는 바로 <!-- --><strong>blockchain state를 변경하는 transaction이 빈번하게 발생하는 경우 client 단에서 새로운 bottleneck이 발생한다는 점이다.<!-- --></strong> 실제로 가장 유명한 Ethereum Client인 GoEthereum과 OpenEtereum에서는 700 tps로 기존 제시된 수 천 transaction보다는 한참 못 미치는 성능을 보여준다.<!-- --></p>
<!-- --><p>그 원인은 사실상 state machine이라고 할 수 있는 Ethereum과 이것의 검증을 위해 제안된 MPT의 구조적인 한계로 인해 발생한다(이는 Background에서 제대로 다룰 것이다). 이 구조적인 한계에 의해서 다음과 같은 현상들이 발생한다.<!-- --></p>
<!-- --><ol>
<!-- --><li>key-value 짝으로 이루어지는 데이터의 read/write 연산이 증폭해서 발생한다.<!-- --></li>
<!-- --><li>특히 write operation은 모든 node에 대한 hash를 재계산하도록 한다.<!-- --></li>
<!-- --><li>이러한 동작이 완료되기 전까지 반드시 transaction을 처리하는 thread는 대기해야 한다.<!-- --></li>
<!-- --></ol>
<!-- --><p>이를 해결하기 위해서, 해당 논문은 LMPT라는 새로운 자료구조를 제시한다. 이는 기존 Ethereum의 MPT를 기반으로 하는 시스템보다 6배 정도 상승된 tps 성능 지표를 보여주고 있다. 이것의 핵심 아이디어는 MPT를 계층화(layer)하는 것이다. 즉, 최근 update된 내용을 별도의 저장공간을 활용하여 저장해두고 이를 우선적으로 활용하기 때문에 더 빠른 처리 성능을 보여주는 것이다.<!-- --></p>
<!-- --><h2 id="Background">Background<!-- --></h2>
<!-- --><blockquote>
<!-- --><p><mark><strong>1. Ethereum<!-- --></strong></mark></p>
<!-- --></blockquote>
<!-- --><p>Ethereum은 기존 Bitcoin Blockchain System과 확연히 다른점이 있다. 바로 State Machine이라는 점이다. 기존의 Bitcoin에서는 거래 내역을 모두 공개하고, 이를 통해서 우리는 최초 Block에서부터 이 거래 내역을 읽어들이면서 가진 자산을 확인할 수 있다. 즉, 거래 history를 종합해서 결과값을 얻는 것이다. Transaction의 수정과 삭제 없이 계속해서 추가만 이루어지는 형태라고 볼 수 있다. 하지만, Ethereum에서는 Transaction을 State Machine의 상태를 변화시키는 하나의 action으로 받아들인다. 따라서, Transaction에 의해서 우리는 상태가 변화하도록 하는 방식인 것이다. 따라서, 우리는 해당 State만 보고 자신의 자산을 파악할 수 있는 것이다.<!-- --></p>
<!-- --><blockquote>
<!-- --><p><mark><strong>2. MPT<!-- --></strong></mark></p>
<!-- --></blockquote>
<!-- --><p>결국 Ethereum 시스템을 활용하기 위해서는 모든 것이 공개되는 Network 상에서 안전하게 State와 이를 변경하는 Transaction을 보관하는 것이 중요하다. 이러한 data를 무결하게 그러면서도 수정, 삭제, 검색 등이 용이할 수 있도록 하기 위해서 Ethereum에서는 MPT(Merkle Patricia Trie)를 활용한다. 이는 결국 위에서 설명한 Merkle Tree와 마찬가지로 하위 Node의 Hash값을 상위 Node에서 가지기 때문에 Root Hash만을 비교하여 검증을 할 수 있다는 점에서 강점을 가지고 있다.<!-- --></p>
<!-- --><p>MPT는 3가지의 Node로 이루어진다.<!-- --></p>
<!-- --><ol>
<!-- --><li><strong>Leaf Node<!-- --></strong><br/>
실제로 value를 저장하는 말단 node이다. 만약, path로 key가 모두 표시되지 않았다면, key-end에 남은 key를 모두 담는다.<!-- --></li>
<!-- --><li><strong>Extension Node<!-- --></strong><br/>
Leaf Node 이외에 경로의 확장이 필요할 때 사용되어지는 Node로 Branch Node의 hash data를 하나로 합치는 등의 역할을 한다.<!-- --></li>
<!-- --><li><strong>Branch Node<!-- --></strong><br/>
16개의 pointer를 포함하는 Node로 이를 통해서 Leaf, Extension, Branch Node를 가르키는 데 사용할 수 있다.<!-- --></li>
<!-- --></ol>
<!-- --><p>따라서, 일반적인 구조는 아래와 같다.<!-- --></p>
<!-- --><p><img src="/images/mpt.png" alt="mpt"/></p>
<!-- --><p>이 구조가 가지는 의의는 결국 우리는 하위 node들을 hash한 데이터를 상위 node에서 포함하고 있기 때문에 필요에 따라 trie에 일부분만을 저장해도 data의 검증은 충분히 가능하다는 점이다. 따라서, 모든 data를 가지는 full node와 달리 light client는 더 적은 데이터만 갖고도 검증이 가능한 것이다. 하지만, light client에서 authenticated read(full node의 도움이 필요한 read)를 수행하고자 하는 경우 full node에서는 read를 수행하기 위해서 path를 따라서 읽기를 반복해나가며, leaf node에 있는 최종 value를 얻어와야 한다.<!-- --></p>
<!-- --><blockquote>
<!-- --><p><mark><strong>3. Further Observation<!-- --></strong></mark></p>
<!-- --></blockquote>
<!-- --><p>해당 논문에서는 OpenEthereum Client를 관측하고, 기존 논문들에서 여러 영감을 얻었다. 다음은 이 논문에서 insight를 얻는 데 중요한 역할을 한 관측 정보이다.<!-- --></p>
<!-- --><ol>
<!-- --><li>
<!-- --><p>Transaction이 Blockchain State에 빈번하게 접근할 수록 Transaction의 처리 성능은 낮아진다.<!-- --></p>
<!-- --></li>
<!-- --><li>
<!-- --><p>실제 Transaction의 실행 시간 중에서 가장 많은 시간을 차지하는 것은 Blockchain State에 접근하는 동작(SLOAD, SSTORE)이다.<!-- --><br/>
<!-- --><a href="https://aoli.al/papers/solythesis-pldi20.pdf">🔗 기반 논문(Securing Smart Contract with Runtime Validation)<!-- --></a></p>
<!-- --></li>
<!-- --><li>
<!-- --><p>한 번의 Transaction은 여러 번의 IO을 유발한다.(IO amplication)<!-- --><br/>
MPT 구조에서 하나의 key 조회를 위해서 한 번에 데이터를 찾을 수 없기 때문에 결국 key를 통해서 Trie를 순회하여야 한다.<!-- --><br/>
이는 key에 대응되는 Node가 많을 수록 많은 IO를 요구한다.<!-- --></p>
<!-- --></li>
<!-- --><li>
<!-- --><p>Transaction 실행 thread는 병렬적으로 실행되지 않고, 위에서 제시된 operation이 끝날 때까지 대기한다.<!-- --><br/>
즉, Transaction을 처리하는 Thread는 critical path(section)를 지키기 위해서 단 하나만 존재한다는 것이다.<!-- --></p>
<!-- --></li>
<!-- --><li>
<!-- --><p>memory cache size를 늘리는 것은 성능향상에 큰 도움이 되지 않는다.<!-- --></p>






























<!-- --><table><thead><tr><th style="text-align:left">Memory Cache size(MB)<!-- --></th><th style="text-align:left">Hit Rate<!-- --></th><th style="text-align:left">TPS<!-- --></th></tr></thead><tbody><tr><td style="text-align:left">50<!-- --></td><td style="text-align:left">0.635<!-- --></td><td style="text-align:left">1238<!-- --></td></tr><tr><td style="text-align:left">100<!-- --></td><td style="text-align:left">0.758<!-- --></td><td style="text-align:left">1256<!-- --></td></tr><tr><td style="text-align:left">500<!-- --></td><td style="text-align:left">0.862<!-- --></td><td style="text-align:left">1278<!-- --></td></tr><tr><td style="text-align:left">1000<!-- --></td><td style="text-align:left">0.879<!-- --></td><td style="text-align:left">1292<!-- --></td></tr></tbody></table>
<!-- --><p>위의 표를 보면 알 수 있지만, Cache Size를 늘렸을 때 Hit Rate는 늘릴 수 있지만 TPS의 성능 향상 폭은 5% 수준에 그친다. 이는 memory cache를 제대로 사용하지 못하고 있음을 의미한다.<!-- --></p>
<!-- --></li>
<!-- --></ol>
<!-- --><p>즉, 해당 논문에서는 하나의 Transaction에 의해서 IO가 빈번히 발생하는데 이를 병렬적으로 처리하는 것도 기존 MPT만으로는 한계가 있기 때문에 이를 해결할 수 있는 방법을 제시한다.<!-- --></p>
<!-- --><h2 id="LMPT">LMPT<!-- --></h2>
<!-- --><p>Layered Merkle Patricia Trie의 약자로 기존 Ethereum MPT의 한계를 극복하기 위해서 제안하는 자료구조이다. 이의 핵심적인 목표는 Authenticated Ethereum State를 더 효과적으로 저장하는 것이다. 여기서 사용하는 핵심 아이디어는 바로 기존 Computer Architecture에서 사용했던 Hierarchical Memory의 구조를 그대로 차용하는 것이다. 즉, cache로 사용할 수 있는 MPT를 더 구현해두는 것이다. 이는 결론상으로 MPT의 read시에 IO amplication을 효과적으로 줄일 수 있다.<!-- --></p>
<!-- --><p>우선 구성 요소는 다음과 같다.<!-- --></p>
<!-- --><ol>
<!-- --><li><strong>Delta MPT<!-- --></strong><br/>
Read access가 요청되면 가장 먼저 조회되는 MPT이다.<!-- --></li>
<!-- --><li><strong>Intermediate MPT<!-- --></strong><br/>
Delta MPT 이후에 조회되는 MPT이다.<!-- --></li>
<!-- --><li><strong>Snapshot MPT<!-- --></strong><br/>
원본이라고 할 수 있는 MPT이다. 전체 blockchain data를 저장하며, disk에 존재한다.<!-- --></li>
<!-- --><li><strong>Flat KV Store<!-- --></strong><br/>
read시에 가장 마지막에 조회된다. 이 역시도 전체 blockchain data를 저장하지만, 차이점이라면 key를 path로 하여 조회하는 MPT와 다르게 key, value store형태이다.<!-- --><br/>
그렇기에 snapshot MPT와 동일하게 disk에 존재하지만, 더 빠르다게 조회가 가능하다는 장점이 있다.<!-- --><br/>
snapshot MPT를 조회하는 대신에 이를 통해서 조회를 한다면, key를 통해서 바로 조회할 수 있는 방식이기 때문에 read IO amplication을 효과적으로 줄일 수 있다.<!-- --></li>
<!-- --></ol>
<!-- --><p>위의 까지는 read시에 최적화를 수행하였다면, write 시에는 이렇게 계층화를 해두었기 때문에 disk에 write하는 동안의 여유가 생길 수 있다. LMPT에서는 MPT의 적은 변화일 경우에는 delta MPT에 저장하고 있다가 periodic checkpoint를 두고, 해당 시점마다 delta MPT의 변경사항은 intermediate MPT, intermediate MPT의 변경 내용은 snapshot MPT에 합친다. 따라서, write 동작은 시간차를 두고 <!-- --><strong>batch 단위<!-- --></strong>로 <!-- --><strong>verification과는 독립적<!-- --></strong>으로 진행된다. 이는 결국 병렬적으로 IO 작업을 처리할 수 있는 여지를 만들어준다.<!-- --></p>
<!-- --><blockquote>
<!-- --><p><mark><strong>[Design] Structure<!-- --></strong></mark></p>
<!-- --></blockquote>
<!-- --><p>어떻게 실제로 이를 구현했는지에 대한 outline을 제시하면 다음과 같다. (OpenEthereum은 Rust를 이용하기 때문에 LMPT도 Rust에 기반한 code이다. psuedo code이기 때문에 해당 언어를 몰라도 알아볼 수 있을 것이다.)<!-- --></p>
<!-- --><pre><div class="MarkDown_codeblock__wrapper__S4FFz"><div class="MarkDown_codeblock__header__h3PfO"><span class="MarkDown_codeblock__header__circle__B4MWO"></span><span class="MarkDown_codeblock__header__circle__B4MWO"></span><span class="MarkDown_codeblock__header__circle__B4MWO"></span><span class="MarkDown_codeblock__header__button__aBRNB"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="25px" width="25px" xmlns="http://www.w3.org/2000/svg"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z"></path></svg></span></div><div style="color:#f8f8f2;background:#282a36;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-rust" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">1<!-- --></span><span class="token" style="color:#8be9fd">struct<!-- --></span><span> <!-- --></span><span class="token type-definition" style="color:#f1fa8c">Trie<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">{<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">2<!-- --></span><span>  root<!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span> uint256<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">3<!-- --></span><span>  kv<!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span>   <!-- --></span><span class="token" style="color:#f1fa8c">Map<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">4<!-- --></span><span></span><span class="token" style="color:#f8f8f2">}<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">5<!-- --></span><span></span><span class="token" style="color:#8be9fd">struct<!-- --></span><span> <!-- --></span><span class="token type-definition" style="color:#f1fa8c">LMPT<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">{<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">6<!-- --></span><span>  delta<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> interm<!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span>  <!-- --></span><span class="token" style="color:#f1fa8c">Trie<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> <!-- --></span><span class="token" style="color:#6272a4">// In memory<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">7<!-- --></span><span>  snapshot<!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span>       <!-- --></span><span class="token" style="color:#f1fa8c">Trie<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> <!-- --></span><span class="token" style="color:#6272a4">// In Disk<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">8<!-- --></span><span>  flat<!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span>           <!-- --></span><span class="token" style="color:#f1fa8c">Map<!-- --></span><span>   <!-- --></span><span class="token" style="color:#6272a4">// In Disk<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">9<!-- --></span><span></span><span class="token" style="color:#f8f8f2">}<!-- --></span></code></div></div></pre>
<!-- --><p>위에서 제시한 전체 구성요소와 마찬가지로 delta, intermedidate, snapshot mpt를 정의하고 flat를 정의한 것을 볼 수 있다.<!-- --></p>
<!-- --><blockquote>
<!-- --><p><mark><strong>[Design] Read/Write<!-- --></strong></mark></p>
<!-- --></blockquote>
<!-- --><p>실제로 Write와 Read는 아래와 같이 수행되어진다. 코드는 논문을 참조하였지만, 설명은 직접 작성하였다.<!-- --></p>
<!-- --><pre><div class="MarkDown_codeblock__wrapper__S4FFz"><div class="MarkDown_codeblock__header__h3PfO"><span class="MarkDown_codeblock__header__circle__B4MWO"></span><span class="MarkDown_codeblock__header__circle__B4MWO"></span><span class="MarkDown_codeblock__header__circle__B4MWO"></span><span class="MarkDown_codeblock__header__button__aBRNB"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="25px" width="25px" xmlns="http://www.w3.org/2000/svg"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z"></path></svg></span></div><div style="color:#f8f8f2;background:#282a36;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-rust" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">1<!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#ff79c6">LMPT<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">2<!-- --></span>
<!-- --><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">3<!-- --></span><span></span><span class="token" style="color:#8be9fd">fn<!-- --></span><span> <!-- --></span><span class="token function-definition" style="color:#f1fa8c">write_LMPT<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span>k<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> v<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">{<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">4<!-- --></span><span>  root <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>delta<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span class="token" style="color:#f1fa8c">put<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>delta<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>root<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> k<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> v<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span> <!-- --></span><span class="token" style="color:#6272a4">// put new k, v data and get recomputed root hash<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">5<!-- --></span><span>  <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>delta<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>root <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> root                    <!-- --></span><span class="token" style="color:#6272a4">// set new root<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">6<!-- --></span><span></span><span class="token" style="color:#f8f8f2">}<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">7<!-- --></span>
<!-- --><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">8<!-- --></span><span></span><span class="token" style="color:#8be9fd">fn<!-- --></span><span> <!-- --></span><span class="token function-definition" style="color:#f1fa8c">read_LMPT<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span>k<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> auth_proof<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">-&gt;<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">&lt;<!-- --></span><span>v<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> p<!-- --></span><span class="token" style="color:#f8f8f2">&gt;<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">{<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">9<!-- --></span><span>  <!-- --></span><span class="token" style="color:#6272a4">// get value and path from delta mpt with key<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">10<!-- --></span><span>  <!-- --></span><span class="token" style="color:#f8f8f2">&lt;<!-- --></span><span>v<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> p1<!-- --></span><span class="token" style="color:#f8f8f2">&gt;<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>delta<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span class="token" style="color:#f1fa8c">get<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>delta<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>root<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> k<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">11<!-- --></span><span>  <!-- --></span><span class="token" style="color:#6272a4">// check whether value is exist or not<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">12<!-- --></span><span>  <!-- --></span><span class="token" style="color:#6272a4">// if exist, then return value and path<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">13<!-- --></span><span>  <!-- --></span><span class="token" style="color:#6272a4">// if not exist, then we get a adjacent path from delta MPT and store it in p1.<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">14<!-- --></span><span>  <!-- --></span><span class="token" style="color:#8be9fd">if<!-- --></span><span> v is present
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">15<!-- --></span><span>    <!-- --></span><span class="token" style="color:#8be9fd">return<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">&lt;<!-- --></span><span>v<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> p1<!-- --></span><span class="token" style="color:#f8f8f2">&gt;<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">16<!-- --></span><span>  <!-- --></span><span class="token" style="color:#6272a4">// get value and path from intermediate mpt with key<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">17<!-- --></span><span>  <!-- --></span><span class="token" style="color:#f8f8f2">&lt;<!-- --></span><span>v<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> p2<!-- --></span><span class="token" style="color:#f8f8f2">&gt;<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>interm<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span class="token" style="color:#f1fa8c">get<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>interm<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>root<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> k<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">18<!-- --></span><span>  <!-- --></span><span class="token" style="color:#6272a4">// check whether value is exist or not<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">19<!-- --></span><span>  <!-- --></span><span class="token" style="color:#6272a4">// if exist, then return value and path(p1 is adjacent path in delta, p2 is real path in intermediate MPT)<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">20<!-- --></span><span>  <!-- --></span><span class="token" style="color:#6272a4">// if not exist, then we get a adjacent path from intermediate MPT and store it in p2.<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">21<!-- --></span><span>  <!-- --></span><span class="token" style="color:#8be9fd">if<!-- --></span><span> v is present
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">22<!-- --></span><span>    <!-- --></span><span class="token" style="color:#8be9fd">return<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">&lt;<!-- --></span><span>v<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> p1 <!-- --></span><span class="token" style="color:#f8f8f2">+<!-- --></span><span> p2<!-- --></span><span class="token" style="color:#f8f8f2">&gt;<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">23<!-- --></span><span>  <!-- --></span><span class="token" style="color:#6272a4">// if client want authneticated read(when they can&#x27;t have authenticity), <!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">24<!-- --></span><span>  <!-- --></span><span class="token" style="color:#6272a4">// then request to snapshot MPT and return result<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">25<!-- --></span><span>  <!-- --></span><span class="token" style="color:#6272a4">// else then request to flat kv store and return result without path.<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">26<!-- --></span><span>  <!-- --></span><span class="token" style="color:#8be9fd">if<!-- --></span><span> auth_proof
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">27<!-- --></span><span>    <!-- --></span><span class="token" style="color:#f8f8f2">&lt;<!-- --></span><span>v<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> p3<!-- --></span><span class="token" style="color:#f8f8f2">&gt;<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>snapshot<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span class="token" style="color:#f1fa8c">get<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>snapshot<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>root<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> k<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">28<!-- --></span><span>    <!-- --></span><span class="token" style="color:#8be9fd">return<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">&lt;<!-- --></span><span>v<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> p1 <!-- --></span><span class="token" style="color:#f8f8f2">+<!-- --></span><span> p2 <!-- --></span><span class="token" style="color:#f8f8f2">+<!-- --></span><span> p3<!-- --></span><span class="token" style="color:#f8f8f2">&gt;<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">29<!-- --></span><span>  <!-- --></span><span class="token" style="color:#8be9fd">else<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">30<!-- --></span><span>    v <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>flat<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span class="token" style="color:#f1fa8c">get<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span>k<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">31<!-- --></span><span>    <!-- --></span><span class="token" style="color:#8be9fd">return<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">&lt;<!-- --></span><span>v<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> dummy<!-- --></span><span class="token" style="color:#f8f8f2">&gt;<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">32<!-- --></span><span></span><span class="token" style="color:#f8f8f2">}<!-- --></span></code></div></div></pre>
<!-- --><p>간단하게 요약하자면, 결국 write의 경우에는 다음 절차가 끝인 것이며,<!-- --></p>
<!-- --><ol>
<!-- --><li>key, value를 받아서 delta MPT에 저장한다.<!-- --></li>
<!-- --><li>변경된 root hash를 delta MPT에 적용한다.<!-- --></li>
<!-- --></ol>
<!-- --><p>read의 경우에는 다음과 같은 절차가 끝인 것이다.<!-- --></p>
<!-- --><ol>
<!-- --><li>delta MPT를 우선 조회한다.<!-- --></li>
<!-- --><li>intermediate MPT를 다음으로 조회한다.<!-- --></li>
<!-- --><li>만약, 출처가 확실한 요청인 경우 auth_proof가 필요없으므로, flat KV store를 조회한다.<!-- --></li>
<!-- --><li>auth_proof가 필요하다면, snapshot MPT를 조회한다.<!-- --></li>
<!-- --></ol>
<!-- --><blockquote>
<!-- --><p><mark><strong>[Design] Merge<!-- --></strong></mark></p>
<!-- --></blockquote>
<!-- --><p>write 과정에서는 delta MPT에만 추가를 수행했었다. 아래에서는 실제로 변경사항을 snapshot MPT와 flat KV store에 적용한 것이다.<!-- --></p>
<!-- --><pre><div class="MarkDown_codeblock__wrapper__S4FFz"><div class="MarkDown_codeblock__header__h3PfO"><span class="MarkDown_codeblock__header__circle__B4MWO"></span><span class="MarkDown_codeblock__header__circle__B4MWO"></span><span class="MarkDown_codeblock__header__circle__B4MWO"></span><span class="MarkDown_codeblock__header__button__aBRNB"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="25px" width="25px" xmlns="http://www.w3.org/2000/svg"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z"></path></svg></span></div><div style="color:#f8f8f2;background:#282a36;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-rust" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">1<!-- --></span><span class="token" style="color:#6272a4">// merge intermediate MPT to snapshot MPT and flat KV store<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">2<!-- --></span><span></span><span class="token" style="color:#8be9fd">fn<!-- --></span><span> <!-- --></span><span class="token function-definition" style="color:#f1fa8c">merge_compute<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">-&gt;<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span>root<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> flat<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">{<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">3<!-- --></span><span>  flat <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>flat            
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">4<!-- --></span><span>  root <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>snapshot<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>root   
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">5<!-- --></span><span>  <!-- --></span><span class="token" style="color:#8be9fd">for<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">&lt;<!-- --></span><span>k<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> v<!-- --></span><span class="token" style="color:#f8f8f2">&gt;<!-- --></span><span> <!-- --></span><span class="token" style="color:#8be9fd">in<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>interm<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span class="token" style="color:#f1fa8c">kv<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>interm<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>root<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">6<!-- --></span><span>    root <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>snapshot<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span class="token" style="color:#f1fa8c">append<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span>root<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> k<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> v<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">7<!-- --></span><span>    flat <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> flat<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span class="token" style="color:#f1fa8c">set<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span>k<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> v<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">8<!-- --></span><span>  <!-- --></span><span class="token" style="color:#8be9fd">return<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span>root<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> flat<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span> 
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">9<!-- --></span><span></span><span class="token" style="color:#f8f8f2">}<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">10<!-- --></span>
<!-- --><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">11<!-- --></span><span></span><span class="token" style="color:#6272a4">// reconfigure flat, snapshot root, intermediate MPT, delta MPT<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">12<!-- --></span><span></span><span class="token" style="color:#8be9fd">fn<!-- --></span><span> <!-- --></span><span class="token function-definition" style="color:#f1fa8c">merge_update<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> root<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> flat<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">{<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">13<!-- --></span><span>  <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>flat <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> flat
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">14<!-- --></span><span>  <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>snapshot<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>root <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> root
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">15<!-- --></span><span>  <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>interm <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>delta
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">16<!-- --></span><span>  <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>interm<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>root <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>delta<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>root
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">17<!-- --></span><span>  <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>delta <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">Trie<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">18<!-- --></span><span>  <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>delta<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span>root <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">None<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:3.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">19<!-- --></span><span></span><span class="token" style="color:#f8f8f2">}<!-- --></span></code></div></div></pre>
<!-- --><p>이 과정도 간단하게 요약하자면 다음과 같다.<!-- --></p>
<!-- --><ol>
<!-- --><li>merge_compute, merge_update가 주기적으로 실행되도록 설정한다.<!-- --></li>
<!-- --><li>merge_compute에서는 intermediate MPT의 data를 모두 snapshot MPT와 flat KV store에 추가한다.<!-- --></li>
<!-- --><li>merge_update에서는 intermediate MPT는 이미 적용이 완료되었기 때문에 delta MPT를 intermediate MPT로 변경한 후, delta MPT를 비어 있는 MPT로 변경한다.<!-- --></li>
<!-- --><li>매 주기가 될 때마다 merge_compute와 merge_update가 순차적으로 실행된다.<!-- --></li>
<!-- --></ol>
<!-- --><p>위 method가 중요한 점은 바로 transaction의 write/read와 독립적으로 동작할 수 있다는 점이다. 즉, disk에 data를 write 하기 위해서 실제 transaction 처리에 waiting이 필요없다는 것이다.<!-- --></p>
<!-- --><blockquote>
<!-- --><p><mark><strong>[Design] Flush<!-- --></strong></mark></p>
<!-- --></blockquote>
<!-- --><p>위에서 제시한 Method를 다음과 같이 적용함으로서 다음과 같이 Ethereum state를 update하고, 무결하게 유지할 수 있다.<!-- --></p>
<!-- --><pre><div class="MarkDown_codeblock__wrapper__S4FFz"><div class="MarkDown_codeblock__header__h3PfO"><span class="MarkDown_codeblock__header__circle__B4MWO"></span><span class="MarkDown_codeblock__header__circle__B4MWO"></span><span class="MarkDown_codeblock__header__circle__B4MWO"></span><span class="MarkDown_codeblock__header__button__aBRNB"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 24 24" height="25px" width="25px" xmlns="http://www.w3.org/2000/svg"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z"></path></svg></span></div><div style="color:#f8f8f2;background:#282a36;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none;padding:1em;margin:.5em 0;overflow:auto;border-radius:0.3em"><code class="language-rust" style="color:#f8f8f2;background:none;text-shadow:0 1px rgba(0, 0, 0, 0.3);font-family:Consolas, Monaco, &#x27;Andale Mono&#x27;, &#x27;Ubuntu Mono&#x27;, monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none"><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">1<!-- --></span><span>block_cnt <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#bd93f9">0<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">2<!-- --></span><span>merge_interval <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#bd93f9">100<!-- --></span><span>     <!-- --></span><span class="token" style="color:#6272a4">// you can set this constant<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">3<!-- --></span>
<!-- --><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">4<!-- --></span><span></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span> <!-- --></span><span class="token" style="color:#f8f8f2">:<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span> <!-- --></span><span class="token" style="color:#ff79c6">LMPT<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span>genesis_state<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>  <!-- --></span><span class="token" style="color:#6272a4">// setup initial state<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">5<!-- --></span>
<!-- --><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">6<!-- --></span><span></span><span class="token" style="color:#8be9fd">while<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">Block<!-- --></span><span> is processing
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">7<!-- --></span><span>  <!-- --></span><span class="token" style="color:#8be9fd">for<!-- --></span><span> transaction <!-- --></span><span class="token" style="color:#8be9fd">in<!-- --></span><span> <!-- --></span><span class="token" style="color:#f1fa8c">Block<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">8<!-- --></span><span>    <!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">.<!-- --></span><span class="token" style="color:#f1fa8c">update_trie<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span>transaction<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>                  <!-- --></span><span class="token" style="color:#6272a4">// apply transaction to LMPT<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">9<!-- --></span><span>  block_cnt <!-- --></span><span class="token" style="color:#f8f8f2">+=<!-- --></span><span> <!-- --></span><span class="token" style="color:#bd93f9">1<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">10<!-- --></span><span>  <!-- --></span><span class="token" style="color:#8be9fd">if<!-- --></span><span> block_cnt <!-- --></span><span class="token" style="color:#f8f8f2">%<!-- --></span><span> merge_interval <!-- --></span><span class="token" style="color:#f8f8f2">==<!-- --></span><span> <!-- --></span><span class="token" style="color:#bd93f9">0<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">11<!-- --></span><span>    <!-- --></span><span class="token" style="color:#f1fa8c">Wait<!-- --></span><span> <!-- --></span><span class="token" style="color:#8be9fd">for<!-- --></span><span> last spawned thread to end         <!-- --></span><span class="token" style="color:#6272a4">// wait until previous thread finished.<!-- --></span><span>
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">12<!-- --></span><span>    <!-- --></span><span class="token" style="color:#f1fa8c">merge_update<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> root<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> flat<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>               
<!-- --></span><span class="linenumber react-syntax-highlighter-line-number" style="display:inline-block;min-width:2.25em;padding-right:1em;text-align:right;user-select:none;color:#6272a4">13<!-- --></span><span>    <!-- --></span><span class="token" style="color:#f1fa8c">spawn_thread<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span>root<!-- --></span><span class="token" style="color:#f8f8f2">,<!-- --></span><span> flat<!-- --></span><span class="token" style="color:#f8f8f2">=<!-- --></span><span class="token" style="color:#f1fa8c">merge_compute<!-- --></span><span class="token" style="color:#f8f8f2">(<!-- --></span><span class="token" style="color:#f1fa8c">T<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span class="token" style="color:#f8f8f2">)<!-- --></span><span>   <!-- --></span><span class="token" style="color:#6272a4">// make new thread for merging<!-- --></span></code></div></div></pre>
<!-- --><p>이 과정의 요약은 다음과 같다.<!-- --></p>
<!-- --><ol>
<!-- --><li>merge_interval를 원하는 값으로 초기화한다. (이 값에 대해서 논문에서는 제시하지 않음)<!-- --></li>
<!-- --><li>초기 genesis_state를 통해 LMPT를 초기화한다.<!-- --></li>
<!-- --><li>blockchain의 block을 처리하도록 한다. 새로운 block에 대한 처리도 이에 포함된다.<!-- --></li>
<!-- --><li>그 과정에서 특정 interval이 되면, 기존 merge_compute를 수행하는 thread가 있는지를 확인했다가 background로 merge_compute를 실행하는 thread를 생성한다.<!-- --></li>
<!-- --></ol>
<!-- --><h2 id="Evaluation">Evaluation<!-- --></h2>
<!-- --><p>본 논문에서는 평가를 위해서 다음과 같은 실험을 수행한다.<!-- --></p>




















<!-- --><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">data structure<!-- --></th><th style="text-align:left">workload<!-- --></th></tr></thead><tbody><tr><td style="text-align:left">Test1<!-- --></td><td style="text-align:left">MPT vs LMPT<!-- --></td><td style="text-align:left">simple payment<!-- --></td></tr><tr><td style="text-align:left">Test2<!-- --></td><td style="text-align:left">MPT vs LMPT<!-- --></td><td style="text-align:left">ETC-20 token (Tether)<!-- --></td></tr></tbody></table>
<!-- --><p>여기서 실험 시에 고려한 사항은 다음과 같다.<!-- --></p>
<!-- --><ol>
<!-- --><li>실제와 같은 상황을 만들기 위해서 실제 Ethereum transaction 500,000개를 활용한 benchmark를 만들었다.<!-- --></li>
<!-- --><li>또한, 또 다른 insight를 얻기 위해서 각 address간의 고르면서도 random하게 transaction을 보내도록 하는 Random senders traces benchmark도 만들었다.<!-- --></li>
<!-- --><li>또한, 간단한 payment의 경우와 복잡한 smart contract에 의해 동작하는 ETC-20 token 중 가장 많이 사용되는 Tether token을 활용한 비교도 수행하였다.<!-- --></li>
<!-- --></ol>
<!-- --><p>결과적으로 state로 보관해야할 account의 수가 많아질 수록 LMPT와 MPT 사이의 차이를 명확하게 볼 수 있는 형태를 보여준다. 이 차이는 더 복잡한 ETC-20 token에서 더 명확하게 들어나고 성능 차이는 적게는 1.2배에서 6배 이상까지도 벌어지는 것을 확인할 수 있다. 이를 통해서 결과적으로 cache를 활용하여 더 효율적인 Transaction 처리가 가능하다는 것이다.<!-- --></p>
<!-- --><h2 id="Related-Work">Related Work<!-- --></h2>
<!-- --><p>해당 논문은 결국 Blockchain의 MPT 구현을 변형하여 효율적인 방법을 제시하였다. 이외에도 TPS를 향상시키기 위한 여러 방법이 제시되었다. 하지만, LMPT는 이러한 연구들보다 앞 선 결과를 보여준다. 그 이유를 들기 위해서 다음과 같은 사전 연구와 비교했을 때 어느 점이 좋은지를 밝힌다.<!-- --></p>
<!-- --><ol>
<!-- --><li><strong>Distributed MPTs<!-- --></strong><br/>
LMPT와 가장 유사한 연구 사례들로 MPT의 구현을 변경하여 최적화를 하고자 한 사례이다. 하지만, 이들 중에서도 LMPT가 더 우수하다는 것을 다음을 통해서 알 수 있다.
<!-- --><ul>
<!-- --><li><a href="https://www.usenix.org/conference/hotstorage18/presentation/raju">🔗 mLSM<!-- --></a><br/>
MPT 자체를 여러 개의 MPT로 나누어 저장하는 방식을 택하였다. 이를 통해서 read, write 시에 IO amplication을 막을 수 <!-- --><strong>있었지만<!-- --></strong>, 오히려 write 시에는 여러 번의 중복 writing으로 인해서 더 많은 비용이 발생하였다.<!-- --></li>
<!-- --><li><a href="https://www.usenix.org/conference/atc21/presentation/ponnapalli">🔗 RainBlock<!-- --></a><br/>
MPT를 sharding하여 분배하여 저장하는 방식을 선택하였다. 이를 통해서 성능을 올리는 것이 가능했지만, 이는 전체적인 Ethereum 구현을 바꾸어야 한다. <!-- --><strong>하지만<!-- --></strong>, LMPT는 이러한 변경없이도 client단에서 쉽게 구현 및 변경이 가능하다.<!-- --></li>
<!-- --></ul>
<!-- --></li>
<!-- --><li><strong>Consensus protocols<!-- --></strong><br/>
consensus protocol을 변경하여 최적화를 하려는 시도 역시 많았다(HyperLedger Fabric, Prism, etc). <!-- --><strong>하지만<!-- --></strong>, 이를 통해서 storage bottleneck을 해결할 수는 없다. 따라서, 해당 연구와 consensus protocol 관련 연구는 상호 보완적인 관계로, 같이 사용하게 되면 더 좋은 성능을 보일 것이라고 기대하고 있다.<!-- --></li>
<!-- --><li><strong>Sharding in Blockchains<!-- --></strong><br/>
sharding은 Ethereum v2의 architecture 중 하나로 제시된 내용 중 하나로 이를 이용하게 되면 transaction 실행을 분산하는 효과를 불러올 수 있다. 하지만, shard간의 일관성을 유지하기 위한 protocol과 shard간 cross-shard 통신으로 인한 overhead도 고려해야 한다. 이러한 내용을 제쳐두고도 결국은 sharding과 LMPT는 독립적으로 동작할 수 있기 때문에 consensus protocol과 같이 독립적으로 보아도 무관하다.<!-- --></li>
<!-- --></ol>
<!-- --><h2 id="Opinion">Opinion<!-- --></h2>
<!-- --><p>TPS를 향상 시키기 위한 방법은 Bitcoin이 처음 생기고 나서부터 계속해서 고려되고 있는 문제라고 생각한다. 해당 논문에서는 기존 논문이 였던 mLSM에서 영감을 얻어서 이를 더 발전시킨 방법을 찾았다고 생각한다. 단순히 여러 개의 MPT를 구현하는 것을 넘어서 실제 문제를 명확하게 정의해서 여러 개의 MPT로 어떻게 이를 해결할 수 있는지를 명확하게 제시한 것 같다. 여러 개의 MPT를 통해서 read 과정에서 locality를 확보했을 뿐만 아니라 merge 과정을 write 과정에서 분리함으로서 기존 transaction이 가지던 bottleneck을 해소한 것이다. 이 점이 명확하게 받아들여져서 해당 분야 전공이 아님에도 쉽게 이해할 수 있었다. 하지만, 아쉽게도 실제 구현 code를 찾을 수는 없었기에 flush단계에서 사용된 merge_interval의 정확한 값이 궁금했지만 찾지는 못했다. 또, 이 임계값이 상황에 따라서 성능에 큰 영향을 미치는 요소라고 파악을 하고 있었는데 이를 알 수 없어서 아쉬웠다.<!-- --></p>
<!-- --><p>아마 여기서 후속 연구를 진행할 수 있다면, 해당 임계값을 ML, DL, RL을 이용해서 좀 더 효과적으로 적용할 수 있는 방법을 찾아보는 것도 좋은 연구 방향이 될 수 있을 것이다.
이러한 주제를 처음 접했고, Ethereum의 구현에 대해서도 전혀 아는게 없었기 때문에 다양한 사전 조사를 요구했던 논문이였다. 하지만, Background에 대한 설명도 자세히 나와있고, Idea 자체가 명확했기에 훌륭하고 가독성이 높은 논문이 된 거 같다.<!-- --></p>
<!-- --><h2 id="Reference">Reference<!-- --></h2>
<!-- --><ul>
<!-- --><li>Jemin Andrew Choi, Sidi Mohamed Beillahi, Peilun Li, Andreas Veneris, Fan Long <!-- --><a href="https://ieeexplore.ieee.org/document/9805484/"><code>&quot;LMPTs: Eliminating Storage Bottlenecks for Processing Blockchain Transactions&quot;<!-- --></code></a>, May 2022<!-- --></li>
<!-- --><li>Ao Li, Jemin Andrew Choi, Fan Long <!-- --><a href="https://aoli.al/papers/solythesis-pldi20.pdf"><code>&quot;Securing Smart Contract with Runtime Validation&quot;<!-- --></code></a>, June 2020<!-- --></li>
<!-- --><li>Tumbnail : Photo by <!-- --><a href="https://unsplash.com/@theshubhamdhage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Shubham Dhage<!-- --></a> on <!-- --><a href="https://unsplash.com/s/photos/blockchain?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash<!-- --></a></li>
<!-- --><li>Merkle Patricia Image : <!-- --><a href="https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture">https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture<!-- --></a></li>
<!-- --><li>Pandian Raju, Soujanya Ponnapalli, Evan Kaminsky, Gilad Oved, and Zachary Keener, University of Texas at Austin; Vijay Chidambaram, University of Texas at Austin and VMware Research; Ittai Abraham, VMware Research, <!-- --><a href="https://www.usenix.org/conference/hotstorage18/presentation/raju"><code>mLSM: Making Authenticated Storage Faster in Ethereum<!-- --></code></a>, July 2018<!-- --></li>
<!-- --><li>Soujanya Ponnapalli, Aashaka Shah, and Souvik Banerjee, University of Texas at Austin; Dahlia Malkhi, Diem Association and Novi Financial; Amy Tai, VMware Research; Vijay Chidambaram, University of Texas at Austin and VMware Research; Michael Wei, VMware Research, <!-- --><a href="https://www.usenix.org/conference/atc21/presentation/ponnapalli"><code>RainBlock: Faster Transaction Processing in Public Blockchains<!-- --></code></a>, July 2021<!-- --></li>
<!-- --></ul></article><div class="Comment_comment__wrapper___sKTf"><h2 class="Comment_comment__title__hLmXO">Comments</h2><section></section></div><ins class="adsbygoogle" style="display:block;text-align:center" data-ad-format="autorelaxed" data-ad-client="ca-pub-7452732177557701" data-ad-slot="3654773972"></ins></div></section><footer class="Layout_footer__EL5v8"><div class="Layout_footer__copyright__r5baC"><span>Copyright © euidong</span><br/><span>모든 컨텐츠에 대한 저작권은 작성자에게 존재합니다. <!-- --><br/>불법 복제를 통한 상업적 사용을 절대적으로 금지합니다. <!-- --><br/>단, 비상업적 이용의 경우 출처 및 링크를 적용한다면 자유롭게 사용가능 합니다.<!-- --></span><span>Also I use photos by<!-- --> <!-- --><a href="https://unsplash.com/@lorenzoherrera?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Lorenzo Herrera</a> <!-- -->on<!-- --> <!-- --><a href="https://unsplash.com/s/photos/tech?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" tabindex="-1">Unsplash</a></span></div><div class="Layout_footer__contents__YZWSm"><a class="Layout_footer__contents__link__K_TKH" href="https://github.com/euidong" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><span>github</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://euidong.github.io/portfolio" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M6 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm-5 6s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H1zM11 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5zm.5 2.5a.5.5 0 0 0 0 1h4a.5.5 0 0 0 0-1h-4zm2 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2zm0 3a.5.5 0 0 0 0 1h2a.5.5 0 0 0 0-1h-2z"></path></svg><span>portfolio</span></a><a class="Layout_footer__contents__link__K_TKH" href="https://chrome.google.com/webstore/detail/bonfire/nkooidijgbppkojdgkoafcoppnohdfka?hl=ko" target="_blank" rel="noreferrer"><svg stroke="currentColor" fill="currentColor" stroke-width="0" version="1.1" viewBox="0 0 16 16" height="60" width="60" xmlns="http://www.w3.org/2000/svg"><path d="M5.016 16c-1.066-2.219-0.498-3.49 0.321-4.688 0.897-1.312 1.129-2.61 1.129-2.61s0.706 0.917 0.423 2.352c1.246-1.387 1.482-3.598 1.293-4.445 2.817 1.969 4.021 6.232 2.399 9.392 8.631-4.883 2.147-12.19 1.018-13.013 0.376 0.823 0.448 2.216-0.313 2.893-1.287-4.879-4.468-5.879-4.468-5.879 0.376 2.516-1.364 5.268-3.042 7.324-0.059-1.003-0.122-1.696-0.649-2.656-0.118 1.823-1.511 3.309-1.889 5.135-0.511 2.473 0.383 4.284 3.777 6.197z"></path></svg><span>chat</span></a></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"content":"\n## Intro\n\nEthereum의 TPS를 Client 단에서 향상 시키기 위한 노력으로, LMPT는 Layered Merkle Partical Trie의 약자이다. 이는 기존 Ethereum에서 사용하던 MPT의 성능 향상을 위하여 제기된 아이디어로 Computer Architecture에서 흔하게 사용되는 cache를 접목한 방법이다. (해당 논문 ICBC 2022의 논문 중 LMPT를 기반으로 한 요약글이다.)\n\n## Terms\n\n- **ERC-20**  \n  Ethereum과 호환이 가능한 token에 대한 표준을 제시한 문서이다. 즉, 이 표준을 만족하는 token은 Ethereum을 통해서 교환이 가능하며 그 반대도 가능하다.\n- **Tether token**  \n  Tether token은 ERC-20에 기반한 대표적인 token으로, 미국 달러와 1:1로 대응하는 USDT로 유명하다. 실제 거래에서도 빈번히 사용되는 ERC-20 token이다.\n- **Trie**  \n  Trie는 sequence로 이루어진 데이터의 빠른 검색을 위해서 만들어진 tree의 일종이다. 데이터를 저장할 때 sequence 데이터의 검색을 최적화하는 것을 목표로 한다. 원리는 다음과 같다. sequence의 검색 시에 sequence의 앞에서부터 맞는 node를 root에서부터 검색하며 찾아나간다. 이 덕분에 검색 시에는 sequence의 길이만큼의 시간이면 충분히 데이터를 찾는 것이 가능하다. 하지만, 저장 sequence를 풀어서 저장하는 방식이기 때문에 경우의 수가 엄청 많아진다. 이는 sequence를 하나의 데이터로 보는 것보다 저장 공간을 많이 차지한다는 단점도 있다.\n- **Patricia Trie**  \n  Trie에서는 기본적으로 모든 sequence를 요소 하나를 node로 보았다면, Patricia Trie에서는 각 nnode가 두 개로 나뉘어진다. branch node, leaf node이다. leaf node는 각 sequence의 끝을 의미하며 각 sequence는 반드시 하나의 leaf node로 종결되어지고, branch node는 저장한 데이터 중에서 중복이 발생하는 경우 중간 지점으로 저장해두는 방식이다. 따라서, Trie에서는 각 노드가 sequence의 하나의 값을 의미했다면, Patricia Trie에서는 path가 sequence의 요소들을 의미한다. 이에 대한 이해를 위해서는 아래에 제시된 그림을 보는 것이 좋을 것이다.(좌. trie, 우. patricia trie)  \n  ![patricia-trie](/images/patricia-trie.png)\n- **Merkle Tree**  \n  Bitcoin에서 사용된 자료구조로 Blockchain의 모든 Block을 저장하는 것은 특정 node에게는 부담이 될 수 있기 때문에 이에 대한 인증을 쉽게 하기 위해서 요약본만을 저장하는 방식이다. 자세한 내용은 [🔗 bitcoin-4](/posts/bitcoin-4)의 2. Merkle Tree 부분에서 자세히 다루었다. 간단히 설명하자면, Block을 serialization하고 hash하여 결과값을 저장한 후 이를 leaf node로 하는 형태의 binary tree를 만드는 것이다. 그렇기에 우리는 Merkle Tree의 hash값 몇개만 갖고도 해당 transaction을 포함하는 block이 유효한지를 파악할 수 있다.  \n- **MPT**  \n  Merkle Patricia Trie의 줄임말로 기존 Bitcoin에서 사용하던 Merkle Tree와 Patricia Trie의 결합을 통해 만들어낸 자료구조이다. 이에 대한 설명은 아래에서 더 자세히 다룬다.\n- **Latency bound issue**  \n  Memory에서 너무 많은 데이터를 얻어오려고 할 때를 의미하는 Memory Bound 중의 하나로 data를 Memory 만으로는 가져올 수 없을 때, secondary storage에서 불러오는데 발생하는 latency를 의미한다.\n\n## Problem\n\nBitcoin에서 시작된 Blockchain에 대한 응용은 의료, 공급망 관리 등으로 확장되며 계속해서 발전되고 있다. 그럼에도 불구하고 아직까지 **transaction의 빠른 처리**는 challenge한 부분으로 남아있다. 이는 P2P 환경에서 안전한 transaction의 생성 및 조회 그리고 검증을 위해서 어쩔 수 없는 trade off로 받아들여졌다. 그 결과 7~30 tps(transaction per second)정도에 그치는 성능을 보여주고 있다. 주류인 중앙 처리 방식은 수 천개의 transaction을 처리하는 것과 비교했을 때에는 굉장히 낮은 수준이다.\n\n이를 해결하기 위해서 다년간 여러가지 접근 방식과 해결책이 제시되었다(AI-gorand, Conflux, Prism, OHIE, etc). 이를 통해서 수 천개의 transaction을 blockchain에서 처리하는 것이 가능하게 되었다. 하지만, 실제로 응용하는데에는 한계가 있었다. 그것은 state를 보관하는 ledger 단에서 발생하는 것이 아닌 실제로 transaction을 처리하는 client 단에서의 문제이다. 이는 바로 **blockchain state를 변경하는 transaction이 빈번하게 발생하는 경우 client 단에서 새로운 bottleneck이 발생한다는 점이다.** 실제로 가장 유명한 Ethereum Client인 GoEthereum과 OpenEtereum에서는 700 tps로 기존 제시된 수 천 transaction보다는 한참 못 미치는 성능을 보여준다.\n\n그 원인은 사실상 state machine이라고 할 수 있는 Ethereum과 이것의 검증을 위해 제안된 MPT의 구조적인 한계로 인해 발생한다(이는 Background에서 제대로 다룰 것이다). 이 구조적인 한계에 의해서 다음과 같은 현상들이 발생한다.\n\n1. key-value 짝으로 이루어지는 데이터의 read/write 연산이 증폭해서 발생한다.\n2. 특히 write operation은 모든 node에 대한 hash를 재계산하도록 한다.\n3. 이러한 동작이 완료되기 전까지 반드시 transaction을 처리하는 thread는 대기해야 한다.\n\n이를 해결하기 위해서, 해당 논문은 LMPT라는 새로운 자료구조를 제시한다. 이는 기존 Ethereum의 MPT를 기반으로 하는 시스템보다 6배 정도 상승된 tps 성능 지표를 보여주고 있다. 이것의 핵심 아이디어는 MPT를 계층화(layer)하는 것이다. 즉, 최근 update된 내용을 별도의 저장공간을 활용하여 저장해두고 이를 우선적으로 활용하기 때문에 더 빠른 처리 성능을 보여주는 것이다.\n\n## Background\n\n\u003e \u003cmark\u003e**1. Ethereum**\u003c/mark\u003e\n\nEthereum은 기존 Bitcoin Blockchain System과 확연히 다른점이 있다. 바로 State Machine이라는 점이다. 기존의 Bitcoin에서는 거래 내역을 모두 공개하고, 이를 통해서 우리는 최초 Block에서부터 이 거래 내역을 읽어들이면서 가진 자산을 확인할 수 있다. 즉, 거래 history를 종합해서 결과값을 얻는 것이다. Transaction의 수정과 삭제 없이 계속해서 추가만 이루어지는 형태라고 볼 수 있다. 하지만, Ethereum에서는 Transaction을 State Machine의 상태를 변화시키는 하나의 action으로 받아들인다. 따라서, Transaction에 의해서 우리는 상태가 변화하도록 하는 방식인 것이다. 따라서, 우리는 해당 State만 보고 자신의 자산을 파악할 수 있는 것이다.\n\n\u003e \u003cmark\u003e**2. MPT**\u003c/mark\u003e\n\n결국 Ethereum 시스템을 활용하기 위해서는 모든 것이 공개되는 Network 상에서 안전하게 State와 이를 변경하는 Transaction을 보관하는 것이 중요하다. 이러한 data를 무결하게 그러면서도 수정, 삭제, 검색 등이 용이할 수 있도록 하기 위해서 Ethereum에서는 MPT(Merkle Patricia Trie)를 활용한다. 이는 결국 위에서 설명한 Merkle Tree와 마찬가지로 하위 Node의 Hash값을 상위 Node에서 가지기 때문에 Root Hash만을 비교하여 검증을 할 수 있다는 점에서 강점을 가지고 있다.\n\nMPT는 3가지의 Node로 이루어진다.\n\n1. **Leaf Node**  \n   실제로 value를 저장하는 말단 node이다. 만약, path로 key가 모두 표시되지 않았다면, key-end에 남은 key를 모두 담는다.\n2. **Extension Node**  \n   Leaf Node 이외에 경로의 확장이 필요할 때 사용되어지는 Node로 Branch Node의 hash data를 하나로 합치는 등의 역할을 한다.\n3. **Branch Node**  \n   16개의 pointer를 포함하는 Node로 이를 통해서 Leaf, Extension, Branch Node를 가르키는 데 사용할 수 있다.\n\n따라서, 일반적인 구조는 아래와 같다.\n\n![mpt](/images/mpt.png)\n\n이 구조가 가지는 의의는 결국 우리는 하위 node들을 hash한 데이터를 상위 node에서 포함하고 있기 때문에 필요에 따라 trie에 일부분만을 저장해도 data의 검증은 충분히 가능하다는 점이다. 따라서, 모든 data를 가지는 full node와 달리 light client는 더 적은 데이터만 갖고도 검증이 가능한 것이다. 하지만, light client에서 authenticated read(full node의 도움이 필요한 read)를 수행하고자 하는 경우 full node에서는 read를 수행하기 위해서 path를 따라서 읽기를 반복해나가며, leaf node에 있는 최종 value를 얻어와야 한다.\n\n\u003e \u003cmark\u003e**3. Further Observation**\u003c/mark\u003e\n\n해당 논문에서는 OpenEthereum Client를 관측하고, 기존 논문들에서 여러 영감을 얻었다. 다음은 이 논문에서 insight를 얻는 데 중요한 역할을 한 관측 정보이다.\n\n1. Transaction이 Blockchain State에 빈번하게 접근할 수록 Transaction의 처리 성능은 낮아진다.\n2. 실제 Transaction의 실행 시간 중에서 가장 많은 시간을 차지하는 것은 Blockchain State에 접근하는 동작(SLOAD, SSTORE)이다.  \n   [🔗 기반 논문(Securing Smart Contract with Runtime Validation)](https://aoli.al/papers/solythesis-pldi20.pdf)\n3. 한 번의 Transaction은 여러 번의 IO을 유발한다.(IO amplication)  \n   MPT 구조에서 하나의 key 조회를 위해서 한 번에 데이터를 찾을 수 없기 때문에 결국 key를 통해서 Trie를 순회하여야 한다.  \n   이는 key에 대응되는 Node가 많을 수록 많은 IO를 요구한다.\n4. Transaction 실행 thread는 병렬적으로 실행되지 않고, 위에서 제시된 operation이 끝날 때까지 대기한다.  \n   즉, Transaction을 처리하는 Thread는 critical path(section)를 지키기 위해서 단 하나만 존재한다는 것이다.\n5. memory cache size를 늘리는 것은 성능향상에 큰 도움이 되지 않는다.  \n   | Memory Cache size(MB) | Hit Rate | TPS  |\n   | :-------------------- | :------- | :--- |\n   | 50                    | 0.635    | 1238 |\n   | 100                   | 0.758    | 1256 |\n   | 500                   | 0.862    | 1278 |\n   | 1000                  | 0.879    | 1292 |\n\n   위의 표를 보면 알 수 있지만, Cache Size를 늘렸을 때 Hit Rate는 늘릴 수 있지만 TPS의 성능 향상 폭은 5% 수준에 그친다. 이는 memory cache를 제대로 사용하지 못하고 있음을 의미한다.\n\n즉, 해당 논문에서는 하나의 Transaction에 의해서 IO가 빈번히 발생하는데 이를 병렬적으로 처리하는 것도 기존 MPT만으로는 한계가 있기 때문에 이를 해결할 수 있는 방법을 제시한다.\n\n## LMPT\n\nLayered Merkle Patricia Trie의 약자로 기존 Ethereum MPT의 한계를 극복하기 위해서 제안하는 자료구조이다. 이의 핵심적인 목표는 Authenticated Ethereum State를 더 효과적으로 저장하는 것이다. 여기서 사용하는 핵심 아이디어는 바로 기존 Computer Architecture에서 사용했던 Hierarchical Memory의 구조를 그대로 차용하는 것이다. 즉, cache로 사용할 수 있는 MPT를 더 구현해두는 것이다. 이는 결론상으로 MPT의 read시에 IO amplication을 효과적으로 줄일 수 있다.\n\n우선 구성 요소는 다음과 같다.\n\n1. **Delta MPT**  \n   Read access가 요청되면 가장 먼저 조회되는 MPT이다.\n2. **Intermediate MPT**  \n   Delta MPT 이후에 조회되는 MPT이다.\n3. **Snapshot MPT**  \n   원본이라고 할 수 있는 MPT이다. 전체 blockchain data를 저장하며, disk에 존재한다.\n4. **Flat KV Store**  \n   read시에 가장 마지막에 조회된다. 이 역시도 전체 blockchain data를 저장하지만, 차이점이라면 key를 path로 하여 조회하는 MPT와 다르게 key, value store형태이다.  \n   그렇기에 snapshot MPT와 동일하게 disk에 존재하지만, 더 빠르다게 조회가 가능하다는 장점이 있다.  \n   snapshot MPT를 조회하는 대신에 이를 통해서 조회를 한다면, key를 통해서 바로 조회할 수 있는 방식이기 때문에 read IO amplication을 효과적으로 줄일 수 있다.\n\n위의 까지는 read시에 최적화를 수행하였다면, write 시에는 이렇게 계층화를 해두었기 때문에 disk에 write하는 동안의 여유가 생길 수 있다. LMPT에서는 MPT의 적은 변화일 경우에는 delta MPT에 저장하고 있다가 periodic checkpoint를 두고, 해당 시점마다 delta MPT의 변경사항은 intermediate MPT, intermediate MPT의 변경 내용은 snapshot MPT에 합친다. 따라서, write 동작은 시간차를 두고 **batch 단위**로 **verification과는 독립적**으로 진행된다. 이는 결국 병렬적으로 IO 작업을 처리할 수 있는 여지를 만들어준다.\n\n\u003e \u003cmark\u003e**[Design] Structure**\u003c/mark\u003e\n\n어떻게 실제로 이를 구현했는지에 대한 outline을 제시하면 다음과 같다. (OpenEthereum은 Rust를 이용하기 때문에 LMPT도 Rust에 기반한 code이다. psuedo code이기 때문에 해당 언어를 몰라도 알아볼 수 있을 것이다.)\n\n```rust\nstruct Trie {\n  root: uint256,\n  kv:   Map\n}\nstruct LMPT {\n  delta, interm:  Trie, // In memory\n  snapshot:       Trie, // In Disk\n  flat:           Map   // In Disk\n}\n```\n\n위에서 제시한 전체 구성요소와 마찬가지로 delta, intermedidate, snapshot mpt를 정의하고 flat를 정의한 것을 볼 수 있다.\n\n\u003e \u003cmark\u003e**[Design] Read/Write**\u003c/mark\u003e\n\n실제로 Write와 Read는 아래와 같이 수행되어진다. 코드는 논문을 참조하였지만, 설명은 직접 작성하였다.\n\n```rust\nT := LMPT()\n\nfn write_LMPT(k, v) {\n  root := T.delta.put(T.delta.root, k, v) // put new k, v data and get recomputed root hash\n  T.delta.root := root                    // set new root\n}\n\nfn read_LMPT(k, auth_proof) -\u003e \u003cv, p\u003e {\n  // get value and path from delta mpt with key\n  \u003cv, p1\u003e := T.delta.get(T.delta.root, k)\n  // check whether value is exist or not\n  // if exist, then return value and path\n  // if not exist, then we get a adjacent path from delta MPT and store it in p1.\n  if v is present\n    return \u003cv, p1\u003e\n  // get value and path from intermediate mpt with key\n  \u003cv, p2\u003e := T.interm.get(T.interm.root, k)\n  // check whether value is exist or not\n  // if exist, then return value and path(p1 is adjacent path in delta, p2 is real path in intermediate MPT)\n  // if not exist, then we get a adjacent path from intermediate MPT and store it in p2.\n  if v is present\n    return \u003cv, p1 + p2\u003e\n  // if client want authneticated read(when they can't have authenticity), \n  // then request to snapshot MPT and return result\n  // else then request to flat kv store and return result without path.\n  if auth_proof\n    \u003cv, p3\u003e := T.snapshot.get(T.snapshot.root, k)\n    return \u003cv, p1 + p2 + p3\u003e\n  else\n    v := T.flat.get(k)\n    return \u003cv, dummy\u003e\n}\n```\n\n간단하게 요약하자면, 결국 write의 경우에는 다음 절차가 끝인 것이며,\n\n1. key, value를 받아서 delta MPT에 저장한다.\n2. 변경된 root hash를 delta MPT에 적용한다.\n\nread의 경우에는 다음과 같은 절차가 끝인 것이다.\n\n1. delta MPT를 우선 조회한다.\n2. intermediate MPT를 다음으로 조회한다.\n3. 만약, 출처가 확실한 요청인 경우 auth_proof가 필요없으므로, flat KV store를 조회한다.\n4. auth_proof가 필요하다면, snapshot MPT를 조회한다.\n\n\u003e \u003cmark\u003e**[Design] Merge**\u003c/mark\u003e\n\nwrite 과정에서는 delta MPT에만 추가를 수행했었다. 아래에서는 실제로 변경사항을 snapshot MPT와 flat KV store에 적용한 것이다.\n\n```rust\n// merge intermediate MPT to snapshot MPT and flat KV store\nfn merge_compute(T) -\u003e (root, flat) {\n  flat := T.flat            \n  root := T.snapshot.root   \n  for \u003ck, v\u003e in T.interm.kv(T.interm.root)\n    root := T.snapshot.append(root, k, v)\n    flat := flat.set(k, v)\n  return (root, flat) \n}\n\n// reconfigure flat, snapshot root, intermediate MPT, delta MPT\nfn merge_update(T, root, flat) {\n  T.flat := flat\n  T.snapshot.root := root\n  T.interm := T.delta\n  T.interm.root := T.delta.root\n  T.delta := Trie()\n  T.delta.root := None\n}\n```\n\n이 과정도 간단하게 요약하자면 다음과 같다.\n\n1. merge_compute, merge_update가 주기적으로 실행되도록 설정한다.\n2. merge_compute에서는 intermediate MPT의 data를 모두 snapshot MPT와 flat KV store에 추가한다.\n3. merge_update에서는 intermediate MPT는 이미 적용이 완료되었기 때문에 delta MPT를 intermediate MPT로 변경한 후, delta MPT를 비어 있는 MPT로 변경한다.\n4. 매 주기가 될 때마다 merge_compute와 merge_update가 순차적으로 실행된다.\n\n위 method가 중요한 점은 바로 transaction의 write/read와 독립적으로 동작할 수 있다는 점이다. 즉, disk에 data를 write 하기 위해서 실제 transaction 처리에 waiting이 필요없다는 것이다.\n\n\u003e \u003cmark\u003e**[Design] Flush**\u003c/mark\u003e\n\n위에서 제시한 Method를 다음과 같이 적용함으로서 다음과 같이 Ethereum state를 update하고, 무결하게 유지할 수 있다.\n\n```rust\nblock_cnt := 0\nmerge_interval := 100     // you can set this constant\n\nT := LMPT(genesis_state)  // setup initial state\n\nwhile Block is processing\n  for transaction in Block\n    T.update_trie(transaction)                  // apply transaction to LMPT\n  block_cnt += 1\n  if block_cnt % merge_interval == 0\n    Wait for last spawned thread to end         // wait until previous thread finished.\n    merge_update(T, root, flat)               \n    spawn_thread(root, flat=merge_compute(T))   // make new thread for merging\n```\n\n이 과정의 요약은 다음과 같다.\n\n1. merge_interval를 원하는 값으로 초기화한다. (이 값에 대해서 논문에서는 제시하지 않음)\n2. 초기 genesis_state를 통해 LMPT를 초기화한다.\n3. blockchain의 block을 처리하도록 한다. 새로운 block에 대한 처리도 이에 포함된다.\n4. 그 과정에서 특정 interval이 되면, 기존 merge_compute를 수행하는 thread가 있는지를 확인했다가 background로 merge_compute를 실행하는 thread를 생성한다.\n\n## Evaluation\n\n본 논문에서는 평가를 위해서 다음과 같은 실험을 수행한다.\n\n|       | data structure | workload              |\n| :---- | :------------- | :-------------------- |\n| Test1 | MPT vs LMPT    | simple payment        |\n| Test2 | MPT vs LMPT    | ETC-20 token (Tether) |\n\n여기서 실험 시에 고려한 사항은 다음과 같다.\n\n1. 실제와 같은 상황을 만들기 위해서 실제 Ethereum transaction 500,000개를 활용한 benchmark를 만들었다.\n2. 또한, 또 다른 insight를 얻기 위해서 각 address간의 고르면서도 random하게 transaction을 보내도록 하는 Random senders traces benchmark도 만들었다.\n3. 또한, 간단한 payment의 경우와 복잡한 smart contract에 의해 동작하는 ETC-20 token 중 가장 많이 사용되는 Tether token을 활용한 비교도 수행하였다.\n\n결과적으로 state로 보관해야할 account의 수가 많아질 수록 LMPT와 MPT 사이의 차이를 명확하게 볼 수 있는 형태를 보여준다. 이 차이는 더 복잡한 ETC-20 token에서 더 명확하게 들어나고 성능 차이는 적게는 1.2배에서 6배 이상까지도 벌어지는 것을 확인할 수 있다. 이를 통해서 결과적으로 cache를 활용하여 더 효율적인 Transaction 처리가 가능하다는 것이다.\n\n## Related Work\n\n해당 논문은 결국 Blockchain의 MPT 구현을 변형하여 효율적인 방법을 제시하였다. 이외에도 TPS를 향상시키기 위한 여러 방법이 제시되었다. 하지만, LMPT는 이러한 연구들보다 앞 선 결과를 보여준다. 그 이유를 들기 위해서 다음과 같은 사전 연구와 비교했을 때 어느 점이 좋은지를 밝힌다.\n\n1. **Distributed MPTs**  \n   LMPT와 가장 유사한 연구 사례들로 MPT의 구현을 변경하여 최적화를 하고자 한 사례이다. 하지만, 이들 중에서도 LMPT가 더 우수하다는 것을 다음을 통해서 알 수 있다.\n   - [🔗 mLSM](https://www.usenix.org/conference/hotstorage18/presentation/raju)  \n     MPT 자체를 여러 개의 MPT로 나누어 저장하는 방식을 택하였다. 이를 통해서 read, write 시에 IO amplication을 막을 수 **있었지만**, 오히려 write 시에는 여러 번의 중복 writing으로 인해서 더 많은 비용이 발생하였다.\n   - [🔗 RainBlock](https://www.usenix.org/conference/atc21/presentation/ponnapalli)  \n     MPT를 sharding하여 분배하여 저장하는 방식을 선택하였다. 이를 통해서 성능을 올리는 것이 가능했지만, 이는 전체적인 Ethereum 구현을 바꾸어야 한다. **하지만**, LMPT는 이러한 변경없이도 client단에서 쉽게 구현 및 변경이 가능하다.\n2. **Consensus protocols**  \n   consensus protocol을 변경하여 최적화를 하려는 시도 역시 많았다(HyperLedger Fabric, Prism, etc). **하지만**, 이를 통해서 storage bottleneck을 해결할 수는 없다. 따라서, 해당 연구와 consensus protocol 관련 연구는 상호 보완적인 관계로, 같이 사용하게 되면 더 좋은 성능을 보일 것이라고 기대하고 있다.\n3. **Sharding in Blockchains**  \n   sharding은 Ethereum v2의 architecture 중 하나로 제시된 내용 중 하나로 이를 이용하게 되면 transaction 실행을 분산하는 효과를 불러올 수 있다. 하지만, shard간의 일관성을 유지하기 위한 protocol과 shard간 cross-shard 통신으로 인한 overhead도 고려해야 한다. 이러한 내용을 제쳐두고도 결국은 sharding과 LMPT는 독립적으로 동작할 수 있기 때문에 consensus protocol과 같이 독립적으로 보아도 무관하다.\n\n## Opinion\n\nTPS를 향상 시키기 위한 방법은 Bitcoin이 처음 생기고 나서부터 계속해서 고려되고 있는 문제라고 생각한다. 해당 논문에서는 기존 논문이 였던 mLSM에서 영감을 얻어서 이를 더 발전시킨 방법을 찾았다고 생각한다. 단순히 여러 개의 MPT를 구현하는 것을 넘어서 실제 문제를 명확하게 정의해서 여러 개의 MPT로 어떻게 이를 해결할 수 있는지를 명확하게 제시한 것 같다. 여러 개의 MPT를 통해서 read 과정에서 locality를 확보했을 뿐만 아니라 merge 과정을 write 과정에서 분리함으로서 기존 transaction이 가지던 bottleneck을 해소한 것이다. 이 점이 명확하게 받아들여져서 해당 분야 전공이 아님에도 쉽게 이해할 수 있었다. 하지만, 아쉽게도 실제 구현 code를 찾을 수는 없었기에 flush단계에서 사용된 merge_interval의 정확한 값이 궁금했지만 찾지는 못했다. 또, 이 임계값이 상황에 따라서 성능에 큰 영향을 미치는 요소라고 파악을 하고 있었는데 이를 알 수 없어서 아쉬웠다.\n\n아마 여기서 후속 연구를 진행할 수 있다면, 해당 임계값을 ML, DL, RL을 이용해서 좀 더 효과적으로 적용할 수 있는 방법을 찾아보는 것도 좋은 연구 방향이 될 수 있을 것이다.\n이러한 주제를 처음 접했고, Ethereum의 구현에 대해서도 전혀 아는게 없었기 때문에 다양한 사전 조사를 요구했던 논문이였다. 하지만, Background에 대한 설명도 자세히 나와있고, Idea 자체가 명확했기에 훌륭하고 가독성이 높은 논문이 된 거 같다.\n\n## Reference\n\n- Jemin Andrew Choi, Sidi Mohamed Beillahi, Peilun Li, Andreas Veneris, Fan Long [`\"LMPTs: Eliminating Storage Bottlenecks for Processing Blockchain Transactions\"`](https://ieeexplore.ieee.org/document/9805484/), May 2022\n- Ao Li, Jemin Andrew Choi, Fan Long [`\"Securing Smart Contract with Runtime Validation\"`](https://aoli.al/papers/solythesis-pldi20.pdf), June 2020\n- Tumbnail : Photo by [Shubham Dhage](https://unsplash.com/@theshubhamdhage?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/blockchain?utm_source=unsplash\u0026utm_medium=referral\u0026utm_content=creditCopyText)\n- Merkle Patricia Image : \u003chttps://ethereum.stackexchange.com/questions/268/ethereum-block-architecture\u003e\n- Pandian Raju, Soujanya Ponnapalli, Evan Kaminsky, Gilad Oved, and Zachary Keener, University of Texas at Austin; Vijay Chidambaram, University of Texas at Austin and VMware Research; Ittai Abraham, VMware Research, [`mLSM: Making Authenticated Storage Faster in Ethereum`](https://www.usenix.org/conference/hotstorage18/presentation/raju), July 2018\n- Soujanya Ponnapalli, Aashaka Shah, and Souvik Banerjee, University of Texas at Austin; Dahlia Malkhi, Diem Association and Novi Financial; Amy Tai, VMware Research; Vijay Chidambaram, University of Texas at Austin and VMware Research; Michael Wei, VMware Research, [`RainBlock: Faster Transaction Processing in Public Blockchains`](https://www.usenix.org/conference/atc21/presentation/ponnapalli), July 2021\n","slug":"lmpt","date":"2022-10-28 17:17","title":"LMPT","category":"Paper","tags":["Blockchain","Ehtereum","MPT"],"desc":"Ethereum의 TPS를 Client 단에서 향상 시키기 위한 노력으로, LMPT는 Layered Merkle Partical Trie의 약자이다. 이는 기존 Ethereum에서 사용하던 MPT의 성능 향상을 위하여 제기된 아이디어로 Computer Architecture에서 흔하게 사용되는 cache를 접목한 방법이다. (해당 논문 ICBC 2022의 논문 중 LMPT를 기반으로 한 요약글이다.)","thumbnailSrc":"https://euidong.github.io/images/blockchain-thumbnail.jpg"},"relatedPosts":[]},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"lmpt"},"buildId":"6SENXQ_RcGFHETqFmw7p-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>