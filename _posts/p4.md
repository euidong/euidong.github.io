---
slug: "p4"
title: "P4"
date: "2022-06-09 17:29"
category: "Network"
tags: ["SDN", "P4", "ProgrammableSwitch", "DataPlane", "OpenFlow"]
thumbnailSrc: "/images/p4-icon.png"
---

## Reference

- Thumbnail: [ğŸ”— P4 ê³µì‹í™ˆí˜ì´ì§€](https://p4.org)
- [P4 specification](https://p4.org/p4-spec/docs/P4-16-v1.2.2.pdf)

## History

ì˜ˆì „ Postingì—ì„œ [ğŸ”— OpenFlow](/posts/openflow)ì™€ [ğŸ”— SDN](/posts/sdn)ì— ëŒ€í•´ì„œ ë‹¤ë£¬ ì ì´ ìˆë‹¤. ì´ë•Œ, P4ì— ëŒ€í•´ì„œ ê°„ëµíˆ ì•Œì•„ë³´ê³  ì§€ë‚˜ê°”ì—ˆëŠ”ë°, í•´ë‹¹ Postingì—ì„œëŠ” ì´ë¥¼ ìì„¸íˆ ë‹¤ë£° ê²ƒì´ë‹¤. ë§Œì•½, ì´ì— ëŒ€í•œ ê°œë…ì´ ì¡í˜€ìˆì§€ ì•Šë‹¤ë©´, í•´ë‹¹ Postingì„ ì´í•´í•˜ê¸° ì–´ë µë‹¤. ë”°ë¼ì„œ, SDNê³¼ OpenFlow ê´€ë ¨ Postingì„ ë¨¼ì € ì½ê³  ë‹¤ì‹œ ëŒì•„ì˜¤ê¸°ë¥¼ ë°”ë€ë‹¤.

ë¨¼ì €, P4ì˜ ì´ˆê¸° ì‹œì‘ì€ OpenFlowì˜ ì„±ì¥ê³¼ ì—°ê´€ì´ ìˆë‹¤. OpenFlowëŠ” ê¸°ì¡´ì˜ Switchë¥¼ Data Planeê³¼ Control Planeìœ¼ë¡œ ë‚˜ëˆ„ì–´ Control Planeì„ ì™¸ë¶€ Server(Controller)ë¡œ ì˜®ê¸°ê³  ì´ë“¤ì€ OpenFlow Protocolì„ í†µí•´ì„œ Switchì˜ Data Palenì„ ì œì–´í•˜ê³ ì í–ˆë‹¤. OpenFlowì˜ ì‚¬ìš©ì´ ê°€ì†í™”ë˜ë©´ì„œ ê³„ì†í•´ì„œ ìƒˆë¡œìš´ versionì´ updateë˜ì—ˆê³ , 1.0ì—ì„œ 1.5ê¹Œì§€ ë„ë‹¬í•˜ê²Œ ë˜ì—ˆë‹¤. ê·¸ëŸ°ë°, ì—¬ëŸ¬ Usecaseì™€ Protocolì„ ì§€ì›í•˜ê¸° ìœ„í•´ì„œ ì ì  ë¹„ëŒ€í•´ì§€ëŠ” Headerë¥¼ ë§ˆì£¼ì¹˜ê²Œ ëœë‹¤. ì´ëŠ” í†µì‹  ì†ë„ì˜ ì €í•˜ë¥¼ ì•¼ê¸°í•  ë¿ë§Œ ì•„ë‹ˆë¼ ê¸°ì¡´ì˜ ìœ ì—°í•œ ì‹œìŠ¤í…œì„ ë§Œë“¤ê³ ìí•œ OpenFlowì˜ íƒ„ìƒ ë°°ê²½ê³¼ë„ ê±°ë¦¬ê°€ ìˆê²Œ ëœë‹¤. ë”°ë¼ì„œ, Data Planeì„ í•„ìš”ì— ë”°ë¼ Protocol, Header, Algorithmì„ í¬í•¨í•˜ì—¬ Programmingìœ¼ë¡œ êµ¬í˜„í•˜ì—¬ ì‚¬ìš©í•˜ë©´ ì¢‹ì§€ ì•Šì„ê¹Œë¼ëŠ” ë°œìƒì—ì„œ ì‹œì‘ëœ ê²ƒì´ P4ì´ë‹¤. ê·¸ë ‡ê¸°ì— P4ì˜ full nameì´ **Programming Protocol-independent Packet processors**ì¸ ê²ƒì´ë‹¤.

ì´ë ‡ê²Œ ì‹œì‘ëœ ProjectëŠ” ì ì  ë¹„ëŒ€í•´ì§€ë©°, ì›ë˜ëŠ” Programmable Switchë¥¼ ìœ„í•œ ì–¸ì–´ë¥¼ ëª©ì ìœ¼ë¡œ í–ˆë‹¤ë©´ í˜„ì¬ì—ëŠ” ì—¬ëŸ¬ ëª©ì ì˜ ì¥ë¹„(target)ì„ ì§€ì›í•˜ëŠ” ì–¸ì–´ë¡œ í™•ì¥ë˜ì—ˆë‹¤. ë”°ë¼ì„œ, P4ë¥¼ í•œ ë¬¸ì¥ìœ¼ë¡œ ì •ì˜í•˜ë¼ê³  í•˜ë©´, **Programmable Targetì˜ Data Planeì„ Programmingí•˜ëŠ” ì–¸ì–´**ë¼ê³  í•  ìˆ˜ ìˆë‹¤.

## ë™ì‘ì›ë¦¬

P4ë¥¼ í†µí•œ Programmingì„ í†µí•´ì„œ ìš°ë¦¬ê°€ ìµœì¢…ì ìœ¼ë¡œ ë§Œë“œëŠ” ê²ƒì€ ë‘ ê°€ì§€ì´ë‹¤. ì²«ë²ˆì§¸ë¡œ, `DataPlane runtime`ì€ Tableê³¼ Action ê·¸ë¦¬ê³  ì ì ˆí•œ Alogrithmì„ í†µí•´ ì‹¤ì œë¡œ Packetì„ ì²˜ë¦¬ ë° Forwardingí•  Softwareë¥¼ ì œì‘í•˜ê³ , Control Planeì—ì„œ Data Planeì„ ì œì–´ ë° ì„¤ì •ì„ í•˜ê¸° ìœ„í•œ APIë¥¼ ì œì‘í•œë‹¤.

![p4-overview](/images/p4-overview.jpeg)

ì´ë¥¼ ìœ„í•´ì„œ Targetì„ ì œì‘í•˜ëŠ” VenderëŠ” ë‹¤ìŒê³¼ ê°™ì€ 3ê°€ì§€ë¥¼ ì œì‘í•œë‹¤.

1. P4 Architecture : í•´ë‹¹ Targetì—ì„œ ì‘ë™ì´ ê°€ëŠ¥í•œ Interfaceì™€ extern objectë¥¼ ì •ì˜í•´ë†“ì€ ëª…ì„¸ì„œì´ë‹¤. í›„ì— P4 programmerëŠ” ì´ë¥¼ ì°¸ê³ í•˜ì—¬ í•´ë‹¹ Interfaceì— í•´ë‹¹í•˜ëŠ” Packageë¥¼ ì‘ì„±í•˜ë©´ ëœë‹¤.
2. P4 Compiler : Programmerê°€ ì‘ì„±í•œ Codeë¥¼ Compileí•˜ì—¬ APIì™€ DataPlane Runtimeì„ ìƒì„±í•œë‹¤.
3. Target(Hardware) : ì‹¤ì œë¡œ ë™ì‘í•˜ëŠ” Hardwareì´ë‹¤.

ì´ì œ P4 ê°œë°œì(Programmer)ëŠ” P4 Architectureë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ì—¬ ì›í•˜ëŠ” ë™ì‘ì„ êµ¬í˜„í•œë‹¤. ì´ë¥¼ Compilerë¥¼ í†µí•´ì„œ ì‹¤í–‰ì‹œì¼œ ì •ìƒë™ì‘ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ì—¬ ìµœì¢…ì ìœ¼ë¡œ ë™ì‘í•˜ëŠ” P4 Targetì„ ì™„ì„±í•  ìˆ˜ ìˆë‹¤.

ì´ë ‡ê²Œ ë³´ì•˜ë“¯ì´ P4 Programming ê³¼ì •ì€ Target ë””ìì´ë„ˆ(Vender)ì— ì˜í•´ì„œ ë§Œë“¤ì–´ì§„ ê°ì²´ ì§€í–¥ Architectureì— ê¸°ë°˜í•˜ì—¬ Implementationì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ í•µì‹¬ì´ë‹¤. ì•„ë§ˆ ê°ì²´ ì§€í–¥ì— ìµìˆ™í•˜ë‹¤ë©´ êµ‰ì¥íˆ ì¹œìˆ™í•œ ê°œë…ì¼ ê²ƒì´ë‹¤.

## êµ¬ì„±ìš”ì†Œ

P4 programmingì„ í†µí•´ì„œ ì‹¤ì œë¡œ ì‘ì„±í•˜ê±°ë‚˜ ì‚¬ìš©í•˜ëŠ” êµ¬ì„±ìš”ì†Œë“¤ì€ ì•„ë˜ì™€ ê°™ë‹¤.

- **Architecture** : P4ë¥¼ ì§€ì›í•˜ëŠ” ì§€ì›í•˜ëŠ” Switchì˜ êµ¬ì„±ìš”ì†Œë“¤ì˜ interface(ê°ì²´ì§€í–¥ì—ì„œì˜ interface)ë¥¼ ì‘ì„±í•œ ëª…ì„¸ì„œë¡œ ì´ëŠ” Programmerê°€ ì•„ë‹Œ í•´ë‹¹ Targetì„ ì œì‘í•œ Venderê°€ ì‘ì„±í•œë‹¤. ì´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ P4 ProgrammerëŠ” Implementationì„ ìˆ˜í–‰í•œë‹¤.
- **Header Type** : í•´ë‹¹ Data Planeì—ì„œ ì‚¬ìš©í•  ê°ê°ì˜ Packetì˜ Headerì˜ í˜•íƒœë¥¼ ì˜ë¯¸í•œë‹¤. ì¦‰, Packetì˜ Header ë¶€ë¶„ì„ ì •ì˜í•œ ê²ƒì´ë‹¤.
- **Parser** : ì—°ì†ìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” Packetì—ì„œ Headerë¥¼ ì‹ë³„í•˜ê³  ì¶”ì¶œí•˜ëŠ” ì—­í• ì„ í•œë‹¤.
- **Table** : Programmerì— ì˜í•´ì„œ ì •ì˜ëœ keyì™€ ì´ì— ëŒ€ì‘í•˜ëŠ” Actionì´ ì €ì¥ëœë‹¤. ì´ë¥¼ í†µí•´ì„œ, Routing Table, Flow Lookup Table, ACL ë“±ê³¼ ê°™ì€ ì¼ë°˜ Switchì˜ Tableë„ êµ¬ì„±ì´ ê°€ëŠ¥í•˜ë©°, ë” ë³µì¡í•œ í˜•íƒœì˜ ìƒˆë¡œìš´ Tableì„ êµ¬ì„±í•˜ëŠ” ê²ƒë„ ê°€ëŠ¥í•˜ë‹¤.
- **Action** : Headerì™€ Metadataì— íŠ¹ì •í•œ ì¡°ì‘ì„ ê°€í•  ìˆ˜ ìˆë‹¤.
- **Match-action unit** : ì‹¤ì œë¡œ Tableì„ ì¡°íšŒí•˜ì—¬, Actionì„ ìˆ˜í–‰í•˜ëŠ” Unitìœ¼ë¡œ ë™ì‘ìˆœì„œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
  1. Packetì˜ fieldì™€ metadataë¥¼ í™œìš©í•˜ì—¬ keyë¥¼ ìƒì„±í•œë‹¤.
  2. ìƒì„±í•œ keyë¡œ Tableì—ì„œ ì¡°íšŒ(Lookup)í•œë‹¤.
  3. ì¡°íšŒëœ keyì— ëŒ€ì‘í•˜ëŠ” actionì´ ì¡´ì¬í•œë‹¤ë©´, ì´ë¥¼ ìˆ˜í–‰í•œë‹¤.
- **User-defined metadata** : Programmer(user)ì— ì˜í•´ì„œ ì •ì˜ëœ data êµ¬ì¡°ë¡œ ê° packetì—ì„œ ì¶”ì¶œì´ ê°€ëŠ¥í•˜ë‹¤.
- **Intrinsic metadata** : ê¸°ë³¸ì ìœ¼ë¡œ ì •ì˜ëœ data êµ¬ì¡°ë¡œ ê° packetì—ì„œ ì¶”ì¶œì´ ê°€ëŠ¥í•˜ë‹¤.
- **Extern object** : ì¼ë°˜ì ì¸ Programming Languageì—ì„œ Libraryì™€ ê°™ì€ ì—­í• ì„ í•˜ë©°, P4ê°€ ì‹¤í–‰ë  Hardwareì—ì„œ ì œê³µí•˜ëŠ” ê¸°ëŠ¥ë“¤ì´ ì—¬ê¸°ì— í¬í•¨ëœë‹¤. P4ì—ì„œ ì´ë¥¼ ì´ìš©í•˜ì—¬ Programmingì´ ê°€ëŠ¥í•˜ì§€ë§Œ, ì´ëŠ” P4ë¥¼ ì§€ì›í•˜ëŠ” Hardware Switch ì œì‘ìê°€ ì§€ì •í•˜ëŠ” ê²ƒì´ê¸°ì— P4ë¥¼ í†µí•œ êµ¬í˜„ì€ ë¶ˆê°€ëŠ¥í•˜ë‹¤.
- **Deparser** : Packetì˜ Headerì™€ Payloadë¥¼ ë‹¤ì‹œ ê²°í•©í•˜ì—¬ output portë¡œ ë‚´ë³´ë‚¼ Packetì„ ìƒì„±í•œë‹¤.
- **Control flow** : targetì˜ packet ì²˜ë¦¬ë¥¼ ê¸°ìˆ í•˜ëŠ” í•„ìˆ˜ì ì¸ program ìš”ì†Œì´ë‹¤. Deparsingê³¼ Match-action ë“±ì„ ì´ë¥¼ í†µí•´ì„œ ê¸°ìˆ í•  ìˆ˜ ìˆë‹¤.

## Example

ê°€ì¥ ê¸°ë³¸ì ì¸ Siwtch(Very Simple Switch, **VSS**)ë¥¼ êµ¬í˜„í•˜ë©° P4ì˜ programming ì ˆì°¨ë¥¼ ìµí˜€ë³´ì. ì•„ë˜ ê·¸ë¦¼ì€ VSSë¥¼ ë¶„ì„í•œ ê·¸ë¦¼ì´ë‹¤.

![Very Simple Switch](/images/vss.jpeg)

### Flow

ì´ 3ê°€ì§€ì˜ Flowê°€ ì¡´ì¬í•œë‹¤. í•˜ë‚˜ëŠ” ì¼ë°˜ì ì¸ ë°ì´í„° Packetì„ ì˜ë¯¸í•˜ë©° Targetì˜ **Physical Ethernet**ì„ í†µí•´ì„œ ë“¤ì–´ì˜¨ packetì´ ì´ì— í•´ë‹¹í•œë‹¤. ë˜ ë‹¤ë¥¸ í•˜ë‚˜ì˜ Control Flowë¡œ ëŒ€ê²Œ SDNì˜ Controllerë¥¼ í†µí•´ì„œ ë“¤ì–´ì˜¨ Packetì´ë‹¤. ëŒ€ê²Œ ì´ëŠ” CPUë¥¼ í†µí•´ì„œ ì „ë‹¬ë˜ê¸° ë•Œë¬¸ì— **From CPU**ë¼ê³  í‘œê¸°í•œë‹¤. ë§ˆì§€ë§‰ì€ **Recirculate**ì¸ë° ì´ëŠ” ë™ì¼ Target ë‚´ë¶€ì—ì„œ ì¬ì²˜ë¦¬ë¥¼ ìœ„í•´ì„œ ë‹¤ì‹œ Arbiterë¡œ ì „ë‹¬ëœ Packetì„ ì˜ë¯¸í•œë‹¤. ì´ëŠ” í•œ ë²ˆì˜ ìˆœí™˜ìœ¼ë¡œëŠ” ì œëŒ€ë¡œ ëœ ì²˜ë¦¬ê°€ ì–´ë ¤ìš´ ê²½ìš°ì— ì‚¬ìš©í•œë‹¤.

### Component

ì£¼í™©ìƒ‰ ë°•ìŠ¤ì˜ ìš”ì†ŒëŠ” Hardwareë¡œ ì •ì˜ëœ ìš”ì†Œ(Arbiter, Parser Runtime, Demux/Queue)ë¥¼ ì˜ë¯¸í•˜ê³ , ê²€ì€ ë°•ìŠ¤ì˜ ìš”ì†Œ(Parser, Match-action Pipeline, Deparser)ëŠ” Softwareë¡œ êµ¬í˜„ë˜ëŠ” ìš”ì†Œë¥¼ ì˜ë¯¸í•œë‹¤. ê° ìš”ì†Œë¥¼ ë¨¼ì € ì•Œì•„ë³´ë„ë¡ í•˜ì.

1. **Arbiter**  
    í•œêµ­ì–´ë¡œëŠ” ì¤‘ì¬ìë¼ëŠ” ëœ»ì„ ê°€ì§€ë©°, Inputì„ ì¼ì°¨ì ìœ¼ë¡œ ê°€ê³µí•˜ëŠ” Block(ì¥ì¹˜)ìœ¼ë¡œ ì•„ë˜ì™€ ê°™ì€ ê¸°ëŠ¥ì„ ìˆ˜í–‰í•œë‹¤.
    - ì´ 16ê°œì˜ Portë¥¼ ê°€ì§€ë©°, 3ê°€ì§€ ì¢…ë¥˜ì˜ Inputì„ ì…ë ¥ë°›ëŠ”ë‹¤. (1)Physical Ethernet Input, (2)Control Flow(from CPU), (3)Recirculate Inputì„ ë°›ëŠ”ë‹¤.
    - **Ethernet Inputì¸ ê²½ìš°**, checksumì„ ì¶”ì¶œí•˜ê³  ê²€ì¦í•œë‹¤. ë§Œì•½, ì˜¬ë°”ë¥´ì§€ ì•Šì€ checksumì´ë¼ë©´ packetì´ ë²„ë ¤ì§€ê³ , ì˜¬ë°”ë¥´ë‹¤ë©´ packetì˜ payloadì—ì„œ checksumì„ ì¶”ì¶œí•˜ì—¬ ë‹¤ìŒ ë‹¨ê³„ë¡œ ì „ë‹¬í•œë‹¤.
    - ì—¬ëŸ¬ packetì„ ë™ì‹œì— ìˆ˜ì‹ í•œ ê²½ìš°ì—ëŠ” ì´ë¥¼ schedulingí•˜ëŠ” Algorithmì„ ì‹¤í–‰ì‹œí‚¨ë‹¤.
    - Arbiterê°€ Busy ìƒíƒœì´ê³ , ëŒ€ê¸° queueê°€ ê½‰ ì°¬ ê²½ìš°ì—ëŠ” ë„ì°©í•œ packetì„ Dropí•œë‹¤.
    - packetì„ ë°›ì€ portë¥¼ `inCtrl.inputPort`ì— ì €ì¥í•˜ì—¬, Match-action Pipelineìœ¼ë¡œ ì „ë‹¬í•˜ì—¬ packetì´ ì–´ë””ì„œë¶€í„° ì™”ëŠ”ì§€ë¥¼ markingí•œë‹¤. ì—¬ê¸°ì„œëŠ” Physical Ethernet portëŠ” 0 ~ 7ë²ˆê¹Œì§€ë¥¼ ì˜ë¯¸í•˜ê³ , 13ì€ recirculation port, 14ëŠ” CPU portë¥¼ ì˜ë¯¸í•œë‹¤.
2. **Parser**
   Packetì„ ê°€ê³µí•˜ì—¬ Input Headerë¥¼ ì¶”ì¶œí•˜ê³ , user defined metadataë¥¼ ìƒì„±í•˜ì—¬ ì´ë¥¼ Match-action Pipelineìœ¼ë¡œ ì „ë‹¬í•œë‹¤.
3. **Parser Runtime**
   Parserì™€ í˜‘ë ¥ì„ í•˜ë©° ì‹¤í–‰ë˜ëŠ” ì¥ì¹˜ì´ë‹¤. Parserì— ì •ì˜ëœ actionì— ê¸°ë°˜í•˜ì—¬ Match-action Pipelineìœ¼ë¡œ error codeë¥¼ Match-action Pipelien, packet payloadì— ëŒ€í•œ ì •ë³´(payload ê¸¸ì´ ë“±)ë¥¼ Demuxë¡œ ì „ë‹¬í•œë‹¤.
4. **Match-action Pipeline**
   Parserë¡œ ë¶€í„° ì „ë‹¬ë°›ì€ Input Headerì™€ Parser Runtimeìœ¼ë¡œ ë¶€í„° ë°›ì€ error, Arbiterë¥¼ í†µí•´ ë°›ì€ `inCtrl.inputPort`ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ì—¬ keyë¥¼ êµ¬ì„±í•˜ê³ , ì´ë¥¼ í†µí•´ì„œ Tableì„ ì¡°íšŒí•˜ì—¬ ì ì ˆí•œ Actionì„ ì¡°íšŒí•˜ì—¬ ì‹¤í–‰í•œë‹¤. ì´ë¥¼ í†µí•´ì„œ ê²°ë¡ ì ìœ¼ë¡œ Output Headerì™€ `outCtrl.outputPort`ë¥¼ ìƒì„±í•œë‹¤.
5. **Deparser**
   Deparserì˜ ì—­í• ì€ output Headerë¥¼ ë‹¤ì‹œ ì¬ì¡°ë¦½í•˜ëŠ” ì¥ì¹˜ì´ë‹¤. ì˜¨ì „í•œ header í˜•íƒœë¥¼ ì™„ì„±í•´ì„œ Demuxì—ì„œ Packetì„ ìµœì¢…ìœ¼ë¡œ ìƒì„±í•  ìˆ˜ ìˆë„ë¡ ë•ëŠ”ë‹¤.
6. **Demux/Queue**
   ë°–ìœ¼ë¡œ ì „ë‹¬í•  packetì˜ headerëŠ” Deparserë¡œë¶€í„°, payloadëŠ” Parserë¡œ ë¶€í„° ì „ë‹¬ë°›ì•„ì„œ ì´ë¥¼ ì¬ê²°í•©í•˜ì—¬ ìƒˆë¡œìš´ packetì„ ìƒì„±í•˜ì—¬ ì˜¬ë°”ë¥¸ output portë¡œ ë‚´ë³´ë‚´ëŠ” ì—­í• ì„ í•˜ëŠ” ì¥ì¹˜ì´ë‹¤. output portëŠ” Matc-action Pipelineì˜ `outCtrl.outputPort`ë¥¼ í†µí•´ì„œ ì „ë‹¬ëœë‹¤. ì„¸ë¶€ì ì¸ ë™ì‘ì€ ì•„ë˜ì™€ ê°™ë‹¤.
   - packet ì‚­ì œë¥¼ ì›í•˜ëŠ” ê²½ìš° drop portë¡œ packetì„ ë‚´ë³´ë‚¸ë‹¤.
   - Physical Ethernetìœ¼ë¡œ ë‚˜ê°€ëŠ” packetì¸ ê²½ìš° í•´ë‹¹í•˜ëŠ” output interfaceë¡œ ì „ë‹¬í•œë‹¤. ë§Œì•½, í•´ë‹¹ interfaceê°€ Busy ìƒíƒœë¼ë©´ Queueì— ì €ì¥ëœë‹¤. output interfaceì—ì„œëŠ” packetì˜ checksumì„ ê³„ì‚°í•˜ì—¬ packetì˜ ëì— ë¶™ì—¬ì„œ ë‚´ë³´ë‚¸ë‹¤.
   - CPUë¥¼ í†µí•´ì„œ ì „ë‹¬í•˜ëŠ” Control plane packetì˜ ê²½ìš°ì—ëŠ” Deparserì—ì„œ ìƒì„±ëœ Headerë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³ , original packet ê·¸ëŒ€ë¡œë§Œ ì „ì†¡í•  ìˆ˜ ìˆë‹¤.
   - `outCtrl.outputPort`ê°€ ì˜¬ë°”ë¥´ì§€ ì•Šë‹¤ë©´, í•´ë‹¹ packetì€ dropëœë‹¤.
   - ë§Œì•½, Demuxê°€ Busy ìƒíƒœì´ê³ , queueì— ë¹ˆ ê³µê°„ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´, `outCtrl.outputPort`ë¥¼ ë¬´ì‹œí•˜ê³  packetì„ dropí•œë‹¤.

### Architecture.p4

ì•„ë˜ëŠ” ìœ„ì˜ ë‚´ìš©ì„ ê¸°ë°˜ìœ¼ë¡œ Venderê°€ ì‘ì„±í•œ Architectureì˜ ë‚´ìš©ì´ë‹¤.

```c++
// File: "very_simple_switch_model.p4"
// Core Libraryë¡œ packet_inê³¼ packet_outì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ í•„ìš”í•˜ë‹¤.
#include <core.p4> 

// PortëŠ” 4bitë¡œ í‘œí˜„ ê°€ëŠ¥í•˜ë‹¤.
typedef bit<4> PortId;

// 4 width(bit)ë¡œ í‘œí˜„í•˜ëŠ” 8, ìƒëµí•´ì„œ 8ë§Œ ì¨ë„ ë¬´ë°©
const PortId REAL_PORT_COUNT = 4w8; 

// Input packetì— ë™ë°˜ë˜ëŠ” metadataë¡œ Match-action Pipelineì—ì„œ ì‚¬ìš©ëœë‹¤.
struct InControl {
  PortId inputPort;
}

// Special Input Port
const PortId RECIRCULATE_IN_PORT = 0xD;
const PortId CPU_IN_PORT = 0xE;

// Match-action Pipelineì—ì„œ ìƒì„±ë˜ëŠ” Output packetì— ë™ë°˜ë˜ëŠ” metadata
struct OutControl {
  PortId outputPort;
}

// Special Output Port
const PortId DROP_PORT = 0xF;
const PortId CPU_OUT_PORT = 0xE;
const PortId RECIRCULATE_OUT_PORT = 0xD;

// ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” HëŠ” headerë¡œ programmerì— ì˜í•´ì„œ ì •ì˜ëœë‹¤.

/**
 * Parse
 * @param b             input_packet
 * @param parsedHeaders headers contructed by parser
 */
parser Parser<H>(packet_in b, out H parsedHeaders);


/**
 * Match-action Pipeline
 * @param headers     Parserë¡œ ë¶€í„° ë°›ê³ , Deparserì—ê²Œ ë³´ë‚¸ë‹¤.
 * @param parseError  parsing ë„ì¤‘ì— ìƒì„±ëœ error
 * @param inCtrl      packetì„ ë°›ì€ input portë¥¼ í¬í•¨í•œ ì •ë³´
 * @param outCtrl     packetì„ ë³´ë‚¼ output portë¥¼ í¬í•¨í•œ ì •ë³´
 */
control Pipe<H>(inout H headers, 
                in error parseError, 
                in InControl inCtrl, 
                out OutControl outCtrl);

/**
 * Deparser
 * @param outputHeaders programmerì— ì˜í•´ì„œ ì •ì˜ëœ output header
 * @param b             ë°–ìœ¼ë¡œ ë‚´ë³´ë‚¼ packet
 */
control Deparser<H>(inout H outputHeaders, packet_out b);

/**
 * Top level Packet
 */
packege VSS<H>(parse<H> p, Pipe<H> map, Deparser<H> d);

/**
 * Extern block
 * ì´ëŠ” Target venderê°€ ë‚´ë¶€ì ìœ¼ë¡œ êµ¬í˜„í•œ blockì´ë‹¤.
 * programmerëŠ” ì•„ë˜ ì„ ì–¸ëœ blockì„ ììœ ë¡­ê²Œ ì‚¬ìš©ê°€ëŠ¥í•˜ë‹¤.
 */
extern Checksum16 {
  Checksum16();
  void clear();
  void update<T>(in T data);
  void remove<T>(in T data);
  bit<16> get();
}
```

ì´ë ‡ê²Œ ì‘ì„±ëœ architectureë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ì—¬ programmerëŠ” ì½”ë“œ ì‘ì„±ì´ ê°€ëŠ¥í•˜ë‹¤.

### Programming.p4

ë¨¼ì € ì–´ë–¤ ë™ì‘ì„ ìˆ˜í–‰í•˜ê²Œ í• ì§€ë¥¼ ì •ì˜í•˜ì.

<!-- TODO ì±„ìš°ê¸° -->
1. Ethernet/IPv4 headerë¥¼ í™œìš©í•˜ì—¬ Forwardingì„ ìˆ˜í–‰í•  ê²ƒì´ë‹¤.
2. CheckSumì„ í™•ì¸í•˜ì—¬ ì •ë‹¹ì„± ì—¬ë¶€ë¥¼ í™•ì¸í•œë‹¤.
3. TTL ê°’ì„ í™•ì¸í•˜ì—¬ ì •ë‹¹ì„± ì—¬ë¶€ë¥¼ í™•ì¸í•œë‹¤.
4. Destination IPv4ë¥¼ í™œìš©í•˜ì—¬ Next Hopì˜ IPv4ë¥¼ ì°¾ëŠ”ë‹¤.
5. ì¶”ì¶œí–ˆë˜ Packetì˜ Headerë¥¼ ë‹¤ì‹œ Ethernet/IPv4ë¡œ ì¬êµ¬ì„±í•œë‹¤.

ì´ë¥¼ ì½”ë“œë¡œì¨ êµ¬í˜„í•˜ë©´ ì•„ë˜ì™€ ê°™ë‹¤.

```c++
// File: "very_simple_switch_impl.p4"
# include <core.p4>
# include "very_simple_switch_model.p4"

// í•´ë‹¹ programì€ packetì—ì„œ IPv4ì™€ 
// ethernet headerë¥¼ ê°€ì ¸ì™€
// destination IPì— ê¸°ë°˜í•˜ì—¬ packetì„ 
// forwardingí•˜ëŠ” ê²ƒì„ ëª©ì ìœ¼ë¡œ í•œë‹¤.

typedef bit<48> EthernetAddress;
typedef bit<32> IPv4Address;

// Standard Ethernet header
header Ethernet_h {
  EthernetAddress dstAddr;
  EthernetAddress srcAddr;
  bit<16>         etherType;
}

// IPv4 header (without option)
header IPv4_h {
  bit<4>      version;
  bit<4>      ihl;
  bit<8>      diffserv;
  bit<16>     totalLen;
  bit<16>     identification;
  bit<3>      flags;
  bit<13>     fragOffset;
  bit<8>      ttl;
  bit<8>      protocol;
  bit<16>     hdrChecksum;
  IPv4Address srcAddr;
  IPv4Address dstAddr;
}

// packetì—ì„œ ì¶”ì¶œí•œ headerí˜•íƒœì˜ êµ¬ì¡°ì²´
struct Parsed_packet {
  Ethernet_h ethernet;
  IPv4_h     ip;
}

/* Parser Section */

// Programmerì— ì˜í•´ì„œ ì •ì˜ëœ errorë¡œ 
// parsing ë„ì¤‘ì— ì´ë¥¼ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤.
error {
  IPv4OptionsNotSupported,
  IPv4IncorrectVersion,
  IPv4ChecksumError
}

/**
 * @param b ë“¤ì–´ì˜¤ëŠ” packet
 * @param p parsingí•´ì„œ ë‚˜ê°ˆ packet Header
 */
parser TopParser(packet_in b, out Parsed_packet p) {
  Checksum16() ck; // checksum blockì„ instantiating

  state start {
    b.extract(p.ethernet); // pì˜ ethernet ë¶€ë¶„ì„ bì—ì„œ ì¶”ì¶œ
    transition select(p.ethernet.etherType) {
      0x800: parse_ipv4; // forward packet to parse_ipv4
      // default ruleì´ ì—†ê¸° ë•Œë¬¸ì— 0x800(ethernet)ì„ 
      // ì œì™¸í•œ packetì„ ëª¨ë‘ rejected ëœë‹¤.
    } 
  }

  state parse_ipv4 {
    b.extract(p.ip);
    verify(p.ip.version == 4w4, error.IPv4IncorrectVersion);
    verify(p.ip.ihl == 4w5, error.IPv4OptionsNotSupported);
    ck.clear();
    ck.update(p.ip);
    verify(ck.get() == 16w0, error.IPv4ChecksumError);
    transition accept; // ë‹¤ìŒ blockìœ¼ë¡œ outì„ forwarding
  }
}

/* Match-action Pipeline Section */

control TopPipe(inout Parsed_packet headers, 
                in error parseError,
                in InControl inCtrl,
                out OutControl outCtrl) {
  IPv4Address nextHop;

  action Drop_action() { outCtrl.outputPort = DROP_PORT; }

  action Set_nhop(IPv4Address ipv4_dest, PortId port) {
    nextHop = ipv4_dest;
    headers.ip.ttl = headers.ip.ttl - 1;
    outCtrl.outputPort = port;
  }

  table ipv4_match {
    // lpm : longest-prefix match
    key = { headers.ip.dstAddr: lpm; }
    // í•´ë‹¹ í…Œì´ë¸”ì—ì„œ keyì— ëŒ€ì‘í•  ìˆ˜ ìˆëŠ” actionì˜ listì´ë‹¤. 
    // í•´ë‹¹ tableì€ í›„ì— controllerì— ì˜í•´ì„œ ì±„ì›Œì§„ë‹¤.
    // ì¦‰, í…Œì´ë¸”ì€ p4 prgrammingì„ í†µí•´ì„œ ì±„ìš°ëŠ” ê²ƒì€ ì•„ë‹ˆë‹¤.
    actions = {
      Drop_action;
      Set_nhop;
    }
    size = 1024;
    default_action = Drop_action;
  }

  action Send_to_cpu() {
    outCtrl.outputPort = CPU_OUT_PORT;
  }

  table check_ttl {
    // exact : ì •í™•íˆ ì¼ì¹˜í•˜ëŠ”ì§€ ì—¬ë¶€ë¥¼ í™•ì¸
    key = { headers.ip.ttl: exact; }
    actions = { 
      Send_to_cpu;
      NoAction;
    }
    const default_action = NoAction;
  }

  action Set_dmac(EthernetAddress dmac) {
    headers.ethernet.dstAddr = dmac;
  }
  
  table dmac {
    key = { NextHop: exact; }
    actions = {
      Drop_action;
      Set_dmac;
    }
    size = 1024;
    default_action = Drop_action;
  }

  action Set_smac(EthernetAddress smac) {
    headers.ethernet.srcAddr = smac;
  }
  
  table smac {
    key = { outCtrl.outputPort: exact; }
    actions = {
      Drop_action;
      Set_smac;
    }
    size = 16;
    default_action = Drop_action;
  }

  apply {
    if (parseError != error.NoError) {
      Drop_actrion();
      return;
    }

    ipv4_match.apply();
    if (outCtrl.outputPort == DROP_PORT) return;

    check_ttl.apply();
    if (outCtrl.outputPort == CPU_OUT_PORT) return;

    dmac.apply();
    if (outCtrl.outputPort == DROP_PORT) return;

    smac.apply();
  }
}

/* Deparser Section */

control TopDeparser(inout Parsed_packet p, packet_out b) {
  Checksum16() ck;
  apply {
    b.emit(p.ethernet);
    if (p.ip.isValid()) {
      ck.clear();
      p.ip.hdrChecksum = 16w0;
      ck.update(p.ip);
      p.ip.hdrChecksum = ck.get();
    }
    b.emit(p.ip);
  }
}

// VSS packetë¥¼ Instantiate
VSS(TopParser(), TopPipe(), TopDeparser()) main;
```

ì—¬ê¸°ê¹Œì§€ê°€ ê¸°ë³¸ì ì¸ P4ì— ëŒ€í•œ ì„¤ëª…ì´ë‹¤. í›„ì— ì „ë°˜ì ì¸ ë¬¸ë²•ê³¼ ì‘ì„±ë²•ì— ëŒ€í•œ ê°€ì´ë“œë¥¼ ì‘ì„±í•˜ë„ë¡ í•˜ê² ë‹¤.
