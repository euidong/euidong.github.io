---
slug: "p4"
title: "P4"
date: "2022-06-09 17:29"
category: "Network"
tags: ["SDN", "P4", "ProgrammableSwitch", "DataPlane", "OpenFlow"]
thumbnailSrc: "/images/p4-icon.png"
---

## Reference

- Thumbnail: [🔗 P4 공식홈페이지](https://p4.org)
- [P4 specification](https://p4.org/p4-spec/docs/P4-16-v1.2.2.pdf)

## History

예전 Posting에서 [🔗 OpenFlow](/posts/openflow)와 [🔗 SDN](/posts/sdn)에 대해서 다룬 적이 있다. 이때, P4에 대해서 간략히 알아보고 지나갔었는데, 해당 Posting에서는 이를 자세히 다룰 것이다. 만약, 이에 대한 개념이 잡혀있지 않다면, 해당 Posting을 이해하기 어렵다. 따라서, SDN과 OpenFlow 관련 Posting을 먼저 읽고 다시 돌아오기를 바란다.

먼저, P4의 초기 시작은 OpenFlow의 성장과 연관이 있다. OpenFlow는 기존의 Switch를 Data Plane과 Control Plane으로 나누어 Control Plane을 외부 Server(Controller)로 옮기고 이들은 OpenFlow Protocol을 통해서 Switch의 Data Palen을 제어하고자 했다. OpenFlow의 사용이 가속화되면서 계속해서 새로운 version이 update되었고, 1.0에서 1.5까지 도달하게 되었다. 그런데, 여러 Usecase와 Protocol을 지원하기 위해서 점점 비대해지는 Header를 마주치게 된다. 이는 통신 속도의 저하를 야기할 뿐만 아니라 기존의 유연한 시스템을 만들고자한 OpenFlow의 탄생 배경과도 거리가 있게 된다. 따라서, Data Plane을 필요에 따라 Protocol, Header, Algorithm을 포함하여 Programming으로 구현하여 사용하면 좋지 않을까라는 발상에서 시작된 것이 P4이다. 그렇기에 P4의 full name이 **Programming Protocol-independent Packet processors**인 것이다.

이렇게 시작된 Project는 점점 비대해지며, 원래는 Programmable Switch를 위한 언어를 목적으로 했다면 현재에는 여러 목적의 장비(target)을 지원하는 언어로 확장되었다. 따라서, P4를 한 문장으로 정의하라고 하면, **Programmable Target의 Data Plane을 Programming하는 언어**라고 할 수 있다.

## 동작원리

P4를 통한 Programming을 통해서 우리가 최종적으로 만드는 것은 두 가지이다. 첫번째로, `DataPlane runtime`은 Table과 Action 그리고 적절한 Alogrithm을 통해 실제로 Packet을 처리 및 Forwarding할 Software를 제작하고, Control Plane에서 Data Plane을 제어 및 설정을 하기 위한 API를 제작한다.

![p4-overview](/images/p4-overview.jpeg)

이를 위해서 Target을 제작하는 Vender는 다음과 같은 3가지를 제작한다.

1. P4 Architecture : 해당 Target에서 작동이 가능한 Interface와 extern object를 정의해놓은 명세서이다. 후에 P4 programmer는 이를 참고하여 해당 Interface에 해당하는 Package를 작성하면 된다.
2. P4 Compiler : Programmer가 작성한 Code를 Compile하여 API와 DataPlane Runtime을 생성한다.
3. Target(Hardware) : 실제로 동작하는 Hardware이다.

이제 P4 개발자(Programmer)는 P4 Architecture를 기반으로 하여 원하는 동작을 구현한다. 이를 Compiler를 통해서 실행시켜 정상동작 여부를 확인하여 최종적으로 동작하는 P4 Target을 완성할 수 있다.

이렇게 보았듯이 P4 Programming 과정은 Target 디자이너(Vender)에 의해서 만들어진 객체 지향 Architecture에 기반하여 Implementation을 수행하는 것이 핵심이다. 아마 객체 지향에 익숙하다면 굉장히 친숙한 개념일 것이다.

## 구성요소

P4 programming을 통해서 실제로 작성하거나 사용하는 구성요소들은 아래와 같다.

- **Architecture** : P4를 지원하는 지원하는 Switch의 구성요소들의 interface(객체지향에서의 interface)를 작성한 명세서로 이는 Programmer가 아닌 해당 Target을 제작한 Vender가 작성한다. 이를 기반으로 P4 Programmer는 Implementation을 수행한다.
- **Header Type** : 해당 Data Plane에서 사용할 각각의 Packet의 Header의 형태를 의미한다. 즉, Packet의 Header 부분을 정의한 것이다.
- **Parser** : 연속으로 들어오는 Packet에서 Header를 식별하고 추출하는 역할을 한다.
- **Table** : Programmer에 의해서 정의된 key와 이에 대응하는 Action이 저장된다. 이를 통해서, Routing Table, Flow Lookup Table, ACL 등과 같은 일반 Switch의 Table도 구성이 가능하며, 더 복잡한 형태의 새로운 Table을 구성하는 것도 가능하다.
- **Action** : Header와 Metadata에 특정한 조작을 가할 수 있다.
- **Match-action unit** : 실제로 Table을 조회하여, Action을 수행하는 Unit으로 동작순서는 다음과 같다.
  1. Packet의 field와 metadata를 활용하여 key를 생성한다.
  2. 생성한 key로 Table에서 조회(Lookup)한다.
  3. 조회된 key에 대응하는 action이 존재한다면, 이를 수행한다.
- **User-defined metadata** : Programmer(user)에 의해서 정의된 data 구조로 각 packet에서 추출이 가능하다.
- **Intrinsic metadata** : 기본적으로 정의된 data 구조로 각 packet에서 추출이 가능하다.
- **Extern object** : 일반적인 Programming Language에서 Library와 같은 역할을 하며, P4가 실행될 Hardware에서 제공하는 기능들이 여기에 포함된다. P4에서 이를 이용하여 Programming이 가능하지만, 이는 P4를 지원하는 Hardware Switch 제작자가 지정하는 것이기에 P4를 통한 구현은 불가능하다.
- **Deparser** : Packet의 Header와 Payload를 다시 결합하여 output port로 내보낼 Packet을 생성한다.
- **Control flow** : target의 packet 처리를 기술하는 필수적인 program 요소이다. Deparsing과 Match-action 등을 이를 통해서 기술할 수 있다.

## Example

가장 기본적인 Siwtch(Very Simple Switch, **VSS**)를 구현하며 P4의 programming 절차를 익혀보자. 아래 그림은 VSS를 분석한 그림이다.

![Very Simple Switch](/images/vss.jpeg)

### Flow

총 3가지의 Flow가 존재한다. 하나는 일반적인 데이터 Packet을 의미하며 Target의 **Physical Ethernet**을 통해서 들어온 packet이 이에 해당한다. 또 다른 하나의 Control Flow로 대게 SDN의 Controller를 통해서 들어온 Packet이다. 대게 이는 CPU를 통해서 전달되기 때문에 **From CPU**라고 표기한다. 마지막은 **Recirculate**인데 이는 동일 Target 내부에서 재처리를 위해서 다시 Arbiter로 전달된 Packet을 의미한다. 이는 한 번의 순환으로는 제대로 된 처리가 어려운 경우에 사용한다.

### Component

주황색 박스의 요소는 Hardware로 정의된 요소(Arbiter, Parser Runtime, Demux/Queue)를 의미하고, 검은 박스의 요소(Parser, Match-action Pipeline, Deparser)는 Software로 구현되는 요소를 의미한다. 각 요소를 먼저 알아보도록 하자.

1. **Arbiter**  
    한국어로는 중재자라는 뜻을 가지며, Input을 일차적으로 가공하는 Block(장치)으로 아래와 같은 기능을 수행한다.
    - 총 16개의 Port를 가지며, 3가지 종류의 Input을 입력받는다. (1)Physical Ethernet Input, (2)Control Flow(from CPU), (3)Recirculate Input을 받는다.
    - **Ethernet Input인 경우**, checksum을 추출하고 검증한다. 만약, 올바르지 않은 checksum이라면 packet이 버려지고, 올바르다면 packet의 payload에서 checksum을 추출하여 다음 단계로 전달한다.
    - 여러 packet을 동시에 수신한 경우에는 이를 scheduling하는 Algorithm을 실행시킨다.
    - Arbiter가 Busy 상태이고, 대기 queue가 꽉 찬 경우에는 도착한 packet을 Drop한다.
    - packet을 받은 port를 `inCtrl.inputPort`에 저장하여, Match-action Pipeline으로 전달하여 packet이 어디서부터 왔는지를 marking한다. 여기서는 Physical Ethernet port는 0 ~ 7번까지를 의미하고, 13은 recirculation port, 14는 CPU port를 의미한다.
2. **Parser**
   Packet을 가공하여 Input Header를 추출하고, user defined metadata를 생성하여 이를 Match-action Pipeline으로 전달한다.
3. **Parser Runtime**
   Parser와 협력을 하며 실행되는 장치이다. Parser에 정의된 action에 기반하여 Match-action Pipeline으로 error code를 Match-action Pipelien, packet payload에 대한 정보(payload 길이 등)를 Demux로 전달한다.
4. **Match-action Pipeline**
   Parser로 부터 전달받은 Input Header와 Parser Runtime으로 부터 받은 error, Arbiter를 통해 받은 `inCtrl.inputPort`를 기반으로 하여 key를 구성하고, 이를 통해서 Table을 조회하여 적절한 Action을 조회하여 실행한다. 이를 통해서 결론적으로 Output Header와 `outCtrl.outputPort`를 생성한다.
5. **Deparser**
   Deparser의 역할은 output Header를 다시 재조립하는 장치이다. 온전한 header 형태를 완성해서 Demux에서 Packet을 최종으로 생성할 수 있도록 돕는다.
6. **Demux/Queue**
   밖으로 전달할 packet의 header는 Deparser로부터, payload는 Parser로 부터 전달받아서 이를 재결합하여 새로운 packet을 생성하여 올바른 output port로 내보내는 역할을 하는 장치이다. output port는 Matc-action Pipeline의 `outCtrl.outputPort`를 통해서 전달된다. 세부적인 동작은 아래와 같다.
   - packet 삭제를 원하는 경우 drop port로 packet을 내보낸다.
   - Physical Ethernet으로 나가는 packet인 경우 해당하는 output interface로 전달한다. 만약, 해당 interface가 Busy 상태라면 Queue에 저장된다. output interface에서는 packet의 checksum을 계산하여 packet의 끝에 붙여서 내보낸다.
   - CPU를 통해서 전달하는 Control plane packet의 경우에는 Deparser에서 생성된 Header를 사용하지 않고, original packet 그대로만 전송할 수 있다.
   - `outCtrl.outputPort`가 올바르지 않다면, 해당 packet은 drop된다.
   - 만약, Demux가 Busy 상태이고, queue에 빈 공간이 존재하지 않는다면, `outCtrl.outputPort`를 무시하고 packet을 drop한다.

### Architecture.p4

아래는 위의 내용을 기반으로 Vender가 작성한 Architecture의 내용이다.

```c++
// File: "very_simple_switch_model.p4"
// Core Library로 packet_in과 packet_out을 사용하기 위해 필요하다.
#include <core.p4> 

// Port는 4bit로 표현 가능하다.
typedef bit<4> PortId;

// 4 width(bit)로 표현하는 8, 생략해서 8만 써도 무방
const PortId REAL_PORT_COUNT = 4w8; 

// Input packet에 동반되는 metadata로 Match-action Pipeline에서 사용된다.
struct InControl {
  PortId inputPort;
}

// Special Input Port
const PortId RECIRCULATE_IN_PORT = 0xD;
const PortId CPU_IN_PORT = 0xE;

// Match-action Pipeline에서 생성되는 Output packet에 동반되는 metadata
struct OutControl {
  PortId outputPort;
}

// Special Output Port
const PortId DROP_PORT = 0xF;
const PortId CPU_OUT_PORT = 0xE;
const PortId RECIRCULATE_OUT_PORT = 0xD;

// 공통으로 사용되는 H는 header로 programmer에 의해서 정의된다.

/**
 * Parse
 * @param b             input_packet
 * @param parsedHeaders headers contructed by parser
 */
parser Parser<H>(packet_in b, out H parsedHeaders);


/**
 * Match-action Pipeline
 * @param headers     Parser로 부터 받고, Deparser에게 보낸다.
 * @param parseError  parsing 도중에 생성된 error
 * @param inCtrl      packet을 받은 input port를 포함한 정보
 * @param outCtrl     packet을 보낼 output port를 포함한 정보
 */
control Pipe<H>(inout H headers, 
                in error parseError, 
                in InControl inCtrl, 
                out OutControl outCtrl);

/**
 * Deparser
 * @param outputHeaders programmer에 의해서 정의된 output header
 * @param b             밖으로 내보낼 packet
 */
control Deparser<H>(inout H outputHeaders, packet_out b);

/**
 * Top level Packet
 */
packege VSS<H>(parse<H> p, Pipe<H> map, Deparser<H> d);

/**
 * Extern block
 * 이는 Target vender가 내부적으로 구현한 block이다.
 * programmer는 아래 선언된 block을 자유롭게 사용가능하다.
 */
extern Checksum16 {
  Checksum16();
  void clear();
  void update<T>(in T data);
  void remove<T>(in T data);
  bit<16> get();
}
```

이렇게 작성된 architecture를 기반으로 하여 programmer는 코드 작성이 가능하다.

### Programming.p4

먼저 어떤 동작을 수행하게 할지를 정의하자.

<!-- TODO 채우기 -->
1. Ethernet/IPv4 header를 활용하여 Forwarding을 수행할 것이다.
2. CheckSum을 확인하여 정당성 여부를 확인한다.
3. TTL 값을 확인하여 정당성 여부를 확인한다.
4. Destination IPv4를 활용하여 Next Hop의 IPv4를 찾는다.
5. 추출했던 Packet의 Header를 다시 Ethernet/IPv4로 재구성한다.

이를 코드로써 구현하면 아래와 같다.

```c++
// File: "very_simple_switch_impl.p4"
# include <core.p4>
# include "very_simple_switch_model.p4"

// 해당 program은 packet에서 IPv4와 
// ethernet header를 가져와
// destination IP에 기반하여 packet을 
// forwarding하는 것을 목적으로 한다.

typedef bit<48> EthernetAddress;
typedef bit<32> IPv4Address;

// Standard Ethernet header
header Ethernet_h {
  EthernetAddress dstAddr;
  EthernetAddress srcAddr;
  bit<16>         etherType;
}

// IPv4 header (without option)
header IPv4_h {
  bit<4>      version;
  bit<4>      ihl;
  bit<8>      diffserv;
  bit<16>     totalLen;
  bit<16>     identification;
  bit<3>      flags;
  bit<13>     fragOffset;
  bit<8>      ttl;
  bit<8>      protocol;
  bit<16>     hdrChecksum;
  IPv4Address srcAddr;
  IPv4Address dstAddr;
}

// packet에서 추출한 header형태의 구조체
struct Parsed_packet {
  Ethernet_h ethernet;
  IPv4_h     ip;
}

/* Parser Section */

// Programmer에 의해서 정의된 error로 
// parsing 도중에 이를 발생시킬 수 있다.
error {
  IPv4OptionsNotSupported,
  IPv4IncorrectVersion,
  IPv4ChecksumError
}

/**
 * @param b 들어오는 packet
 * @param p parsing해서 나갈 packet Header
 */
parser TopParser(packet_in b, out Parsed_packet p) {
  Checksum16() ck; // checksum block을 instantiating

  state start {
    b.extract(p.ethernet); // p의 ethernet 부분을 b에서 추출
    transition select(p.ethernet.etherType) {
      0x800: parse_ipv4; // forward packet to parse_ipv4
      // default rule이 없기 때문에 0x800(ethernet)을 
      // 제외한 packet을 모두 rejected 된다.
    } 
  }

  state parse_ipv4 {
    b.extract(p.ip);
    verify(p.ip.version == 4w4, error.IPv4IncorrectVersion);
    verify(p.ip.ihl == 4w5, error.IPv4OptionsNotSupported);
    ck.clear();
    ck.update(p.ip);
    verify(ck.get() == 16w0, error.IPv4ChecksumError);
    transition accept; // 다음 block으로 out을 forwarding
  }
}

/* Match-action Pipeline Section */

control TopPipe(inout Parsed_packet headers, 
                in error parseError,
                in InControl inCtrl,
                out OutControl outCtrl) {
  IPv4Address nextHop;

  action Drop_action() { outCtrl.outputPort = DROP_PORT; }

  action Set_nhop(IPv4Address ipv4_dest, PortId port) {
    nextHop = ipv4_dest;
    headers.ip.ttl = headers.ip.ttl - 1;
    outCtrl.outputPort = port;
  }

  table ipv4_match {
    // lpm : longest-prefix match
    key = { headers.ip.dstAddr: lpm; }
    // 해당 테이블에서 key에 대응할 수 있는 action의 list이다. 
    // 해당 table은 후에 controller에 의해서 채워진다.
    // 즉, 테이블은 p4 prgramming을 통해서 채우는 것은 아니다.
    actions = {
      Drop_action;
      Set_nhop;
    }
    size = 1024;
    default_action = Drop_action;
  }

  action Send_to_cpu() {
    outCtrl.outputPort = CPU_OUT_PORT;
  }

  table check_ttl {
    // exact : 정확히 일치하는지 여부를 확인
    key = { headers.ip.ttl: exact; }
    actions = { 
      Send_to_cpu;
      NoAction;
    }
    const default_action = NoAction;
  }

  action Set_dmac(EthernetAddress dmac) {
    headers.ethernet.dstAddr = dmac;
  }
  
  table dmac {
    key = { NextHop: exact; }
    actions = {
      Drop_action;
      Set_dmac;
    }
    size = 1024;
    default_action = Drop_action;
  }

  action Set_smac(EthernetAddress smac) {
    headers.ethernet.srcAddr = smac;
  }
  
  table smac {
    key = { outCtrl.outputPort: exact; }
    actions = {
      Drop_action;
      Set_smac;
    }
    size = 16;
    default_action = Drop_action;
  }

  apply {
    if (parseError != error.NoError) {
      Drop_actrion();
      return;
    }

    ipv4_match.apply();
    if (outCtrl.outputPort == DROP_PORT) return;

    check_ttl.apply();
    if (outCtrl.outputPort == CPU_OUT_PORT) return;

    dmac.apply();
    if (outCtrl.outputPort == DROP_PORT) return;

    smac.apply();
  }
}

/* Deparser Section */

control TopDeparser(inout Parsed_packet p, packet_out b) {
  Checksum16() ck;
  apply {
    b.emit(p.ethernet);
    if (p.ip.isValid()) {
      ck.clear();
      p.ip.hdrChecksum = 16w0;
      ck.update(p.ip);
      p.ip.hdrChecksum = ck.get();
    }
    b.emit(p.ip);
  }
}

// VSS packet를 Instantiate
VSS(TopParser(), TopPipe(), TopDeparser()) main;
```

여기까지가 기본적인 P4에 대한 설명이다. 후에 전반적인 문법과 작성법에 대한 가이드를 작성하도록 하겠다.
