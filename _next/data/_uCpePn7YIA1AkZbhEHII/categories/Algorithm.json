{"pageProps":{"posts":[{"content":"우리가 알고리즘을 생각할 때, 가장 먼저 떠올릴 수 있는 방법 중에 하나입니다. 가장 기본적인 알고리즘이기 때문에, 굳이 설명을 하지 않아도 자연스럽게 채득하는 경우가 대부분이지만, 사고의 틀을 정하여 더 빠르게 답을 찾을 수 있습니다.\n\nBrute Force를 직접적으로 번역하면, 이는 \"무차별  대입\"정도로 생각할 수 있습니다. 이는 여러 가지의 경우의 수에서 최적의 답이 한 개 이상 존재할 때, 모든 경우의 수를 하나하나 대입해보면서, 정답이 맞는지를 확인하는 방식입니다. 즉, 가능한 모든 경우를 만들고, 그 후에 이것이 정답인지를 계속해서 확인하는 과정이 알고리즘의 핵심입니다.\n\n가장 흔한 예시가 해커들이 특정 유저의 password를 알아내기 위해서 모든 경우의 수를 대입하여 확인하는 것이 있습니다.\n\n## **해결 방법**\n\n이 알고리즘의 구현 순서는 다음과 같습니다.\n\n1.  모든 경우의 수를 헤아린다.\n2.  하나의 경우의 수를 갖고 하는 연산의 횟수를 헤아린다.\n3.  해당 알고리즘이 시간 내에 작동할 수 있는지 확인한다.  \n    대게, 1초동안 할 수 있는 연산은 대략 1억회라고 가정하면 쉽습니다.\n4.  알고리즘을 직접 구현한다.\n\n## **대표 예시**\n\n모든 경우의 수를 확인하는 문제가 굉장히 많기 때문에, 순열/조합/부분집합 문제가 굉장히 많습니다. 고등학교 시절 C, P로 경우의 수를 푸는 문제를 굉장히 많이 풀었다면, 아마 쉽게 할 수 있을 것입니다.\n\n일단 순열 조합을 가장 효율적으로 구현하는 방법에 대해서, 일단 정리를 해보겠습니다.\n\n### **1\\. 순열(Permutation)**\n\n```\ndef permutation_helper(k, arr=[], prev=[]):\n    if len(prev) == k:\n        return [prev]\n    ss = []\n    for idx in range(len(arr)):\n        ss += permutation_helper(k, arr[:idx] + arr[idx+1:], prev + [arr[idx]])\n    return ss\n\n\ndef permutation(n, k):\n    arr = [i for i in range(1, n+1)]\n    return permutation_helper(k, arr, [])\n    \nprint(permutation(5, 2))\nprint(permutation_helper(2, [1,2,3,4,5], []))\n```\n\n### **2\\. 조합(Combination)**\n\n```\ndef combination_helper(k, arr=[], prev=[]):\n    if len(prev) == k:\n        return [prev]\n    ss = []\n    for idx in range(len(arr)):\n        ss += combination_helper(k, arr[idx+1:], prev + [arr[idx]])\n    return ss\n\n\ndef combination(n, k):\n    arr = [i for i in range(1, n+1)]\n    return combination_helper(k, arr, [])\n\nprint(combination(5, 2))\nprint(combination_helper(2, [1,2,3,4,5], []))\n```\n\n### **3\\. 부분집합(Subset)**\n\n```\ndef subset_helper(k, arr=[], prev=[]):\n    if len(prev) == k:\n        return []\n    ss = []\n    for idx in range(len(arr)):\n        ss.append(prev + [arr[idx]])\n        ss += subset_helper(k, arr[idx+1:], prev + [arr[idx]])\n    return ss\n\n\ndef subset(n, k):\n    arr = [i for i in range(1, n+1)]\n    return subset_helper(k, arr, [])\n\nprint(subset(5, 2))\nprint(subset_helper(2, [1,2,3,4,5], []))\n```","slug":"brute-force","title":"Brute Force","category":"Algorithm","tags":["BruteForce","순열","조합","부분 집합"],"date":"2022년 4월 14일 13:51","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"## DFS(Depth First Search)\nGraph의 탐색에서 가장 기본이 되는 방법입니다. 한 점에서 연결된 다른 점으로 이동을 하면서, 모든 연결된 점을 순화하는 것을 목표로 가진다고 가정해봅시다. 이때, 정점을 고르는 방식에 따라서, DFS, BFS로 나눕니다. DFS에서는 자신과 연결된 정점 중에서 하나를 선택하고 이동한 뒤에 해당 점에서 다시 연결된 지점을 찾아서 이동합니다. 즉, 바로 지금 뽑은 점에 인접해있는 지점이 이전에 인접해있던 지점보다 가중치가 높다는 것입니다. 이를 모두 진행하고도 답을 찾을 수 없다면, 이제 이전 시점으로 돌아와서 다시 작업을 재개하는 방식입니다.\n\n이를 구현하기 위해서는 `Stack`이 가장 중요합니다. 이전의 연결되었던 점보다 현재 연결된 점이 더 중요하기 때문에, 현재가 우선순위가 높지만, 후에 이를 다시 찾아와야 하기 때문에, 이를 저장하기 위한 자료구조가 필요한데 이것이 `Stack`이 되는 것입니다.\n\n따라서, 이를 직접 구현해보면 다음과 같습니다.\n```python\nadj = [\n  [2,3],\n  [3],\n  [0,3],\n  [0,1,2]\n]\n\nvisited = [False] * 4\nstack = [(0, visited)]\nwhile len(stack) > 0:\n  cur, visited = stack.pop(-1)\n  visited[cur] = True\n  for next in adj[cur]:\n    if visited[next] === False:\n      stack.append((next, visited))\n```\n또는, Recursive Call(함수의 재귀 호출)을 통해서 구현할 수 있습니다. 재귀 호출을 통한 구현이 더 일반적이며, 이해하기 쉬운 구조이기 때문에 많이 사용됩니다. 왜냐하면, 함수는 기본적으로 `stack` 형식으로 호출한 함수들을 쌓아두기 때문에, 더 원활한 구현이 가능합니다. \n```python\nadj = [\n  [2,3],\n  [3],\n  [0,3],\n  [0,1,2]\n]\n\ndef dfs(cur, visited):\n  visited[cur] = True\n  for next in adj[cur]:\n    if visited[next] === False:\n      dfs(next, visited)\n\ndfs(0, [-1] * 4)\n```\n\n추가적으로 만약 순회해야 하는 그래프가 확실하게 모두 연결된 그래프가 아니라면(중간에 간선이 끊겨 연결이 되지 않는 정점이 존재하는 경우), 우리는 모든 정점에서 `dfs`를 수행하도록 설정을 해주어야 합니다. 그래야만 전체 점을 순환할 수 있습니다.\n\n```python\nadj = [\n  [2,3],\n  [3],\n  [0,3],\n  [0,1,2]\n\n]\n\ndef dfs(cur):\n  visited[cur] = True\n  for next in adj[cur]:\n    if visited[next] === False:\n      dfs(next)\n\ndef dfsAll():\n  visited = [False] * len(adj)\n  for v in range(len(adj)):\n    if not visited[v]:\n      dfs(v)\n  \n```\n\n### 시간복잡도\n\n일반적으로 모든 노드를 순환하는 것이 목표라면, \n- 인접 리스트 : $O(|V| + |E|)$\n- 인접 행렬 : $O(V^2)$ \n\n\n# Example\n\n> **연결된 부분집합 갯수**\n\ndisjoint set을 통해서 구현할 수 있는 문제이지만, DFS를 통해서 쉽게 구현할 수 있습니다. 바로, 앞 서 보았던 `dfsAll`에서 `dfs`의 호출 횟수를 counting하면 값을 구할 수 있습니다.\n\n```python\n# adj = [[...], [...], ...]\n# visited = [False, False, ..]\n\ndef dfs(cur):\n  visited[cur] = True\n  for next in adj[cur]:\n    if not visited[next]:\n      dfs(next)\n\ndef dfsAll():\n  visited = [False] * len(adj)\n  cnt = 0\n  for v in range(len(adj)):\n    if not visited[v]:\n      cnt += 1\n      dfs(v)\n  return cnt\n```\n\n---\n\n> **위상정렬**\n\n위상 정렬이란 directed edge(유향 간선)로 이루어진 그래프를 규칙을 깨지 않으면서 정렬하는 방식입니다. 간선이 없는 경우에는 순서가 상관없지만, 간선이 있는 경우에는 순위가 있는 형태입니다. (우선순위 : 출발점 < 도착점)\n언뜻 보기에는 어려워 보이지만, DFS를 통해서 쉽게 해결할 수 있습니다. DFS를 실행하면서 끝에 지점에서 부터 배열에 저장하고 이를 역순으로 정렬하면 위상정렬이 되는 것을 볼 수 있습니다.\n\n```python\n# adj = [[...], [...], ...]\n# visited = [False, False, ..]\n\norder = []\n\ndef dfs(cur):\n  visited[cur] = True\n  for next in adj[cur]:\n    if not visited[next]:\n      dfs(next)\n  order.append(cur)\n\ndef dfsAll():\n  visited = [False] * len(adj)\n  order = []\n  for v in range(len(adj)):\n    if not visited[v]:\n      dfs(v)\n\nprint(order[::-1])\n```\n\n> **오일러 서킷(한 붓 그리기)**\n\n시작 점과 끝 점이 동일할 때, 모든 경로를 지나는 길찾기입니다.\n이를 해결할 때에는 우선 다음 조건을 먼저 확인해야 합니다.\n\n- 두 개 이상의 Component로 분리된 경우 만들 수 없습니다.\n- 어느 한 점이라도 차수가 홀수이면, 만들 수 없습니다.\n\n해결책은 간단합니다. 반복적으로 Circuit(순환)을 찾아서, 최종 구조로 완성하면 됩니다.\n\n다음이 기본적인 프로세스입니다.\n1. 먼저 자신으로 시작해서 자신으로 돌아오는 순환을 먼저 찾는다.\n2. 위의 과정을 진행하고도, 아직 지나지 않은 간선을 포함한 정점이 있다면, 이를 시작점으로 하여 다시 순환을 찾을 수 있다. 이러한 정점이 없을 때까지 이를 반복해서 시행한다.\n3. 이를 최초의 순환에 붙여나가면서, 최종으로 오일러 서킷을 완성한다.\n\n1번과 2번 과정에서 만약, 순환을 찾을 수 없다면 오일러 서킷이 불가능하다는 결론을 내리고 process를 종료합니다.\n\n```python\n# adj = [[...],[...],...] (인접행렬) - 동일 간선이 여러 개 있을 수도 있음\ndef eulerCircuit(cur, circuit):\n  for next in range(len(adj)):\n    if adj[cur][next] > 0:\n      adj[cur][next] -= 1\n      adj[next][cur] -= 1\n      eulerCircuit(next, circuit)\n  circuit.push_back(cur)   \n```\n\n**만약,** 시작점과 끝점이 다른 EulerTrail일 경우에는 임의로 시작점과 끝점을 잇고, Euler Circuit을 찾은 뒤에 삭제하면 됩니다.\n","slug":"dfs1","title":"DFS(1)-기본","category":"Algorithm","tags":["DFS","Graph","Tree"],"date":"2022년 2월 3일 00:00","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"\n이전에는 DFS의 기본이 되는 요소에 대해서 알아보았지만, 이제는 좀 더 심화적인 부분을 배워보고자 한다.   \nDFS가 그래프를 순회하면서 만드는 DFS Spanning Tree에 대한 내용이다.\n\n우리는 총 4가지로 간선을 분류할 수 있습니다. \n1. **Tree Edge(트리 간선)**- DFS Spanning Tree에 포함된 간선\n2. **Forward Edge(순방향 간선)** - 해당 간선이 가르키는 정점이 DFS Spanning Tree에서 자신의 descendant(후손)에 속하는 경우\n3. **Backward Edge(역방향 간선)** - 해당 간선이 가르키는 정점이 DFS Spanning Tree에서 자신의 ancestor(조상)에 속하는 경우\n4. **Cross Edge(교차 간선)** - 해당 간선이 가르키는 정점이 후손도 조상도 아닌 sibiling(형제 또는 그들의 자손)에 속하는 경우\n\n![<img src=\"/images/dfs-spanning-tree.png\" width=\"190\" />](/images/dfs-spanning-tree.png)\n\n이를 구현하기 위해서는 총 두 개의 추가적인 자료구조가 필요하다.   \n1. order[1...N] = 해당 노드의 발견 순서\n2. finished[1...N] = 모든 간선의 사용 여부\n\n```python\nadj = [\n  [1,3],\n  [2],\n  [1],\n  [1,2]\n]\nN = len(adj)\n\norder = [-1] * N\nfinished = [False] * N\ncnt = [0]\ndef dfs(curr):\n  order[curr] = cnt[0]\n  cnt[0] += 1\n  for next in adj[curr]:\n    prefix = curr + \"에서 \" + next + \"까지는\"\n    # 아직 방문하지 않았다면, 트리 간선이다.\n    if order[next] == -1:\n      print(prefix + \"트리 간선이다.\")\n      dfs(next)\n    # 만약 다음 정점의 order가 더 낮다면, 순방향 간선이다.\n    elif order[next] > order[curr]:\n      print(prefix + \"순방향 간선이다.\")\n    # 만약, 다음 정점이 아직 거쳐야 하는 정점이 있다면, 역방향 간선이다.\n    elif not finished[next]:\n      print(prefix + \"역방향 간선이다.\")\n    # 그 외에는 교차 간선이다.\n    else:\n      print(prefix + \"교차 간선이다.\")\n  finished[curr] = True\n\ndef dfsAll():\n  for i in N:\n    if order[i] == -1:\n      dfs(i)\n```\n\n위와 같이 구현하게 되면, 적절하게 간선을 구분할 수 있다. 위에는 방향이 존재하는 그래프였지만, 만약 방향이 존재하지 않는 무향 그래프라면 위의 과정을 좀 더 단순화할 수 있다.\n먼저 간선은 다음과 같이 줄어든다.\n\n1. **트리 간선** = DFS Spanning Tree에 포함된 간선\n2. **중첩 간선** = DFS Spanning Tree에 포함되지 않은 간선\n\n다음과 같이 총 2개로 줄어드는 것을 볼 수 있다. 교차 간선과 역방향 간선은 기본적으로 이후에 방문하는 정점에서 이미 방문한 정점으로 이동하는 것인데 이런 일은 무향 그래프에서는 발생하지 않기 때문에 존재할 수 없다.\n그러면, 구현은 다음과 같이 진행됩니다.\n\n```python\nadj = [\n  [1,2,3],\n  [0,2,3],\n  [0,1,3],\n  [0,1,2]\n]\nN = len(adj)\n\norder = [-1] * N\n# finish는 필요하지 않다.\ncnt = [0]\ndef dfs(curr):\n  order[curr] = cnt[0]\n  cnt[0] += 1\n  for next in adj[curr]:\n    prefix = curr + \"에서 \" + next + \"까지는\"\n    # 아직 방문하지 않았다면, 트리 간선이다.\n    if order[next] == -1:\n      print(prefix + \"트리 간선이다.\")\n      dfs(next)\n    # 만약 다음 정점의 order가 더 낮다면, 중첩 간선이다.\n    # 여기서 유의해야 할 점은 바로 중첩 간선은 두 번 호출된다는 점이다.\n    # 중첩 간선이기 때문에 서로 한 번씩 호출히기 때문이다.\n    # 이를 구분하기 위해서 order를 사용할 수 있다.\n    elif order[next] < order[curr]:\n      print(prefix + \"order가 높은 곳에서 낮은 곳으로 가는 중첩 간선이다.\")\n    else:\n      print(prefix + \"order가 낮은 곳에서 높은 곳으로 가는 중첩 간선이다.\")\n\ndef dfsAll():\n  for i in N:\n    if order[i] == -1:\n      dfs(i)\n```\n\n\n여기서 각 간선의 특징을 이해하면, 다른 문제를 풀기 쉽다.\n1. 역방향 또는 중첩 간선의 갯수 = circle의 갯수   \n    - 여기서 주의할 점은 바로 무향 그래프에서는 바로 직전의 방문한 정점으로 돌아가는 정점은 매번 존재하기 때문에 이는 제외해야 한다는 것을 주의하자.\n2. 무향 그래프에서 특정 정점에서 시작되는 Spanning Tree가 중첩 간선이 없다는 것은, 해당 정점을 기준으로 연결된 정점들은 실제 그래프에서도 트리 형태로 존재한다는 점(절단점)이다.\n3. 방향 그래프에서 역방향 간선과 교차 간선이 없다면, 똑같은 의미를 가진다.\n\n## 문제 풀이\nDFS 문제에서는 대게 다음과 같은 자료 구조가 많이 사용한다.   \n- visited : 방문 여부에 대한 checklist로, graph의 정점의 크기 만큼 존재한다. 초기 값은 False로 초기화한다.\n- order : 방문 순서에 대한 checklist로, graph의 정점의 크기 만큼 존재한다. 초기 값은 -1로 초기화하고, 방문 시마다 올려 주기 위해서, global variable로 cnt를 추가적으로 설정해주기도 한다.(그렇지 않으면, dfs parameter로 전달해주어야 한다.) 또한, 이를 통해서, visited 판단이 가능하기 때문에, 이를 사용할 시에는 visited의 사용을 하지 않아도 된다.\n- finished : 방향 그래프에서 해당 정점에 대한 탐색이 종료되었는지를 확인하기 위해서 사용되는 자료구조이며 graph의 정점의 크기 만큼 존재한다. 초기 값은 False로 초기화하고, dfs의 모든 정점을 방문하는 것이 끝난 경우에 이를 True로 세팅하자.\n- parent : 이는 대게 DFS를 재구조화할 때, 이 역시 graph의 정점의 크기 만큼 존재한다. 대게 경로를 다시 그려야 하는 경우에 많이 사용한다. 만약 visited도 같이 표현하고 싶으면, -2로 초기화하는 것이 좋다. 하지만, visited를 따로 사용할 것이라면, -1로 초기화해도 된다. 왜냐하면, parent -1은 dfs spanning tree의 root라는 의미를 가지는 값으로 쓰는 경우가 대부분이기 때문이다.\n\n\n### Circle 찾기\n위에서 나온 대로 Circle을 찾아나가면 됩니다. \n\n> 백준 16929   \n\nhttps://www.acmicpc.net/problem/16929\n\n가장 기본적인 문제로 대놓고, Circle을 찾으라고 합니다. 유의할 점은 직전에 그쳐간 지점으로 돌아가는 것은 막아야 한다. 따라서, prev 값을 들고 가는 것을 추천한다.\n\n> 백준 12946\n\nhttps://www.acmicpc.net/problem/12946\n\n응용 문제입니다. 처음에는 circle 찾기라는 것을 이해하기 어렵다. 하지만, 최대 색은 3이고, circle을 이루는 원소가 홀수인지 짝수인지를 찾는 문제로 받아들이면, 굉장히 쉽게 풀 수 있다.\n\n> 백준 16947\n\nhttps://www.acmicpc.net/problem/16947\n\n가장 많이 응용되어지는 응용 예시입니다. DFS + BFS 기술을 사용해야 한다. 먼저, DFS를 통해서 Circle에 속하는 원소를 찾아내고, 해당 Circle에 속하는 원소들을 queue에 넣은 후에 거기서부터 bfs로 방문하지 않은 점을 찾아나가면 된다.\n","slug":"dfs2","title":"DFS(2)-DFS Spanning Tree","category":"Algorithm","tags":["DFS","Graph","Tree","Cycle 찾기"],"date":"2022년 4월 23일 10:30","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"## **정의**\n\n우리말로 동적 계획법이라고 번역되어지는 말입니다. 우선 명칭에 대해서 좀 어색할 수 있다. 이는 해당 어원이 오래되었기 때문입니다. 당시에 programming이란 문제 풀이를 위한 planning(계획) 정도로 생각했습니다. 따라서, **Dynamic Programming이 의미하는 바는 다단계 처리에 대한 최적화된 계획법 정도로 해석**할 수 있습니다.\n\nDynamic Programming을 사용하기 위해서는 해당 문제가 다음과 같은 조건을 만족할 때입니다.\n\n1.  **Optimal Substructure**\n2.  **Overlapping Subproblem**\n\n**Optimal Substructure**란 문제의 최적해가 이것의 하위 문제(subproblem)의 최적해에 의해서 정의되어질 수 있어야 한다는 것입니다. 쉽게 말해서 수열의 경우 점화식을 작성할 수 있어야 한다는 의미입니다. 가장 일반적인 예시가 fibonacci 수열을 예로 들 수 있습니다.\n\n$$ fibo(n) = fibo(n-1) + fibo(n-2) $$\n\n**Overlapping Subproblem**이란 문제의 하위 문제(subproblem)들이 중첩해서 사용되는 경우를 말합니다. 위의 fibonacci 수열만 보아도 fibo(100)은 fibo(101), fibo(102)를 계산하기 위해서 쓰이기 때문에 중복이 발생하며, 더 나아가 fibo(101), fibo(102)를 사용하는 경우에는 fibo(100)을 다시 계산해야 합니다. 이것은 굉장한 비용을 초례합니다.\n\n이러한 문제들에 대한 해결책으로써 Dynamic Programming에서는 점화식을 이용해서 문제를 해결하지만, 이때, 한 번 계산한 값을 두 번 계산하지 않도록 하는 것입니다. **이를 가능하게 하는 것이 Memoization(함수의 실행 결과를 저장)입니다.** 즉, 이전에 호출한 함수의 결과값을 별도의 저장 공간(array, list, map, file 등)에 저장해두는 것입니다. 이를 통해서 우리는 problem의 subproblem이 이미 계산된 적이 있다면, 하위 문제를 다시 풀 필요없이 바로 solution(점화식)을 계산할 수 있는 것입니다. 이를 통해서, **계산 시간을 획기적으로 줄일 수 있습니다. 하지만, 추가적인 memory를 사용한다는 점을 반드시 기억해야 합니다.**\n\n여기서 계속해서 반복 및 교체되어 사용되는 단어가 점화식, solution, optimal substructure, function, 함수입니다. 이는 모두 같은 뜻을 가지는데, 여기서도 특히 함수는 **referential transparency**를 보장하는 함수만을 지칭합니다. 수학에서는 아주 당연한 얘기이지만, input값이 동일할 때 항상 같은 output을 내놓아야 한다는 것입니다. programming에서의 함수는 대게 side effect가 존재할 수 있고, 외부 변수를 사용하기도 하므로, 같은 input이라도 상황(context)에 따라 다른 output이 발생할 수도 있는데 이러한 것이 해당 함수에서는 발생해서는 안된다는 것입니다.\n\n---\n\n## **구현**\n\n기본적으로 Dynamic Programming을 적용하기 위해서는 반드시 위에서 언급한 두 조건을 만족하는지를 확인해야 합니다. 따라서, 먼저 점화식을 찾아내고, 이것이 반복 사용되는지를 반드시 확인한 후에 적용하는 것이 기본입니다.\n\nDynamic Programming의 기본적인 구현 방식은 두 가지가 존재합니다. 둘 다 장단점이 있기 때문에 이것에 유의하여 사용해야 합니다.\n\n따라서, 아래에서는 가장 기본적인 예시로 combination을 구하는 방식을 두 가지 방식으로 구현하겠습니다. 일단 Combination은 다음과 같은 점화식을 만족합니다.\n\n$$ {{}_{n}C_{k}} = {{}_{n-1}C_{k-1}} + {{}_{n-1}C_{k}}$$\n\n따라서, 이를 Dynamic Programming을 통해서 구현할 수 있습니다.\n\n### **1\\. Top Down(=Recursive)**\n\n 먼저 input으로 들어올 데이터의 크기를 고려하여, cache list의 크기를 지정합니다. 그 후에 점화식을 함수 내에서 나타내고, 해당 함수값을 return해주면 됩니다. 이때 중요한 것이 이미 함수값을 계산한 적이 있는지를 확인하고 있다면, 바로 return해버리는 점입니다.\n\n```python\nsize = 100\n# 1차원 배열\ncache = [-1] * size\n\n# 2차원 배열\ncache = [[-1 for _ in range(size)] for _ in range(size)]\n\n# 기저값 세팅\ncache[0][0] = 1\ncache[1][0] = 1\ncache[1][1] = 1\n\n# 함수 지정\ndef recursive_call(a, b):\n    # 이미 저장된 값이 있는 경우 return\n    if cache[a][b] != -1:\n        return cache[a][b]\n    # 없다면, 연산 및 저장 후 return\n    cache[a][b] = cache[a-1][b-1] + cache[a-1][b]\n    return cache[a][b]\n    \nprint(recursive_call(10, 2))\n```\n\n해당 방식의 가장 큰 장점은 이해하기 쉽다는 것입니다. 점화식이 분명하게 들어나며, 값을 찾아가는 과정을 상상하는 것이 쉽습니다. 또한, 모든 경우의 수를 탐색하지 않을 수 있다는 점이 있습니다. 왜냐하면, 연관된 데이터만 찾기 때문에 관련 없는 데이터는 찾지 않을 수도 있습니다. **하지만,** recursive call인 만큼 함수 호출의 최대 횟수가 정해져있어, 모든 경우에 올바른 답을 찾지는 못합니다. 이를 해결하기 위해서 끊어서 실행 시켜두는 방법도 있습니다. 예를들어 200을 구하는 문제면, 50, 100, 150을 미리 호출해둡니다. 하지만, 이 또한, 매번 적용할 수 있는 방법은 아니기에 대다수의 경우에는 Bottom Up으로 구현하는 것을 추천합니다.\n\n### **2\\. Bottom Up(with Loop)**\n\n위와 똑같은 원리를 이용해서 구현한 Combination입니다. for문을 이용해서 처음부터 끝까지 구하면서 올라가는 방식입니다. 이렇게 하게 되면, 빈틈없이 아래부터 계산하는지를 체크하면서 구현해야합니다. 중간에 빈값이 발생하는 경우가 없도록 하는 것이 중요합니다.\n\n```python\nsize = 100\n# 1차원 배열\ncache = [-1] * size\n\n# 2차원 배열\ncache = [[-1 for _ in range(size)] for _ in range(size)]\n\n# 기저값 세팅\ncache[0][0] = 1\ncache[1][0] = 1\ncache[1][1] = 1\n\n# 함수 지정\nfor i in range(2, size):\n\tfor j in range(0, i+1):\n    \tcache[i][j] = cache[i-1][j-1] + cache[i-1][j]\n    \nprint(cache[10][2])\n```\n\n---\n\n## **문제 풀이**\n\n모든 Dynamic Programming 문제를 풀기 위해서 거쳐야 하는 단계는 총 3단계입니다.\n\n1.  **문제를** **정의**한다.\n2.  **점화식**을 찾는다.\n3.  **시간 복잡도**를 만족하는지 확인한다.\n4.  **공간 복잡도**를 만족하는지 확인한다.\n\n문제를 정의하고, 점화식을 찾을 때에 나타나는 대략 4가지 유형을 나누어 보았습니다. 제가 만든 분류기준이니 공식적이지는 않습니다.\n\n#### **1\\. 자신의 Subproblem으로만 표현되는 유형**\n\n**A = operate(sub A, sub A)와** 같은 형태로 나타나는 경우를 말한다. 이 경우에는 문제의 재정의가 필요없이 바로 점화식을 작성하면 됩니다. 이런 유형의 문제가 위에서 살펴보았던 combination, fibonacci가 대표적입니다. 가장 기본적인 예시를 풀어봅시다.\n\n> **백준 11726**  \n\n\\*문제를 읽고 오시기 바랍니다.\n\n[11726번: 2×n 타일링](https://www.acmicpc.net/problem/11726)\n\n먼저 이 문제는 2xN 평면에 타일을 채울 수 있는 경우의 수를 찾는 것이 목표입니다.\n\n따라서, $cache[n] = \\text{2xN을 채울 수 있는 경우의 수}$라고 정의하겠습니다.\n\n또한, 규칙을 찾아보면 해당 값은 다음과 같은 pattern을 가진다는 것을 알 수 있습니다. \n\n\n![<img src=\"/images/tile_2_1.jpeg\" width=\"190\" />](/images/tile_2_1.jpeg)\n\nf(n)의 처음 시작을 세로 block으로 시작하면, 다음 block들의 경우의 수는 모두 이전에 구한 경우의 수와 같고, 처음 block을 가로 block으로 설정하면, 위에 block을 놓으면 아래도 가로로 놓는 것이 강제됩니다. 따라서, 가로로 위 아래를 두는 수 밖에 없고, 이렇게 두면 이전전에 두었던 것과 동일한 형태로 놓는 경우의 수만큼의 경우를 갖게 됩니다. 따라서, 결론상 현재의 block의 경우의 수는 이렇게 두 개의 경우의 수의 합으로 정의할 수 있는 것입니다.\n\n> 관련 유형 : 1463, 11727, 11052, 16194, 15988, 1699, 2193\n\n#### **2\\. 문제의 재정의가 필요한 유형**\n\n**A = operate(B), A' = operate(sub B, sub B)와** 같은 형태로 나타나는 경우를 말한다. 이와 같은 유형은 기존에 제시된 문제에 특정 조건을 추가하여, 최종값을 구한 후에 이를 이용해서 답을 구하는 방식입니다. 이 경우에는 문제를 다시 정의해야 하기 때문에 다소 어려울 수 있습니다. 쉬운 예제부터 풀어보겠습니다.\n\n> **백준 1912**\n\n[1912번: 연속합](https://www.acmicpc.net/problem/1912)\n\n이 문제는 점화식으로 나타기가 어렵습니다. 따라서, 약간 문제를 바꾸어서 나타내야 합니다. 수열을 A라 하고, 수열의 i번째 원소를 A[i]라고 할 때, A[i]를 마지막 연속 합의 값으로 했을 때, 최댓값을 S[i]라고 합시다. 이 경우에 이전의 연속합이 음수인 경우는 오히려 값이 낮아지기 때문에 이때는 A[i]를 반환하고, 그렇지 않은 경우에는 S[i-1]에 A[i]를 더해서 연속합을 구하면 됩니다. 따라서 다음과 같은 형태가 됩니다.\n\n$$ \n\\begin{align} \n  S[i] &= S[i-1] + A[i] (\\text{if } S[i-1] > 0) \\\\\n  &= A[i] \n\\end{align} \n$$\n\n와 같은 형태로 나타낼 수 있습니다. 이를 이용해서, S 중에서 가장 큰 값을 찾으면, 그것이 답이 됩니다. 여기서 S가 cache와 같은 역할입니다.\n\n> 관련 유형 : 11053, 2225\n\n#### **3\\. Problem의 Subproblem과 다른 Subproblem이 연계되는 유형**\n\n**A= operate(sub A, sub B), B = operate(sub A, sub B)와** 같은 형태로 나타나는 경우를 말합니다. 이와 같은 유형은 두 개 이상의 subproblem이 서로 연계되기 때문에 이들을 동시에 연산하면서, 진행해야 합니다. 일반적으로는 이중 배열을 이용해서 수행하는 것이 일반적입니다. 이런 내용들을 대게 문제에서 제약사항이 있는 문제에 많이 사용됩니다. 예제를 보면 쉽게 이해가 됩니다.\n\n> **백준 2133**\n\n [2133번: 타일 채우기](https://www.acmicpc.net/problem/2133)\n\n앞 서 풀었던 2xn 타일 문제와 똑같지만, 3xn으로 바뀌었을 뿐이다. 이번에도, 앞에서 부터 한 번씩 경우의 수를 따져보는 것이 중요하다. 먼저 세로를 넣은 경우에는 아래에 가로가 하나 강제되는 것을 볼 수 있다. 그리고, 가로로 넣은 경우에는 세로로 세우거나 가로로 세우는 것을 볼 수 있다. 따라서, 3가지의 경우의 수로 볼 수 있다. 하지만, 우리가 구하고자 하는 모양과는 다른 모양의 조각이 남는 것을 볼 수 있다. 따라서, 우리가 구하고자 하는 것(3xn을 채우는 경우의 수)을 cache[n][0]이라 하고, 그를 위해 부가적으로 해결해야 하는 문제(밑변이 n이고, 윗변은 n-1, 좌는 2, 우는 3인 도형을 채우는 경우의 수)를 cache[n][1]이라고 하자.\n\n그렇게 하면 아래와 같은 점화식을 얻을 수 있다.\n\n![<img src=\"/images/tile_3_1.jpeg\" width=\"190\" />](/images/tile_3_1.jpeg)\n\n하지만, 다른 부가적인 문제에 대한 점화식을 세우지 못했기 때문에, 이에 대한 점화식도 찾아주어야 한다. 왼쪽에 세로를 채우게 되는 경우와 가로를 바로 채우는 경우가 있을 것이다. 해당하는 경우는 각 각 다음과 같이 묘사되고, 점화식도 동일하게 얻을 수 있다.\n\n![<img src=\"/images/tile_3_2.jpeg\" width=\"190\" />](/images/tile_3_2.jpeg)\n\n이제 이를 반복해서 풀어나가면 쉽게 답을 구할 수 있다.\n\n이런 식으로 하나의 subproblem을 풀기 위해서 연계되는 subproblem이 생기는 유형도 존재한다.\n\n>  관련 유형 : 11054, 13398, 1309, 2156, 1149\n\n#### **4\\. 동적계획법을 통해서 얻은 결과값을 추적하는 유형**\n\n해당 유형은 상당히 간단하게도 parent라는 별도의 list를 만들어서 구현할 수 있다. 즉, cache의 값을 갱신해줄 때 영향을 준 subproblem의 index를 저장해두는 것이다. 이를 통해서 해당 값이 어디서부터 유래되었는지를 후에 추적하는 것이 가능하다.\n\n> **백준 14002**\n\n [14002번: 가장 긴 증가하는 부분 수열 4\n\n수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오. 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이\n\nwww.acmicpc.net](https://www.acmicpc.net/problem/14002)\n\n유형 2와 동일한 풀이로 풀 수 있는 문제이다. 만약, cache값을 수정하는 연산이 발생하면, parent를 변경하면 된다.\n\n---\n\n위에 언급한 모든 풀이는 해당 Github에 존재합니다.\n\n[GitHub - euidong/BOJ: 백준 알고리즘 문제 풀이](https://github.com/euidong/BOJ)","slug":"dynamic-programming","title":"Dynamic Programming","category":"Algorithm","tags":["Dynamic Programming","BOJ2133","BOJ11726","BOJ14002","BOJ1912","Memoization","Optimal Structural","Overlapping Subproblem","Referential Transparency"],"date":"2022년 4월 14일 13:51","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"여러 개의 Vertex(정점)와 그를 잇는 Edge(간선)로 이루어진 형태의 자료 구조를 의미한다. \n\n## 핵심 종류\n- 무향 그래프: 방향이 없이 선으로 이어진 그래프\n- 방향 그래프: 방향을 가진 그래프로 한 정점에서 다른 정점으로 가는 방향을 명시한 그래프\n- 가중치 그래프: 각 간선이 가중치를 가지는 형태를 그래프\n- 이분 그래프: 정점을 두 개의 그룹으로 나누었을 때, 각 그룹은 서로 연결되지 않은 점들로만 이루어지는 그래프\n- **방향 비순환 그래프(Directed Acyclic Graph(DAG))**: 어느 정점에서 시작해도 cycle(순환)이 존재하지 않는 형태의 그래프. 이 그래프 형태에 tree(트리)도 해당되며, 이것이 특별한 이유는 선형으로 정렬하는 것이 가능하기 때문이다. ([DFS_위상정렬 참고](/post/DFS))\n\n## Dense vs Sparse\n그래프 관련 문제를 해결할 때, 반드시 고려해야 할 점은 해당 그래프가 Dense(밀도가 높은, edge가 많은)한 경우와 Sparse(희귀한, edge가 적은)한 경우를 모두 고려해주어야 한다. 이에 따라서, 시간복잡도가 굉장히 천차만별하게 나타나기 때문이다.\n\n\n## 표현 방법\n1. adjacent list(인접 리스트)   \n  각 정점마다 해당 정점에서 나가는 간선의 목록을 저장해서 그래프를 표현하는 법\n  ```python\n  import sys\n  # N = 정점의 수, M = 간선의 수\n  N, M = [int(i) for i in sys.stdin.readline().split()]\n  adj = [[] for _ in range(N)]\n  for _ in range(M):\n    a, b = [int(i) for i in sys.stdin.readline().split()]\n    adj[a].append(b)\n    # 무향 그래프에서는 다음과 같이 반대 방향도 추가해주어야 한다.\n    adj[b].append(a)\n  ```\n2. adjacent matrix(인접 행렬)   \n  인접 리스트 방식의 단점은 특정 두 정점이 연결 되었는지를 알기 위해서는 해당 정점과 연결된 모든 정점을 확인해야 한다. 인접 행렬에서는 이를 해결할 수 있다. 연결 여부를 직접 2차원 $V \\times V$ 행렬로 나타내기 때문에 이를 바로 index 조회로 알 수 있다. **하지만,** 메모리를 더 잡아 먹을 수도 있고, 단순히 연결된 정점만 조회하는 연산일 경우에는 오히려 모든 정점을 조회해야 하기 때문에 비용이 증가할 수 있다. (Sparse한 graph일 수록 비용 증가가 크다.)\n  ```python\n  import sys\n  # N = 정점의 수, M = 간선의 수\n  N, M = [int(i) for i in sys.stdin.readline().split()]\n  adj = [[0 for _ in range(N)] for _ in range(N)]\n  for _ in range(M):\n    a, b = [int(i) for i in sys.stdin.readline().split()]\n    adj[a][b] += 1\n    # 무향 그래프에서는 다음과 같이 반대 방향도 추가해주어야 한다.\n    adj[b][a] += 1 \n  ```","slug":"graph","title":"Graph","category":"Algorithm","tags":["Graph"],"date":"2022년 4월 20일 12:00","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"해당 Posting에서는 Modulo연산의 정의와 특징을 이해하고, 이를 이용한 알고리즘을 소개합니다.\n\n사칙연산과 같은 연산자입니다. 하지만, modulo 연산은 기존 사칙연산과는 다른 다양한 특징을 가지기 때문에, 이를 정리하고 이해하는 것은 중요합니다.\n\n우선 modulo 연산이란 무엇인지부터 알아야 합니다.\n\n$$a = bq + r$$\n\n$$r = a \\mod b = a \\mod q$$\n\nex.\n\n1.  $100 \\mod 3 = 1$\n2.  $12 \\mod 32 = 12$\n3.  $123 \\mod 11 = 2$\n4.  $1 \\mod 1 = 0$\n\n로 정의할 수 있습니다.\n\n쉽게 말해서, a와 b에 대해서, 나눗셈한 나머지를 반환하는 연산자입니다.\n\n이는 여러 programming language에서는 % 표기로 나타내는 경우가 많습니다. 따라서, 아래에서 부터는 %로 표기합니다.\n\n이 연산자는 기타 여러 알고리즘에서 유용하게 사용되기 때문에 특징을 알아두는 것이 좋습니다.\n\n## **특징**\n\n1.  연산 결과는 0보다 크거나 같고 연산을 수행하는 값($b$)보다는 작습니다.\n2.  만약, modulo 연산을 했을 때, 결과가 같다면, 두 정수는 **합동**이라고 합니다. 이에 따라, 합동인 정수는 무한히 많습니다.\n\n## **연산 특징**\n\n1.  **덧셈의 항등원(0)이 존재합니다.**  \n    $(A + 0) \\% C = A \\% C$\n2.  **덧셈의 역원(-A = C-A)이 존재합니다.**  \n    $-A \\% C = (C - A) \\% C$  \n    ex) $-105 \\% 100 = -5 \\% 100 = 95$\n3.  $(A+B) \\% C = \\{(A\\%C) + (B\\%C)\\} \\% C$  \n    ex) $54 \\% 17 = \\{(29\\%17) + (25\\%17)\\} \\% 17 = (12+8) \\%17 = 3 $\n4.  $(A-B) \\% C = \\{(A\\%C) - (B\\%C)\\} \\% C$  \n    ex) $54 \\% 17 = \\{(70\\%17) - (16\\%17)\\} \\% 17 = (2-16) \\%17 = -14 \\% 17 = 3 $  \n    \n5.  $(A \\times B) \\% C = \\{(A\\%C) \\times (B\\%C)\\} \\% C$  \n    ex) $960 \\% 17 = \\{(20\\%17) \\times (18\\%17)\\} \\% 17 = (3 \\times 1) \\%17 = 3 $\n6.  **정수 k, p에 대하여, p가 k의 약수라면,**  \n    $A^k \\% C = (A^{k \\over p}\\%C)^p \\% C$  \n    ex) $2^{10}(=1024) \\% 29 = (2^5(=32) \\% 29)^2 \\%29 = 3^2 \\% 29 = 9$\n7.  **곱셈의 항등원(1)이 존재합니다. ($ C \\ge 2$)**  \n    $A \\times 1 \\% C = A \\% C$\n8.  **곱셈의 역원(A^{-1})가 존재합니다.**  \n    $A \\times A^{-1} \\% C = 1 $  \n    하지만, 이를 구하는 것은 직접 해보는 수밖에 없습니다.\n9.  **곱셈의 역원을 통해서 나눗셈을 정의할 수 있습니다.**  \n    $ ({B \\over{A}} ) \\% C = B \\times A^{-1} \\% C$\n\n위와 같은 특징들 때문에, 수의 범위를 제한하는 문제를 푼다고할 때, 굉장히 유용하게 이를 이용할 수 있습니다. 왜냐하면, modulo 합동끼리는 사칙연산의 여러 특징들을 모두 사용할 수 있기 때문입니다.\n\n교환 법칙, 결합법칙, 역원, 항등원이 모두 존재합니다. \n\n또한, 만약, **나누는 수가 만약 소수라면**, 나눗셈을 더 쉽게 정의할 수 있습니다.\n\n바로 **Fermat's little theorem**(페르마의 소정리)를 활용하는 것입니다.\n\n이에 따르면, $A^{n-1} \\% C = 1$이라는 것입니다.\n\n이를 통해서, 우리는 아래를 증명할 수 있으며,\n\n$$ A \\times A^{-1} \\% C = 1  % C $$\n\n$$ A \\times A^{-1} \\% C = A^{n-1} \\% C $$\n\n$$ A^{-1} \\% C = A^{n-2} \\% C $$\n\n결론상 다음과 같이 나눗셈을 변형할 수 있습니다.\n\n$$ {A\\over B} \\% C = A\\times B^{n-2} \\% C$$\n\n## **유클리드 호제법**\n\n최대공약수(GCD), 최소공배수(LCM)를 구하는 문제에서 가장 단골로 사용되는 알고리즘입니다.\n\n해당 알고리즘의 동작순서는 다음과 같습니다.\n\n1.  큰 수(p)로 작은 수(q)를 modulo 연산하여, 결과값(r)을 얻습니다.\n2.  r이 0이라면, q는 최대공약수입니다.\n3.  그렇지 않다면, q와 r을 갖고, 1로 돌아가서 다시 시행합니다.\n\n이 결과를 통해서, 최대공약수(GCD)를 구할 수 있고, 모두가 알다시피, 최소공배수는 ${p \\times q}\\over {gcd}$이므로, 쉽게 유도가 가능합니다.","slug":"modulo","title":"modulo","category":"Algorithm","tags":["Modulo","나머지"],"date":"2022년 4월 1일 00:00","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"}],"params":{"subject":"Algorithm"}},"__N_SSG":true}