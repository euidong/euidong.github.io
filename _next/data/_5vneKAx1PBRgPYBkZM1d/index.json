{"pageProps":{"recentPosts":[{"content":"## DFS(Depth First Search)\nGraph의 탐색에서 가장 기본이 되는 방법입니다. 한 점에서 연결된 다른 점으로 이동을 하면서, 모든 연결된 점을 순화하는 것을 목표로 가진다고 가정해봅시다. 이때, 정점을 고르는 방식에 따라서, DFS, BFS로 나눕니다. DFS에서는 자신과 연결된 정점 중에서 하나를 선택하고 이동한 뒤에 해당 점에서 다시 연결된 지점을 찾아서 이동합니다. 즉, 바로 지금 뽑은 점에 인접해있는 지점이 이전에 인접해있던 지점보다 가중치가 높다는 것입니다. 이를 모두 진행하고도 답을 찾을 수 없다면, 이제 이전 시점으로 돌아와서 다시 작업을 재개하는 방식입니다.\n\n이를 구현하기 위해서는 `Stack`이 가장 중요합니다. 이전의 연결되었던 점보다 현재 연결된 점이 더 중요하기 때문에, 현재가 우선순위가 높지만, 후에 이를 다시 찾아와야 하기 때문에, 이를 저장하기 위한 자료구조가 필요한데 이것이 `Stack`이 되는 것입니다.\n\n따라서, 이를 직접 구현해보면 다음과 같습니다.\n```python\nadj = [\n  [2,3],\n  [3],\n  [0,3],\n  [0,1,2]\n]\n\nvisited = [False] * 4\nstack = [(0, visited)]\nwhile len(stack) > 0:\n  cur, visited = stack.pop(-1)\n  visited[cur] = True\n  for next in adj[cur]:\n    if visited[next] === False:\n      stack.append((next, visited))\n```\n또는, Recursive Call(함수의 재귀 호출)을 통해서 구현할 수 있습니다. 재귀 호출을 통한 구현이 더 일반적이며, 이해하기 쉬운 구조이기 때문에 많이 사용됩니다. 왜냐하면, 함수는 기본적으로 `stack` 형식으로 호출한 함수들을 쌓아두기 때문에, 더 원활한 구현이 가능합니다. \n```python\nadj = [\n  [2,3],\n  [3],\n  [0,3],\n  [0,1,2]\n]\n\ndef dfs(cur, visited):\n  visited[cur] = True\n  for next in adj[cur]:\n    if visited[next] === False:\n      dfs(next, visited)\n\ndfs(0, [-1] * 4)\n```\n\n추가적으로 만약 순회해야 하는 그래프가 확실하게 모두 연결된 그래프가 아니라면(중간에 간선이 끊겨 연결이 되지 않는 정점이 존재하는 경우), 우리는 모든 정점에서 `dfs`를 수행하도록 설정을 해주어야 합니다. 그래야만 전체 점을 순환할 수 있습니다.\n\n```python\nadj = [\n  [2,3],\n  [3],\n  [0,3],\n  [0,1,2]\n\n]\n\ndef dfs(cur):\n  visited[cur] = True\n  for next in adj[cur]:\n    if visited[next] === False:\n      dfs(next)\n\ndef dfsAll():\n  visited = [False] * len(adj)\n  for v in range(len(adj)):\n    if not visited[v]:\n      dfs(v)\n  \n```\n\n### 시간복잡도\n\n일반적으로 모든 노드를 순환하는 것이 목표라면, \n- 인접 리스트 : $O(|V| + |E|)$\n- 인접 행렬 : $O(V^2)$ \n\n\n# Example\n\n> **연결된 부분집합 갯수**\n\ndisjoint set을 통해서 구현할 수 있는 문제이지만, DFS를 통해서 쉽게 구현할 수 있습니다. 바로, 앞 서 보았던 `dfsAll`에서 `dfs`의 호출 횟수를 counting하면 값을 구할 수 있습니다.\n\n```python\n# adj = [[...], [...], ...]\n# visited = [False, False, ..]\n\ndef dfs(cur):\n  visited[cur] = True\n  for next in adj[cur]:\n    if not visited[next]:\n      dfs(next)\n\ndef dfsAll():\n  visited = [False] * len(adj)\n  cnt = 0\n  for v in range(len(adj)):\n    if not visited[v]:\n      cnt += 1\n      dfs(v)\n  return cnt\n```\n\n---\n\n> **위상정렬**\n\n위상 정렬이란 directed edge(유향 간선)로 이루어진 그래프를 규칙을 깨지 않으면서 정렬하는 방식입니다. 간선이 없는 경우에는 순서가 상관없지만, 간선이 있는 경우에는 순위가 있는 형태입니다. (우선순위 : 출발점 < 도착점)\n언뜻 보기에는 어려워 보이지만, DFS를 통해서 쉽게 해결할 수 있습니다. DFS를 실행하면서 끝에 지점에서 부터 배열에 저장하고 이를 역순으로 정렬하면 위상정렬이 되는 것을 볼 수 있습니다.\n\n```python\n# adj = [[...], [...], ...]\n# visited = [False, False, ..]\n\norder = []\n\ndef dfs(cur):\n  visited[cur] = True\n  for next in adj[cur]:\n    if not visited[next]:\n      dfs(next)\n  order.append(cur)\n\ndef dfsAll():\n  visited = [False] * len(adj)\n  order = []\n  for v in range(len(adj)):\n    if not visited[v]:\n      dfs(v)\n\nprint(order[::-1])\n```\n\n> **오일러 서킷(한 붓 그리기)**\n\n시작 점과 끝 점이 동일할 때, 모든 경로를 지나는 길찾기입니다.\n이를 해결할 때에는 우선 다음 조건을 먼저 확인해야 합니다.\n\n- 두 개 이상의 Component로 분리된 경우 만들 수 없습니다.\n- 어느 한 점이라도 차수가 홀수이면, 만들 수 없습니다.\n\n해결책은 간단합니다. 반복적으로 Circuit(순환)을 찾아서, 최종 구조로 완성하면 됩니다.\n\n다음이 기본적인 프로세스입니다.\n1. 먼저 자신으로 시작해서 자신으로 돌아오는 순환을 먼저 찾는다.\n2. 위의 과정을 진행하고도, 아직 지나지 않은 간선을 포함한 정점이 있다면, 이를 시작점으로 하여 다시 순환을 찾을 수 있다. 이러한 정점이 없을 때까지 이를 반복해서 시행한다.\n3. 이를 최초의 순환에 붙여나가면서, 최종으로 오일러 서킷을 완성한다.\n\n1번과 2번 과정에서 만약, 순환을 찾을 수 없다면 오일러 서킷이 불가능하다는 결론을 내리고 process를 종료합니다.\n\n```python\n# adj = [[...],[...],...] (인접행렬) - 동일 간선이 여러 개 있을 수도 있음\ndef eulerCircuit(cur, circuit):\n  for next in range(len(adj)):\n    if adj[cur][next] > 0:\n      adj[cur][next] -= 1\n      adj[next][cur] -= 1\n      eulerCircuit(next, circuit)\n  circuit.push_back(cur)   \n```\n\n**만약,** 시작점과 끝점이 다른 EulerTrail일 경우에는 임의로 시작점과 끝점을 잇고, Euler Circuit을 찾은 뒤에 삭제하면 됩니다.\n","slug":"dfs1","title":"DFS(1)-기본","category":"Algorithm","tags":["DFS","Graph","Tree"],"date":"2022년 2월 3일 00:00","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"\n이전에는 DFS의 기본이 되는 요소에 대해서 알아보았지만, 이제는 좀 더 심화적인 부분을 배워보고자 한다.   \nDFS가 그래프를 순회하면서 만드는 DFS Spanning Tree에 대한 내용이다.\n\n우리는 총 4가지로 간선을 분류할 수 있습니다. \n1. **Tree Edge(트리 간선)**- DFS Spanning Tree에 포함된 간선\n2. **Forward Edge(순방향 간선)** - 해당 간선이 가르키는 정점이 DFS Spanning Tree에서 자신의 descendant(후손)에 속하는 경우\n3. **Backward Edge(역방향 간선)** - 해당 간선이 가르키는 정점이 DFS Spanning Tree에서 자신의 ancestor(조상)에 속하는 경우\n4. **Cross Edge(교차 간선)** - 해당 간선이 가르키는 정점이 후손도 조상도 아닌 sibiling(형제 또는 그들의 자손)에 속하는 경우\n\n![<img src=\"/images/dfs-spanning-tree.png\" width=\"190\" />](/images/dfs-spanning-tree.png)\n\n이를 구현하기 위해서는 총 두 개의 추가적인 자료구조가 필요하다.   \n1. order[1...N] = 해당 노드의 발견 순서\n2. finished[1...N] = 모든 간선의 사용 여부\n\n```python\nadj = [\n  [1,3],\n  [2],\n  [1],\n  [1,2]\n]\nN = len(adj)\n\norder = [-1] * N\nfinished = [False] * N\ncnt = [0]\ndef dfs(curr):\n  order[curr] = cnt[0]\n  cnt[0] += 1\n  for next in adj[curr]:\n    prefix = curr + \"에서 \" + next + \"까지는\"\n    # 아직 방문하지 않았다면, 트리 간선이다.\n    if order[next] == -1:\n      print(prefix + \"트리 간선이다.\")\n      dfs(next)\n    # 만약 다음 정점의 order가 더 낮다면, 순방향 간선이다.\n    elif order[next] > order[curr]:\n      print(prefix + \"순방향 간선이다.\")\n    # 만약, 다음 정점이 아직 거쳐야 하는 정점이 있다면, 역방향 간선이다.\n    elif not finished[next]:\n      print(prefix + \"역방향 간선이다.\")\n    # 그 외에는 교차 간선이다.\n    else:\n      print(prefix + \"교차 간선이다.\")\n  finished[curr] = True\n\ndef dfsAll():\n  for i in N:\n    if order[i] == -1:\n      dfs(i)\n```\n\n위와 같이 구현하게 되면, 적절하게 간선을 구분할 수 있다. 위에는 방향이 존재하는 그래프였지만, 만약 방향이 존재하지 않는 무향 그래프라면 위의 과정을 좀 더 단순화할 수 있다.\n먼저 간선은 다음과 같이 줄어든다.\n\n1. **트리 간선** = DFS Spanning Tree에 포함된 간선\n2. **중첩 간선** = DFS Spanning Tree에 포함되지 않은 간선\n\n다음과 같이 총 2개로 줄어드는 것을 볼 수 있다. 교차 간선과 역방향 간선은 기본적으로 이후에 방문하는 정점에서 이미 방문한 정점으로 이동하는 것인데 이런 일은 무향 그래프에서는 발생하지 않기 때문에 존재할 수 없다.\n그러면, 구현은 다음과 같이 진행됩니다.\n\n```python\nadj = [\n  [1,2,3],\n  [0,2,3],\n  [0,1,3],\n  [0,1,2]\n]\nN = len(adj)\n\norder = [-1] * N\n# finish는 필요하지 않다.\ncnt = [0]\ndef dfs(curr):\n  order[curr] = cnt[0]\n  cnt[0] += 1\n  for next in adj[curr]:\n    prefix = curr + \"에서 \" + next + \"까지는\"\n    # 아직 방문하지 않았다면, 트리 간선이다.\n    if order[next] == -1:\n      print(prefix + \"트리 간선이다.\")\n      dfs(next)\n    # 만약 다음 정점의 order가 더 낮다면, 중첩 간선이다.\n    # 여기서 유의해야 할 점은 바로 중첩 간선은 두 번 호출된다는 점이다.\n    # 중첩 간선이기 때문에 서로 한 번씩 호출히기 때문이다.\n    # 이를 구분하기 위해서 order를 사용할 수 있다.\n    elif order[next] < order[curr]:\n      print(prefix + \"order가 높은 곳에서 낮은 곳으로 가는 중첩 간선이다.\")\n    else:\n      print(prefix + \"order가 낮은 곳에서 높은 곳으로 가는 중첩 간선이다.\")\n\ndef dfsAll():\n  for i in N:\n    if order[i] == -1:\n      dfs(i)\n```\n\n\n여기서 각 간선의 특징을 이해하면, 다른 문제를 풀기 쉽다.\n1. 역방향 또는 중첩 간선의 갯수 = circle의 갯수\n\n\n\n[...continue]\n","slug":"dfs2","title":"DFS(2)-DFS Spanning Tree","category":"Algorithm","tags":["DFS","Graph","Tree","FindCircleInGraph"],"date":"2022년 4월 23일 10:30","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"# Mysql\n\nMysql is a basic Database to store countless data. It is RDMS(This think that Relation is very very very important than any other things). You can Read, Create, Update, Delete data with it faster, managable (like transaction) than FileSystem.\nIt is manage by Oracle. And It can get good performance in read.\n\nEspectially 5.7 version is stable version. So industry use this version for development or test.\n\n![why-use-5.7](/images/why-use-5.7.png)\n\nIf you want get more information [click this](https://mysql.com)\n\n# Docker\n\nDocker is a virtualization application.\nIt is usally show more performance than any other virtualization machine program.\nBecase It use container.\nSo, It can make more efficient feature.\nIf you want get database running in Linux then you just build and run container that has database with Linux.\nWhen you anymore need taht database, you just delete that container.\nIt's so simple, clear. Let's enjoy.\n\nIf you want get more information [click this](https://www.docker.com/)\n\n### Install\n\nFollowing That\nhttps://www.docker.com/get-started\n\n# Mysql with Docker\n\n### Just Run script.\n\n```bash\nsudo docker run \\ # run container\n -e MYSQL_ROOT_PASSWORD=qwe123 \\ # setting MYSQL_ROOT_PASSWORD\n -e MYSQL_DATABASE=just \\ # default database name\n -e TZ=Asia/Seoul \\ # setting Timezone\n -p 3309:3306 \\ # setting port (my Pc port:container port)\n mysql:5.7 \\ # image name\n --character-set-server=utf8 \\ # setting utf8\n --collation-server=utf8_unicode_ci # setting utf8\n```\n\n### With compose file\n\ndocker-compose.yml\n\n```yml\nversion: \"3.7\"\nservices:\n  # Mysql Server\n  db:\n    image: mysql:5.7\n    # mysql utf-8 설정\n    command:\n      - --character-set-server=utf8\n      - --collation-server=utf8_unicode_ci\n    # db password 및 db 자동 생성\n    environment:\n      MYSQL_ROOT_PASSWORD: \"qwe123\"\n      MYSQL_DATABASE: \"just\"\n      MYSQL_TCP_PORT: \"3306\"\n      TZ: \"Asia/Seoul\"\n    ports:\n      - \"3309:3306\"\n    # for db data backUp\n    volumes:\n      - ./mysql/data:/var/lib/mysql\n```\n\n```bash\ndocker-compose up --build\n```\n\nmore information => https://docs.docker.com/get-started/\n\nmore infomation => https://docs.docker.com/compose/","slug":"docker-mysql","title":"Docker Mysql","category":"Docker","tags":["virtualEnv","mysql"],"date":"2022년 4월 20일 12:00","thumbnailSrc":"https://euidong.github.io/images/hero.png"},{"content":"# Gatsby\n\nLink : https://www.gatsbyjs.com\n\n> Gatsby is a React-based open-source framework for creating websites and apps.\n> It's great whether you're building a portfolio site or blog,\n> or a high-traffic e-commerce store or company homepage.\n\ngatsby introduce themselves that sentense. they focus on that big, high performance, and complicated feature view.\nThat is gatsby's advantage. they can make high performance feature more faster.\n\n### Why?\n\n##### First. Bigger and Faster\n\nIt uses React And GraphQL feature.\nSo, it can make better performance than other static web site platform. ex) jk ...\n\n##### Second. Support many feature\n\n- It can do many thing in framework.\n\nhttps://www.gatsbyjs.com/docs/conceptual/\n\n##### Third. Showcase\n\n- gatsby Showcase\n\nhttps://themejam.gatsbyjs.org/showcase\n\n### This Blog's feature\n\n- novela Theme\n\nhttps://github.com/narative/gatsby-theme-novela\n\n### SetUp\n\n=> github : https://github.com/euidong/euidong.github.io\n\n##### 1. Install\n\n```shell\n$ mkdir blog\n$ yarn add react react-dom gatsby @narative/gatsby-theme-novela\n$ yarn install\n```\n\n##### 2. set script\n\n`blog/package.json`\n\n```json\n{\n  \"licenses\": [\n    {\n      \"type\": \"MIT\",\n      \"url\": \"https://www.opensource.org/licenses/mit-license.php\"\n    }\n  ],\n  \"dependencies\": {\n    \"@narative/gatsby-theme-novela\": \"^0.18.4\",\n    \"gatsby\": \"^2.28.0\",\n    \"gh-pages\": \"^3.1.0\",\n    \"react\": \"^17.0.1\",\n    \"react-dom\": \"^17.0.1\"\n  },\n  \"scripts\": {\n    \"build\": \"gatsby build --prefix-paths\",\n    \"deploy\": \"gatsby build --prefix-paths && gh-pages -d public\",\n    \"dev\": \"gatsby develop\"\n  },\n  \"homepage\": \"https://euidong.github.io\"\n}\n```\n\n##### 3. post & author setting\n\nThis theme require at least one post and one author.\n\n`blog/content/authors/authors.yml`\n\n```yml\n- name: Euidong Jung\n  authorsPage: true\n  bio: |\n    Dev - Lang : Javascript Typescript <br />\n    Dev - Front : ReactJS ReactNative <br />\n    Dev - Back : NodeJS Apollo Express <br />\n    Dev - ENV : CloudNative Docker Kubernates AWS\n  avatar: ./avatars/euidong-avatar.jpeg\n  featured: true\n  social:\n    - url: https://github.com/euidong\n```\n\nand add image to\n`blog/content/authors/avatars/euidong-avatar.jpeg`\n\n`blog/content/posts/2021-01-03-gatsby/index.mdx`\n\n```mdx\n---\ntitle: Gatsby Blog\nauthor: Euidong Jung\ndate: 2021-01-03\nhero: ./images/gatsby.png\nexcerpt: Gatsby Flatform\n---\n\n# hellow world\n\n### good world\n\n##### happy world\n```\n\n##### 4. Icon\n\n`blog/src/@narative/gatsby-theme-novela/components/Logo`\n\n```javascript\nimport React from \"react\";\nimport { Link } from \"gatsby\";\nimport LogoBlack from \"../../../../image/icon/logo-black.png\";\nimport LogoWhite from \"../../../../image/icon/logo-white.png\";\n\n/**\n * Paste in your SVG logo and return it from this component.\n * Make sure you have a height set for your logo.\n * It is recommended to keep the height within 25-35px.\n */\nexport default function Logo({ fill }) {\n  return (\n    <Link\n      to=\"/\"\n      style={{\n        fontSize: \"40px\",\n        fontWeight: 700,\n        fontFamily: \"Merriweather',Georgia,Serif\",\n      }}\n    >\n      <img\n        src={fill === \"#fff\" ? LogoWhite : LogoBlack}\n        alt=\"logo\"\n        style={{ height: \"60px\" }}\n      />\n    </Link>\n  );\n}\n```\n\n##### 5. testing\n\n```shell\n$ yarn dev  # testing\n```\n\n##### 6. deployment\n\nSelect static web site deploy platform.(ex. gh-page / aws s3 / heroku ...)\n\n```shell\n$ yarn deploy # deploying to gh-page\n```\n\nIf you want deploy instantly when push to branch. You can use github action. (It is simple CI/CD)\n\nSee bellow example\n\nblog/.github/workflows/main.yml\n\n```yml\nname: github pages\n\non:\n  push:\n    branches:\n      - dev\n\njobs:\n  deploy:\n    runs-on: ubuntu-18.04\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Setup Node\n        uses: actions/setup-node@v2.1.2\n        with:\n          node-version: \"12.x\"\n\n      - name: Cache dependencies\n        uses: actions/cache@v2\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n\n      - name: Install yarn\n        run: npm install -g yarn\n\n      - name: Install node_modules\n        run: yarn install\n\n      - name: Build\n        run: yarn build\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./public\n```\n\nIt is status Badge.\n![github pages](https://github.com/euidong/euidong.github.io/workflows/github%20pages/badge.svg?branch=dev&event=push)","slug":"gatsby","title":"Gatsby","category":"Web","tags":["Gatsby","MDX","Blog"],"date":"2022년 4월 20일 12:00","thumbnailSrc":"https://euidong.github.io/images/gatsby.png"},{"content":"여러 개의 Vertex(정점)와 그를 잇는 Edge(간선)로 이루어진 형태의 자료 구조를 의미한다. \n\n## 핵심 종류\n- 무향 그래프: 방향이 없이 선으로 이어진 그래프\n- 방향 그래프: 방향을 가진 그래프로 한 정점에서 다른 정점으로 가는 방향을 명시한 그래프\n- 가중치 그래프: 각 간선이 가중치를 가지는 형태를 그래프\n- 이분 그래프: 정점을 두 개의 그룹으로 나누었을 때, 각 그룹은 서로 연결되지 않은 점들로만 이루어지는 그래프\n- **방향 비순환 그래프(Directed Acyclic Graph(DAG))**: 어느 정점에서 시작해도 cycle(순환)이 존재하지 않는 형태의 그래프. 이 그래프 형태에 tree(트리)도 해당되며, 이것이 특별한 이유는 선형으로 정렬하는 것이 가능하기 때문이다. ([DFS_위상정렬 참고](/post/DFS))\n\n## Dense vs Sparse\n그래프 관련 문제를 해결할 때, 반드시 고려해야 할 점은 해당 그래프가 Dense(밀도가 높은, edge가 많은)한 경우와 Sparse(희귀한, edge가 적은)한 경우를 모두 고려해주어야 한다. 이에 따라서, 시간복잡도가 굉장히 천차만별하게 나타나기 때문이다.\n\n\n## 표현 방법\n1. adjacent list(인접 리스트)   \n  각 정점마다 해당 정점에서 나가는 간선의 목록을 저장해서 그래프를 표현하는 법\n  ```python\n  import sys\n  # N = 정점의 수, M = 간선의 수\n  N, M = [int(i) for i in sys.stdin.readline().split()]\n  adj = [[] for _ in range(N)]\n  for _ in range(M):\n    a, b = [int(i) for i in sys.stdin.readline().split()]\n    adj[a].append(b)\n    # 무향 그래프에서는 다음과 같이 반대 방향도 추가해주어야 한다.\n    adj[b].append(a)\n  ```\n2. adjacent matrix(인접 행렬)   \n  인접 리스트 방식의 단점은 특정 두 정점이 연결 되었는지를 알기 위해서는 해당 정점과 연결된 모든 정점을 확인해야 한다. 인접 행렬에서는 이를 해결할 수 있다. 연결 여부를 직접 2차원 $V \\times V$ 행렬로 나타내기 때문에 이를 바로 index 조회로 알 수 있다. **하지만,** 메모리를 더 잡아 먹을 수도 있고, 단순히 연결된 정점만 조회하는 연산일 경우에는 오히려 모든 정점을 조회해야 하기 때문에 비용이 증가할 수 있다. (Sparse한 graph일 수록 비용 증가가 크다.)\n  ```python\n  import sys\n  # N = 정점의 수, M = 간선의 수\n  N, M = [int(i) for i in sys.stdin.readline().split()]\n  adj = [[0 for _ in range(N)] for _ in range(N)]\n  for _ in range(M):\n    a, b = [int(i) for i in sys.stdin.readline().split()]\n    adj[a][b] += 1\n    # 무향 그래프에서는 다음과 같이 반대 방향도 추가해주어야 한다.\n    adj[b][a] += 1 \n  ```","slug":"graph","title":"Graph","category":"Algorithm","tags":["Graph"],"date":"2022년 4월 20일 12:00","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"열심히 만든 Blog를 검색 엔진들에 노출하기 위한 일지를 기록한다.\n\n먼저 내가 원하는 것은 구글, 네이버, 다음에 나의 블로그의 태그, 카테고리, 타이틀로 검색어가 노출이 되는 것이다.\n이를 위해서 무엇을 해야 하는지를 정리한다.\n\n## robots.txt\nrobots.txt는 CRA로 React Project를 생성했을 때도, 자동으로 생성해줄만큼 가장 기본적인 요소이다. 이는 가종 검색 엔진의 Posting을 Crawling하는 장치들에게 해당 Posting에 대한 접근 권한을 명시해놓는 곳이다. 따라서, 작성 시에는 간략하게 다음과 같이 표현하는 것이 일반적이다.\n```text\nUser-agent: *\nDisallow:\n``` \n이는 어떠한 검색 엔진 봇의 접근을 허락하며, 모든 하위 uri에 대한 접근을 허락한다는 것이다.\n더 알고 싶다면 공식 문서를 참고하자. https://www.robotstxt.org/robotstxt.html\n\n## sitemap.xml\n웹 페이지 내의 모든 페이지 목록을 나열한 파일이다. 이는 site에 해당하는 모든 url을 등록하고, 어느곳에 어느 컨텐츠가 존재하는지를 알려주는 mapping table이라고 볼 수 있다.\n이를 명시해두어야만 후에 bot들이 작업을 할 때, 조회를 하여 사용할 수 있다. 이를 생성하기 위한 Script는 해당 Project가 포함하고 있다.\n[euidong.github.io's dev branch](https://github.com/euidong/euidong.github.io/blob/dev/generater.js)\n\n---\n# Reference\n\n- Tumbnail : Photo by [NASA](https://unsplash.com/@nasa?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/website?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n  ","slug":"seo","title":"SEO","category":"Web","tags":["SEO","GoogleSearchEngine","검색어 노출","구글 검색어 노출"],"date":"2022년 4월 20일 00:00","thumbnailSrc":"https://euidong.github.io/images/web.jpg"}],"categorizedPosts":{"Algorithm":[{"content":"## DFS(Depth First Search)\nGraph의 탐색에서 가장 기본이 되는 방법입니다. 한 점에서 연결된 다른 점으로 이동을 하면서, 모든 연결된 점을 순화하는 것을 목표로 가진다고 가정해봅시다. 이때, 정점을 고르는 방식에 따라서, DFS, BFS로 나눕니다. DFS에서는 자신과 연결된 정점 중에서 하나를 선택하고 이동한 뒤에 해당 점에서 다시 연결된 지점을 찾아서 이동합니다. 즉, 바로 지금 뽑은 점에 인접해있는 지점이 이전에 인접해있던 지점보다 가중치가 높다는 것입니다. 이를 모두 진행하고도 답을 찾을 수 없다면, 이제 이전 시점으로 돌아와서 다시 작업을 재개하는 방식입니다.\n\n이를 구현하기 위해서는 `Stack`이 가장 중요합니다. 이전의 연결되었던 점보다 현재 연결된 점이 더 중요하기 때문에, 현재가 우선순위가 높지만, 후에 이를 다시 찾아와야 하기 때문에, 이를 저장하기 위한 자료구조가 필요한데 이것이 `Stack`이 되는 것입니다.\n\n따라서, 이를 직접 구현해보면 다음과 같습니다.\n```python\nadj = [\n  [2,3],\n  [3],\n  [0,3],\n  [0,1,2]\n]\n\nvisited = [False] * 4\nstack = [(0, visited)]\nwhile len(stack) > 0:\n  cur, visited = stack.pop(-1)\n  visited[cur] = True\n  for next in adj[cur]:\n    if visited[next] === False:\n      stack.append((next, visited))\n```\n또는, Recursive Call(함수의 재귀 호출)을 통해서 구현할 수 있습니다. 재귀 호출을 통한 구현이 더 일반적이며, 이해하기 쉬운 구조이기 때문에 많이 사용됩니다. 왜냐하면, 함수는 기본적으로 `stack` 형식으로 호출한 함수들을 쌓아두기 때문에, 더 원활한 구현이 가능합니다. \n```python\nadj = [\n  [2,3],\n  [3],\n  [0,3],\n  [0,1,2]\n]\n\ndef dfs(cur, visited):\n  visited[cur] = True\n  for next in adj[cur]:\n    if visited[next] === False:\n      dfs(next, visited)\n\ndfs(0, [-1] * 4)\n```\n\n추가적으로 만약 순회해야 하는 그래프가 확실하게 모두 연결된 그래프가 아니라면(중간에 간선이 끊겨 연결이 되지 않는 정점이 존재하는 경우), 우리는 모든 정점에서 `dfs`를 수행하도록 설정을 해주어야 합니다. 그래야만 전체 점을 순환할 수 있습니다.\n\n```python\nadj = [\n  [2,3],\n  [3],\n  [0,3],\n  [0,1,2]\n\n]\n\ndef dfs(cur):\n  visited[cur] = True\n  for next in adj[cur]:\n    if visited[next] === False:\n      dfs(next)\n\ndef dfsAll():\n  visited = [False] * len(adj)\n  for v in range(len(adj)):\n    if not visited[v]:\n      dfs(v)\n  \n```\n\n### 시간복잡도\n\n일반적으로 모든 노드를 순환하는 것이 목표라면, \n- 인접 리스트 : $O(|V| + |E|)$\n- 인접 행렬 : $O(V^2)$ \n\n\n# Example\n\n> **연결된 부분집합 갯수**\n\ndisjoint set을 통해서 구현할 수 있는 문제이지만, DFS를 통해서 쉽게 구현할 수 있습니다. 바로, 앞 서 보았던 `dfsAll`에서 `dfs`의 호출 횟수를 counting하면 값을 구할 수 있습니다.\n\n```python\n# adj = [[...], [...], ...]\n# visited = [False, False, ..]\n\ndef dfs(cur):\n  visited[cur] = True\n  for next in adj[cur]:\n    if not visited[next]:\n      dfs(next)\n\ndef dfsAll():\n  visited = [False] * len(adj)\n  cnt = 0\n  for v in range(len(adj)):\n    if not visited[v]:\n      cnt += 1\n      dfs(v)\n  return cnt\n```\n\n---\n\n> **위상정렬**\n\n위상 정렬이란 directed edge(유향 간선)로 이루어진 그래프를 규칙을 깨지 않으면서 정렬하는 방식입니다. 간선이 없는 경우에는 순서가 상관없지만, 간선이 있는 경우에는 순위가 있는 형태입니다. (우선순위 : 출발점 < 도착점)\n언뜻 보기에는 어려워 보이지만, DFS를 통해서 쉽게 해결할 수 있습니다. DFS를 실행하면서 끝에 지점에서 부터 배열에 저장하고 이를 역순으로 정렬하면 위상정렬이 되는 것을 볼 수 있습니다.\n\n```python\n# adj = [[...], [...], ...]\n# visited = [False, False, ..]\n\norder = []\n\ndef dfs(cur):\n  visited[cur] = True\n  for next in adj[cur]:\n    if not visited[next]:\n      dfs(next)\n  order.append(cur)\n\ndef dfsAll():\n  visited = [False] * len(adj)\n  order = []\n  for v in range(len(adj)):\n    if not visited[v]:\n      dfs(v)\n\nprint(order[::-1])\n```\n\n> **오일러 서킷(한 붓 그리기)**\n\n시작 점과 끝 점이 동일할 때, 모든 경로를 지나는 길찾기입니다.\n이를 해결할 때에는 우선 다음 조건을 먼저 확인해야 합니다.\n\n- 두 개 이상의 Component로 분리된 경우 만들 수 없습니다.\n- 어느 한 점이라도 차수가 홀수이면, 만들 수 없습니다.\n\n해결책은 간단합니다. 반복적으로 Circuit(순환)을 찾아서, 최종 구조로 완성하면 됩니다.\n\n다음이 기본적인 프로세스입니다.\n1. 먼저 자신으로 시작해서 자신으로 돌아오는 순환을 먼저 찾는다.\n2. 위의 과정을 진행하고도, 아직 지나지 않은 간선을 포함한 정점이 있다면, 이를 시작점으로 하여 다시 순환을 찾을 수 있다. 이러한 정점이 없을 때까지 이를 반복해서 시행한다.\n3. 이를 최초의 순환에 붙여나가면서, 최종으로 오일러 서킷을 완성한다.\n\n1번과 2번 과정에서 만약, 순환을 찾을 수 없다면 오일러 서킷이 불가능하다는 결론을 내리고 process를 종료합니다.\n\n```python\n# adj = [[...],[...],...] (인접행렬) - 동일 간선이 여러 개 있을 수도 있음\ndef eulerCircuit(cur, circuit):\n  for next in range(len(adj)):\n    if adj[cur][next] > 0:\n      adj[cur][next] -= 1\n      adj[next][cur] -= 1\n      eulerCircuit(next, circuit)\n  circuit.push_back(cur)   \n```\n\n**만약,** 시작점과 끝점이 다른 EulerTrail일 경우에는 임의로 시작점과 끝점을 잇고, Euler Circuit을 찾은 뒤에 삭제하면 됩니다.\n","slug":"dfs1","title":"DFS(1)-기본","category":"Algorithm","tags":["DFS","Graph","Tree"],"date":"2022년 2월 3일 00:00","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"\n이전에는 DFS의 기본이 되는 요소에 대해서 알아보았지만, 이제는 좀 더 심화적인 부분을 배워보고자 한다.   \nDFS가 그래프를 순회하면서 만드는 DFS Spanning Tree에 대한 내용이다.\n\n우리는 총 4가지로 간선을 분류할 수 있습니다. \n1. **Tree Edge(트리 간선)**- DFS Spanning Tree에 포함된 간선\n2. **Forward Edge(순방향 간선)** - 해당 간선이 가르키는 정점이 DFS Spanning Tree에서 자신의 descendant(후손)에 속하는 경우\n3. **Backward Edge(역방향 간선)** - 해당 간선이 가르키는 정점이 DFS Spanning Tree에서 자신의 ancestor(조상)에 속하는 경우\n4. **Cross Edge(교차 간선)** - 해당 간선이 가르키는 정점이 후손도 조상도 아닌 sibiling(형제 또는 그들의 자손)에 속하는 경우\n\n![<img src=\"/images/dfs-spanning-tree.png\" width=\"190\" />](/images/dfs-spanning-tree.png)\n\n이를 구현하기 위해서는 총 두 개의 추가적인 자료구조가 필요하다.   \n1. order[1...N] = 해당 노드의 발견 순서\n2. finished[1...N] = 모든 간선의 사용 여부\n\n```python\nadj = [\n  [1,3],\n  [2],\n  [1],\n  [1,2]\n]\nN = len(adj)\n\norder = [-1] * N\nfinished = [False] * N\ncnt = [0]\ndef dfs(curr):\n  order[curr] = cnt[0]\n  cnt[0] += 1\n  for next in adj[curr]:\n    prefix = curr + \"에서 \" + next + \"까지는\"\n    # 아직 방문하지 않았다면, 트리 간선이다.\n    if order[next] == -1:\n      print(prefix + \"트리 간선이다.\")\n      dfs(next)\n    # 만약 다음 정점의 order가 더 낮다면, 순방향 간선이다.\n    elif order[next] > order[curr]:\n      print(prefix + \"순방향 간선이다.\")\n    # 만약, 다음 정점이 아직 거쳐야 하는 정점이 있다면, 역방향 간선이다.\n    elif not finished[next]:\n      print(prefix + \"역방향 간선이다.\")\n    # 그 외에는 교차 간선이다.\n    else:\n      print(prefix + \"교차 간선이다.\")\n  finished[curr] = True\n\ndef dfsAll():\n  for i in N:\n    if order[i] == -1:\n      dfs(i)\n```\n\n위와 같이 구현하게 되면, 적절하게 간선을 구분할 수 있다. 위에는 방향이 존재하는 그래프였지만, 만약 방향이 존재하지 않는 무향 그래프라면 위의 과정을 좀 더 단순화할 수 있다.\n먼저 간선은 다음과 같이 줄어든다.\n\n1. **트리 간선** = DFS Spanning Tree에 포함된 간선\n2. **중첩 간선** = DFS Spanning Tree에 포함되지 않은 간선\n\n다음과 같이 총 2개로 줄어드는 것을 볼 수 있다. 교차 간선과 역방향 간선은 기본적으로 이후에 방문하는 정점에서 이미 방문한 정점으로 이동하는 것인데 이런 일은 무향 그래프에서는 발생하지 않기 때문에 존재할 수 없다.\n그러면, 구현은 다음과 같이 진행됩니다.\n\n```python\nadj = [\n  [1,2,3],\n  [0,2,3],\n  [0,1,3],\n  [0,1,2]\n]\nN = len(adj)\n\norder = [-1] * N\n# finish는 필요하지 않다.\ncnt = [0]\ndef dfs(curr):\n  order[curr] = cnt[0]\n  cnt[0] += 1\n  for next in adj[curr]:\n    prefix = curr + \"에서 \" + next + \"까지는\"\n    # 아직 방문하지 않았다면, 트리 간선이다.\n    if order[next] == -1:\n      print(prefix + \"트리 간선이다.\")\n      dfs(next)\n    # 만약 다음 정점의 order가 더 낮다면, 중첩 간선이다.\n    # 여기서 유의해야 할 점은 바로 중첩 간선은 두 번 호출된다는 점이다.\n    # 중첩 간선이기 때문에 서로 한 번씩 호출히기 때문이다.\n    # 이를 구분하기 위해서 order를 사용할 수 있다.\n    elif order[next] < order[curr]:\n      print(prefix + \"order가 높은 곳에서 낮은 곳으로 가는 중첩 간선이다.\")\n    else:\n      print(prefix + \"order가 낮은 곳에서 높은 곳으로 가는 중첩 간선이다.\")\n\ndef dfsAll():\n  for i in N:\n    if order[i] == -1:\n      dfs(i)\n```\n\n\n여기서 각 간선의 특징을 이해하면, 다른 문제를 풀기 쉽다.\n1. 역방향 또는 중첩 간선의 갯수 = circle의 갯수\n\n\n\n[...continue]\n","slug":"dfs2","title":"DFS(2)-DFS Spanning Tree","category":"Algorithm","tags":["DFS","Graph","Tree","FindCircleInGraph"],"date":"2022년 4월 23일 10:30","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"},{"content":"여러 개의 Vertex(정점)와 그를 잇는 Edge(간선)로 이루어진 형태의 자료 구조를 의미한다. \n\n## 핵심 종류\n- 무향 그래프: 방향이 없이 선으로 이어진 그래프\n- 방향 그래프: 방향을 가진 그래프로 한 정점에서 다른 정점으로 가는 방향을 명시한 그래프\n- 가중치 그래프: 각 간선이 가중치를 가지는 형태를 그래프\n- 이분 그래프: 정점을 두 개의 그룹으로 나누었을 때, 각 그룹은 서로 연결되지 않은 점들로만 이루어지는 그래프\n- **방향 비순환 그래프(Directed Acyclic Graph(DAG))**: 어느 정점에서 시작해도 cycle(순환)이 존재하지 않는 형태의 그래프. 이 그래프 형태에 tree(트리)도 해당되며, 이것이 특별한 이유는 선형으로 정렬하는 것이 가능하기 때문이다. ([DFS_위상정렬 참고](/post/DFS))\n\n## Dense vs Sparse\n그래프 관련 문제를 해결할 때, 반드시 고려해야 할 점은 해당 그래프가 Dense(밀도가 높은, edge가 많은)한 경우와 Sparse(희귀한, edge가 적은)한 경우를 모두 고려해주어야 한다. 이에 따라서, 시간복잡도가 굉장히 천차만별하게 나타나기 때문이다.\n\n\n## 표현 방법\n1. adjacent list(인접 리스트)   \n  각 정점마다 해당 정점에서 나가는 간선의 목록을 저장해서 그래프를 표현하는 법\n  ```python\n  import sys\n  # N = 정점의 수, M = 간선의 수\n  N, M = [int(i) for i in sys.stdin.readline().split()]\n  adj = [[] for _ in range(N)]\n  for _ in range(M):\n    a, b = [int(i) for i in sys.stdin.readline().split()]\n    adj[a].append(b)\n    # 무향 그래프에서는 다음과 같이 반대 방향도 추가해주어야 한다.\n    adj[b].append(a)\n  ```\n2. adjacent matrix(인접 행렬)   \n  인접 리스트 방식의 단점은 특정 두 정점이 연결 되었는지를 알기 위해서는 해당 정점과 연결된 모든 정점을 확인해야 한다. 인접 행렬에서는 이를 해결할 수 있다. 연결 여부를 직접 2차원 $V \\times V$ 행렬로 나타내기 때문에 이를 바로 index 조회로 알 수 있다. **하지만,** 메모리를 더 잡아 먹을 수도 있고, 단순히 연결된 정점만 조회하는 연산일 경우에는 오히려 모든 정점을 조회해야 하기 때문에 비용이 증가할 수 있다. (Sparse한 graph일 수록 비용 증가가 크다.)\n  ```python\n  import sys\n  # N = 정점의 수, M = 간선의 수\n  N, M = [int(i) for i in sys.stdin.readline().split()]\n  adj = [[0 for _ in range(N)] for _ in range(N)]\n  for _ in range(M):\n    a, b = [int(i) for i in sys.stdin.readline().split()]\n    adj[a][b] += 1\n    # 무향 그래프에서는 다음과 같이 반대 방향도 추가해주어야 한다.\n    adj[b][a] += 1 \n  ```","slug":"graph","title":"Graph","category":"Algorithm","tags":["Graph"],"date":"2022년 4월 20일 12:00","thumbnailSrc":"https://euidong.github.io/images/algorithm.png"}],"Docker":[{"content":"# Mysql\n\nMysql is a basic Database to store countless data. It is RDMS(This think that Relation is very very very important than any other things). You can Read, Create, Update, Delete data with it faster, managable (like transaction) than FileSystem.\nIt is manage by Oracle. And It can get good performance in read.\n\nEspectially 5.7 version is stable version. So industry use this version for development or test.\n\n![why-use-5.7](/images/why-use-5.7.png)\n\nIf you want get more information [click this](https://mysql.com)\n\n# Docker\n\nDocker is a virtualization application.\nIt is usally show more performance than any other virtualization machine program.\nBecase It use container.\nSo, It can make more efficient feature.\nIf you want get database running in Linux then you just build and run container that has database with Linux.\nWhen you anymore need taht database, you just delete that container.\nIt's so simple, clear. Let's enjoy.\n\nIf you want get more information [click this](https://www.docker.com/)\n\n### Install\n\nFollowing That\nhttps://www.docker.com/get-started\n\n# Mysql with Docker\n\n### Just Run script.\n\n```bash\nsudo docker run \\ # run container\n -e MYSQL_ROOT_PASSWORD=qwe123 \\ # setting MYSQL_ROOT_PASSWORD\n -e MYSQL_DATABASE=just \\ # default database name\n -e TZ=Asia/Seoul \\ # setting Timezone\n -p 3309:3306 \\ # setting port (my Pc port:container port)\n mysql:5.7 \\ # image name\n --character-set-server=utf8 \\ # setting utf8\n --collation-server=utf8_unicode_ci # setting utf8\n```\n\n### With compose file\n\ndocker-compose.yml\n\n```yml\nversion: \"3.7\"\nservices:\n  # Mysql Server\n  db:\n    image: mysql:5.7\n    # mysql utf-8 설정\n    command:\n      - --character-set-server=utf8\n      - --collation-server=utf8_unicode_ci\n    # db password 및 db 자동 생성\n    environment:\n      MYSQL_ROOT_PASSWORD: \"qwe123\"\n      MYSQL_DATABASE: \"just\"\n      MYSQL_TCP_PORT: \"3306\"\n      TZ: \"Asia/Seoul\"\n    ports:\n      - \"3309:3306\"\n    # for db data backUp\n    volumes:\n      - ./mysql/data:/var/lib/mysql\n```\n\n```bash\ndocker-compose up --build\n```\n\nmore information => https://docs.docker.com/get-started/\n\nmore infomation => https://docs.docker.com/compose/","slug":"docker-mysql","title":"Docker Mysql","category":"Docker","tags":["virtualEnv","mysql"],"date":"2022년 4월 20일 12:00","thumbnailSrc":"https://euidong.github.io/images/hero.png"}],"Web":[{"content":"# Gatsby\n\nLink : https://www.gatsbyjs.com\n\n> Gatsby is a React-based open-source framework for creating websites and apps.\n> It's great whether you're building a portfolio site or blog,\n> or a high-traffic e-commerce store or company homepage.\n\ngatsby introduce themselves that sentense. they focus on that big, high performance, and complicated feature view.\nThat is gatsby's advantage. they can make high performance feature more faster.\n\n### Why?\n\n##### First. Bigger and Faster\n\nIt uses React And GraphQL feature.\nSo, it can make better performance than other static web site platform. ex) jk ...\n\n##### Second. Support many feature\n\n- It can do many thing in framework.\n\nhttps://www.gatsbyjs.com/docs/conceptual/\n\n##### Third. Showcase\n\n- gatsby Showcase\n\nhttps://themejam.gatsbyjs.org/showcase\n\n### This Blog's feature\n\n- novela Theme\n\nhttps://github.com/narative/gatsby-theme-novela\n\n### SetUp\n\n=> github : https://github.com/euidong/euidong.github.io\n\n##### 1. Install\n\n```shell\n$ mkdir blog\n$ yarn add react react-dom gatsby @narative/gatsby-theme-novela\n$ yarn install\n```\n\n##### 2. set script\n\n`blog/package.json`\n\n```json\n{\n  \"licenses\": [\n    {\n      \"type\": \"MIT\",\n      \"url\": \"https://www.opensource.org/licenses/mit-license.php\"\n    }\n  ],\n  \"dependencies\": {\n    \"@narative/gatsby-theme-novela\": \"^0.18.4\",\n    \"gatsby\": \"^2.28.0\",\n    \"gh-pages\": \"^3.1.0\",\n    \"react\": \"^17.0.1\",\n    \"react-dom\": \"^17.0.1\"\n  },\n  \"scripts\": {\n    \"build\": \"gatsby build --prefix-paths\",\n    \"deploy\": \"gatsby build --prefix-paths && gh-pages -d public\",\n    \"dev\": \"gatsby develop\"\n  },\n  \"homepage\": \"https://euidong.github.io\"\n}\n```\n\n##### 3. post & author setting\n\nThis theme require at least one post and one author.\n\n`blog/content/authors/authors.yml`\n\n```yml\n- name: Euidong Jung\n  authorsPage: true\n  bio: |\n    Dev - Lang : Javascript Typescript <br />\n    Dev - Front : ReactJS ReactNative <br />\n    Dev - Back : NodeJS Apollo Express <br />\n    Dev - ENV : CloudNative Docker Kubernates AWS\n  avatar: ./avatars/euidong-avatar.jpeg\n  featured: true\n  social:\n    - url: https://github.com/euidong\n```\n\nand add image to\n`blog/content/authors/avatars/euidong-avatar.jpeg`\n\n`blog/content/posts/2021-01-03-gatsby/index.mdx`\n\n```mdx\n---\ntitle: Gatsby Blog\nauthor: Euidong Jung\ndate: 2021-01-03\nhero: ./images/gatsby.png\nexcerpt: Gatsby Flatform\n---\n\n# hellow world\n\n### good world\n\n##### happy world\n```\n\n##### 4. Icon\n\n`blog/src/@narative/gatsby-theme-novela/components/Logo`\n\n```javascript\nimport React from \"react\";\nimport { Link } from \"gatsby\";\nimport LogoBlack from \"../../../../image/icon/logo-black.png\";\nimport LogoWhite from \"../../../../image/icon/logo-white.png\";\n\n/**\n * Paste in your SVG logo and return it from this component.\n * Make sure you have a height set for your logo.\n * It is recommended to keep the height within 25-35px.\n */\nexport default function Logo({ fill }) {\n  return (\n    <Link\n      to=\"/\"\n      style={{\n        fontSize: \"40px\",\n        fontWeight: 700,\n        fontFamily: \"Merriweather',Georgia,Serif\",\n      }}\n    >\n      <img\n        src={fill === \"#fff\" ? LogoWhite : LogoBlack}\n        alt=\"logo\"\n        style={{ height: \"60px\" }}\n      />\n    </Link>\n  );\n}\n```\n\n##### 5. testing\n\n```shell\n$ yarn dev  # testing\n```\n\n##### 6. deployment\n\nSelect static web site deploy platform.(ex. gh-page / aws s3 / heroku ...)\n\n```shell\n$ yarn deploy # deploying to gh-page\n```\n\nIf you want deploy instantly when push to branch. You can use github action. (It is simple CI/CD)\n\nSee bellow example\n\nblog/.github/workflows/main.yml\n\n```yml\nname: github pages\n\non:\n  push:\n    branches:\n      - dev\n\njobs:\n  deploy:\n    runs-on: ubuntu-18.04\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Setup Node\n        uses: actions/setup-node@v2.1.2\n        with:\n          node-version: \"12.x\"\n\n      - name: Cache dependencies\n        uses: actions/cache@v2\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-node-\n\n      - name: Install yarn\n        run: npm install -g yarn\n\n      - name: Install node_modules\n        run: yarn install\n\n      - name: Build\n        run: yarn build\n\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./public\n```\n\nIt is status Badge.\n![github pages](https://github.com/euidong/euidong.github.io/workflows/github%20pages/badge.svg?branch=dev&event=push)","slug":"gatsby","title":"Gatsby","category":"Web","tags":["Gatsby","MDX","Blog"],"date":"2022년 4월 20일 12:00","thumbnailSrc":"https://euidong.github.io/images/gatsby.png"},{"content":"열심히 만든 Blog를 검색 엔진들에 노출하기 위한 일지를 기록한다.\n\n먼저 내가 원하는 것은 구글, 네이버, 다음에 나의 블로그의 태그, 카테고리, 타이틀로 검색어가 노출이 되는 것이다.\n이를 위해서 무엇을 해야 하는지를 정리한다.\n\n## robots.txt\nrobots.txt는 CRA로 React Project를 생성했을 때도, 자동으로 생성해줄만큼 가장 기본적인 요소이다. 이는 가종 검색 엔진의 Posting을 Crawling하는 장치들에게 해당 Posting에 대한 접근 권한을 명시해놓는 곳이다. 따라서, 작성 시에는 간략하게 다음과 같이 표현하는 것이 일반적이다.\n```text\nUser-agent: *\nDisallow:\n``` \n이는 어떠한 검색 엔진 봇의 접근을 허락하며, 모든 하위 uri에 대한 접근을 허락한다는 것이다.\n더 알고 싶다면 공식 문서를 참고하자. https://www.robotstxt.org/robotstxt.html\n\n## sitemap.xml\n웹 페이지 내의 모든 페이지 목록을 나열한 파일이다. 이는 site에 해당하는 모든 url을 등록하고, 어느곳에 어느 컨텐츠가 존재하는지를 알려주는 mapping table이라고 볼 수 있다.\n이를 명시해두어야만 후에 bot들이 작업을 할 때, 조회를 하여 사용할 수 있다. 이를 생성하기 위한 Script는 해당 Project가 포함하고 있다.\n[euidong.github.io's dev branch](https://github.com/euidong/euidong.github.io/blob/dev/generater.js)\n\n---\n# Reference\n\n- Tumbnail : Photo by [NASA](https://unsplash.com/@nasa?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/website?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n  ","slug":"seo","title":"SEO","category":"Web","tags":["SEO","GoogleSearchEngine","검색어 노출","구글 검색어 노출"],"date":"2022년 4월 20일 00:00","thumbnailSrc":"https://euidong.github.io/images/web.jpg"}]}},"__N_SSG":true}